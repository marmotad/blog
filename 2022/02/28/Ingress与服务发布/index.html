<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marmotad.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本章小结本章重点讲述了Ingress资源及Ingress控制器相关的话题，并重点讲解了Contour控制器的HTTP高级路由功能。  Ingress资源主要用于向Kubernetes集群外部发布服务，它能够通过一个统一的接口管理所有南北向的流量。 Ingress是标准Kubernetes API资源类型之一，它支持基于PATH和虚拟主机的路由机制。 Ingress资源定义的路由功能要转为Ingre">
<meta property="og:type" content="article">
<meta property="og:title" content="Ingress与服务发布">
<meta property="og:url" content="https://marmotad.github.io/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/index.html">
<meta property="og:site_name" content="marmotad">
<meta property="og:description" content="本章小结本章重点讲述了Ingress资源及Ingress控制器相关的话题，并重点讲解了Contour控制器的HTTP高级路由功能。  Ingress资源主要用于向Kubernetes集群外部发布服务，它能够通过一个统一的接口管理所有南北向的流量。 Ingress是标准Kubernetes API资源类型之一，它支持基于PATH和虚拟主机的路由机制。 Ingress资源定义的路由功能要转为Ingre">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224171152147.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220225082946922.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224182206457.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224182849722.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185456515.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185535602.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185613668.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185629970.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185702279.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185720589.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224190429470.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224190904842.png">
<meta property="article:published_time" content="2022-02-28T08:56:24.000Z">
<meta property="article:modified_time" content="2022-02-28T08:59:20.648Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marmotad.github.io/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224171152147.png">

<link rel="canonical" href="https://marmotad.github.io/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Ingress与服务发布 | marmotad</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="marmotad" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">marmotad</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://marmotad.github.io/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="myBlog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="marmotad">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ingress与服务发布
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-28 16:56:24 / 修改时间：16:59:20" itemprop="dateCreated datePublished" datetime="2022-02-28T16:56:24+08:00">2022-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>本章重点讲述了Ingress资源及Ingress控制器相关的话题，并重点讲解了Contour控制器的HTTP高级路由功能。</p>
<ul>
<li>Ingress资源主要用于向Kubernetes集群外部发布服务，它能够通过一个统一的接口管理所有南北向的流量。</li>
<li>Ingress是标准Kubernetes API资源类型之一，它支持基于PATH和虚拟主机的路由机制。</li>
<li>Ingress资源定义的路由功能要转为Ingress控制器上的配置信息，并由控制器负责执行真正的路由过程。</li>
<li>Ingress Nginx是由Kubernetes社区维护的基于Nginx的Ingress控制器。</li>
<li>Contour是另一款Ingress控制器，它以Envoy为数据平面，基于自有的HTTPProxy CRD大大扩展了原生Ingress API的功能。</li>
<li>HTTPProxy封装了Envoy的部分API，从而支持流量切分、流量镜像、基于标头的路由、自定义使用的负载均衡策略、超时和重试、后端端点的健康状态检测等高级功能。</li>
</ul>
<h1 id="Ingress与服务发布"><a href="#Ingress与服务发布" class="headerlink" title="Ingress与服务发布"></a>Ingress与服务发布</h1><p>通常把Kubernetes集群内部的通信称为东西向流量，而把集群内外部的通信称为南北向流量。本章主要介绍Kubernetes为统一管理Ingress流量而特地设计的同名资源类型及其支撑组件Ingress控制器（Ingress Nginx和Contour）相关的话题。</p>
<h2 id="Ingress资源"><a href="#Ingress资源" class="headerlink" title="Ingress资源"></a>Ingress资源</h2><p>Kubernetes上的NodePort和LoadBalancer类型的Service资源能够把集群内部服务暴露给集群外部客户端访问，但两个负载均衡跃点必然产生更大的网络延迟，且无疑会大大增加组织在使用云服务方面的费用开销。因此，Kubernetes为这种需求提供了一种更为高级的流量管理约束方式，尤其是对HTTP/HTTPS协议的约束。Kubernetes使用Ingress控制器作为统一的流量入口，管理内部各种必要的服务，并通过Ingress这一API资源来描述如何区分流量以及内部的路由逻辑。有了Ingress和Ingress控制器，我们就可通过定义路由流量的规则来完成服务发布，而无须创建一堆NodePort或LoadBalancer类型的Service，而且流量也会由Ingress控制器直接到达Pod对象。</p>
<h3 id="Ingress与Ingress控制器流量转发"><a href="#Ingress与Ingress控制器流量转发" class="headerlink" title="Ingress与Ingress控制器流量转发"></a>Ingress与Ingress控制器流量转发</h3><p>本质上来说，Ingress资源基于HTTP虚拟主机或URL路径的流量转发规则，它把需要暴露给集群外部的每个Service对象，并映射为Ingress控制器上的一个虚拟主机或某虚拟主机上的一个PATH路径（例如/auth等），如图13-1所示。<br><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224171152147.png" alt="image-20220224171152147"></p>
<p>Ingress资源自身并不能进行“流量穿透”，它仅是一组路由规则的集合，这些规则要真正发挥作用还需要其他功能的辅助，例如监听某套接字，然后根据这些规则的匹配机制真正完成流量路由等。实现该功能的组件就是Ingress控制器。<br>Ingress控制器是Kubernetes集群的一个重要附件，它更像是一个自定义控制器，但支撑着API Server内置的Ingress资源及相关功能的实现，该控制器需要在集群上单独部署。<br>Ingress控制器本身就是一类以代理HTTP/HTTPS协议为主要功能的代理程序，通常兼有传输层代理功能，甚至可能支持更多的应用层协议，如Redis协议等。它可以由任何具有反向代理（HTTP/HTTPS协议)功能的服务程序实现，例如Nginx、Envoy、HAProxy、Vulcand和Traefik等。Ingress控制器自身也是运行在Kubernetes集群上的Pod资源对象，通常能够与集群上被代理的服务的Pod直接通信，如图13-2所示。</p>
<p><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220225082946922.png" alt="image-20220225082946922"></p>
<p>可用作Ingress控制器的Nginx、Envoy和Traefik等应用程序的配置文件格式不尽相同，甚至无法互相兼容，因此，Ingress控制器自身得能够识别标准的Ingress资源且能够自动完成匹配到自身的配置格式转化，还要能够支持配置信息的动态重载，而无须重新应用进程才能满足Kubernetes应用场景中的需求。<br>Kubernetes集群支持同时部署多个不同类型的Ingress控制器，为避免一个Ingress被多个控制器重复加载，或者有意限制它仅可由某个特定的控制器加载，通常还需要在Ingress资源上注明它要适配的Ingress控制器类型。<br>使用Ingress资源进行流量分发时，Ingress控制器可基于某Ingress资源定义的规则将客户端的请求流量直接转发至Service对应的后端Pod资源之上，这种转发机制会绕过Service资源，从而省去了由kube-proxy实现的端口代理开销。在图13-2中，Ingress规则需要由一个Service资源对象辅助识别所有相关的Pod对象，但Ingress控制器可经由api.ilinux.io规则的定义直接将请求流量调度至Pod3或Pod4，而无须经由Service对象API的再次转发，wap相关规则的作用方式与此类似。</p>
<h3 id="Ingress资源规范"><a href="#Ingress资源规范" class="headerlink" title="Ingress资源规范"></a>Ingress资源规范</h3><p>Ingress定义在extensions群组中，隶属于名称空间级别，它通过规则（.spec.rules）来定义流量路由逻辑，每个规则定义了其服务的主机名称，以及该主机的每个路径所映射到的后端，从而实现将发往某主机的流量根据路径的不同路由到不同的后端端点之上，如图13-2所示。Kubernetes v1.19版本中，Ingress资源规范终于从长达数年的v1beta1版本进化至稳定的v1版本。</p>
<h4 id="v1beta1版本的Ingress资源"><a href="#v1beta1版本的Ingress资源" class="headerlink" title="v1beta1版本的Ingress资源"></a>v1beta1版本的Ingress资源</h4><p>v1beta1版本的Ingress资源位于API群组extensions之中，该版本的资源规范可用的字段及其简要说明如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span>    <span class="comment"># 资源所属的API群组和版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>                     <span class="comment"># 资源类型标识符</span></span><br><span class="line"><span class="attr">metadata:</span>                         <span class="comment"># 元数据</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>                   <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">annotations:</span>   <span class="comment"># 资源注解，v1beta1使用下面的注解来指定要解析该资源的控制器类型</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 适配的Ingress控制器类别</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>            <span class="comment"># 名称空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">rules</span> <span class="string">&lt;[]Object&gt;</span>              <span class="comment"># Ingress规则列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">host</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 虚拟主机的FQDN，支持“*”前缀通配，不支持IP，不支持指定端口</span></span><br><span class="line">    <span class="string">http</span> <span class="string">&lt;Object&gt;</span></span><br><span class="line">      <span class="string">paths</span> <span class="string">&lt;[]Object&gt;</span>          <span class="comment"># 虚拟主机PATH定义的列表，由path和backend组成</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">path</span> <span class="string">&lt;string&gt;</span>           <span class="comment"># 流量匹配的HTTP PATH，必须以/开头</span></span><br><span class="line">        <span class="string">pathType</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 匹配机制，支持Exact、Prefix和ImplementationSpecific</span></span><br><span class="line">        <span class="string">backend</span> <span class="string">&lt;Object&gt;</span>    <span class="comment"># 匹配流量要转发的目标后端</span></span><br><span class="line">          <span class="string">resource</span> <span class="string">&lt;Object&gt;</span>     <span class="comment"># 引用的同一名称空间下的资源，与下面两个字段互斥</span></span><br><span class="line">          <span class="string">serviceName</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 引用的Service资源的名称</span></span><br><span class="line">          <span class="string">servicePort</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># Service用于提供服务的端口</span></span><br><span class="line">  <span class="string">tls</span> <span class="string">&lt;[]Object&gt;</span>   <span class="comment"># TLS配置，用于指定上面rules中定义的需要工作在HTTPS模式的主机</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hosts</span> <span class="string">&lt;[]string&gt;</span>            <span class="comment"># 使用同一组证书的主机名称列表</span></span><br><span class="line">    <span class="string">secretName</span> <span class="string">&lt;string&gt;</span>         <span class="comment"># 保存数字证书和私钥信息的Secret资源名称</span></span><br><span class="line">  <span class="string">backend</span> <span class="string">&lt;Object&gt;</span>              <span class="comment"># 默认backend的定义，可嵌套字段及使用格式与rules字段中的相同</span></span><br><span class="line">  <span class="string">ingressClassName</span>  <span class="string">&lt;string&gt;</span>    <span class="comment"># ingress类名称，用于指定适配的控制器</span></span><br></pre></td></tr></table></figure>

<p>下面的示例（ingress-demo.yaml）中定义了一个Ingress资源规范，它把发往<a target="_blank" rel="noopener" href="http://www.ik8s.io主机的所有流量都代理至ik8s服务,把发往www.ilinux.io主机路径/foo%E4%B8%8A%E7%9A%84%E6%B5%81%E9%87%8F%E9%83%BD%E4%BB%A3%E7%90%86%E8%87%B3foo-svc%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%8F%91%E5%BE%80%E5%85%B6%E4%BB%96%E8%B7%AF%E5%BE%84%E7%9A%84%E6%B5%81%E9%87%8F%E9%83%BD%E4%BB%A3%E7%90%86%E8%87%B3bar-svc%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%80%8C%E4%BD%99%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%B5%81%E9%87%8F%E9%83%BD%E5%B0%86%E7%94%B1default-backend%E6%9C%8D%E5%8A%A1%E6%89%BF%E8%BD%BD%E3%80%82">www.ik8s.io主机的所有流量都代理至ik8s服务，把发往www.ilinux.io主机路径/foo上的流量都代理至foo-svc服务，发往其他路径的流量都代理至bar-svc服务，而余下的所有流量都将由default-backend服务承载。</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ik8s.io</span>     <span class="comment"># 第一个FQDN主机，所有流量都由同一个backend处理</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span>             <span class="comment"># 空路由表示到该主机的所有流量</span></span><br><span class="line">        <span class="attr">backend:</span>          <span class="comment"># 相应后端的定义</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">ik8s</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ilinux.io</span>   <span class="comment"># 第二个FQDN主机，服务于两个不同的路径</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span>        <span class="comment"># 第一个路由规则</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">foo-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span>             <span class="comment"># 第二个路由规则</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">bar-svc</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">tls:</span>         <span class="comment"># tls定义，用于指明哪个FQDN主机需要服务于HTTPS模式</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.ik8s.io</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">tls-ik8s</span></span><br><span class="line">  <span class="attr">backend:</span>     <span class="comment"># 默认的backend，用于处理无法被上述规则匹配到的所有流量</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">default-backend</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="v1版本的Ingress资源"><a href="#v1版本的Ingress资源" class="headerlink" title="v1版本的Ingress资源"></a>v1版本的Ingress资源</h4><p><font color="red">v1版本的Ingress资源被移向了networking.k8s.io这一API群组，该版本的资源规范与v1beta1版本的区别主要在spec.rules.http.backend的内嵌字段之上</font>，它的可用字段及其简要说明如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span>     <span class="comment"># 资源所属的API群组和版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span>     <span class="comment"># 资源类型标识符</span></span><br><span class="line"><span class="attr">metadata:</span>         <span class="comment"># 元数据</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">annotations:</span>    <span class="comment"># 资源注解，v1beta1版本使用下面的注解来指定要解析该资源的控制器类型</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 适配的Ingress控制器类别</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 名称空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">rules</span> <span class="string">&lt;[]Object&gt;</span>     <span class="comment"># Ingress规则列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">host</span> <span class="string">&lt;string&gt;</span>      <span class="comment"># 虚拟主机的FQDN，支持“*”前缀通配，不支持IP，不支持指定端口</span></span><br><span class="line">    <span class="string">http</span> <span class="string">&lt;Object&gt;</span></span><br><span class="line">      <span class="string">paths</span> <span class="string">&lt;[]Object&gt;</span> <span class="comment"># 虚拟主机PATH定义的列表，由path和backend组成</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">path</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 流量匹配的HTTP PATH，必须以/开头</span></span><br><span class="line">        <span class="string">pathType</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 支持Exact、Prefix和ImplementationSpecific，必选</span></span><br><span class="line">        <span class="string">backend</span> <span class="string">&lt;Object&gt;</span>        <span class="comment"># 匹配流量要转发的目标后端</span></span><br><span class="line">          <span class="string">resource</span> <span class="string">&lt;Object&gt;</span>     <span class="comment"># 引用的同一名称空间下的资源，与下面两个字段互斥</span></span><br><span class="line">          <span class="string">service</span> <span class="string">&lt;object&gt;</span>      <span class="comment"># 关联的后端Service对象</span></span><br><span class="line">            <span class="string">name</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 后端Service的名称</span></span><br><span class="line">            <span class="string">port</span> <span class="string">&lt;object&gt;</span>       <span class="comment"># 后端Service上的端口对象</span></span><br><span class="line">              <span class="string">name</span> <span class="string">&lt;string&gt;</span>     <span class="comment"># 端口名称</span></span><br><span class="line">              <span class="string">number</span> <span class="string">&lt;integer&gt;</span>  <span class="comment"># 端口号</span></span><br><span class="line">  <span class="string">tls</span> <span class="string">&lt;[]Object&gt;</span>   <span class="comment"># TLS配置，用于指定上述rules中定义的哪些主机需要工作在HTTPS模式下</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hosts</span> <span class="string">&lt;[]string&gt;</span>     <span class="comment"># 使用同一组证书的主机名称列表</span></span><br><span class="line">    <span class="string">secretName</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 保存数字证书和私钥信息的Secret资源名称</span></span><br><span class="line">  <span class="string">backend</span> <span class="string">&lt;Object&gt;</span> <span class="comment"># 默认backend的定义，可嵌套字段及使用格式与rules字段中的相同</span></span><br><span class="line">  <span class="string">ingressClassName</span>  <span class="string">&lt;string&gt;</span>   <span class="comment"># ingress类名称，用于指定适配的控制器</span></span><br></pre></td></tr></table></figure>

<p>下面的示例配置清单（ingress-v1-demo.yaml）中定义的Ingress资源与13.1.2节的资源清单示例中定义的Ingress资源功能完全相同，二者的唯一区别仅在于Ingress资源的版本。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ik8s.io</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span> </span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">ik8s</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span> </span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">foo-svc</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/bar</span> </span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">bar-svc</span></span><br><span class="line">            <span class="attr">port:</span> </span><br><span class="line">              <span class="attr">number:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>目前，为了尽可能地与众多项目中Ingress资源版本保持兼容，本章后面大多数Ingress资源示例将仍基于v1beta1版本进行说明。</p>
<h4 id="IngressClass资源"><a href="#IngressClass资源" class="headerlink" title="IngressClass资源"></a>IngressClass资源</h4><p>传统实现方法上，界定Ingress资源可由哪个Ingress控制器解析是由Ingress资源使用专有的资源注解kubernetes.io/ingress.class进行标识，而标识方式是在资源规范中同时支持使用.spec.ingressClassName来引用ingressClass资源，这种新的ingressClass资源类型将各种Ingress控制器按照其核心程序类别划分成逻辑组，并给予自定义的标识，具体的资源规范格式如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span> <span class="comment"># API资源群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressClass</span>                    <span class="comment"># 资源类型标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="string">ingressclass.kubernetes.io/is-default-class</span> <span class="string">&lt;boolean&gt;</span>  <span class="comment"># 是否为默认</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">controller</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 该类所关联的Ingress控制器</span></span><br><span class="line">  <span class="string">parameters</span> <span class="string">&lt;Object&gt;</span>   <span class="comment"># 控制器相关的参数，这些参数由引用的资源定义，可选字段</span></span><br><span class="line">    <span class="string">apiGroup</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 引用的目标资源所属的API群组</span></span><br><span class="line">    <span class="string">kind</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 引用的资源类型</span></span><br><span class="line">    <span class="string">name</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 引用的资源名称</span></span><br></pre></td></tr></table></figure>

<p>显然，IngressClass资源的使用价值与资源注解并无本质上的区别，但考虑到管理员的实践习惯及节约篇幅之目的，下面会尽量沿用资源注解的方式来为Ingress资源指定适配的Ingress控制器。</p>
<h3 id="Ingress资源类型"><a href="#Ingress资源类型" class="headerlink" title="Ingress资源类型"></a>Ingress资源类型</h3><p>基于HTTP协议暴露的每个Service资源均可以发布到一个独立的FQDN主机名之上，例如<a target="_blank" rel="noopener" href="http://www.ik8s.io,也可发布到某主机的url路径上,从而将它们整合到同一个web站点,例如www.ilinux.io/foo%E7%AD%89%E3%80%82%E8%87%B3%E4%BA%8E%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E5%8F%91%E5%B8%83%E4%B8%BAHTTPS%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%88%99%E5%8F%96%E5%86%B3%E4%BA%8E%E7%94%A8%E6%88%B7%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E3%80%82">www.ik8s.io，也可发布到某主机的URL路径上，从而将它们整合到同一个Web站点，例如www.ilinux.io/foo等。至于是否需要发布为HTTPS类型的应用则取决于用户的业务需求。</a></p>
<h4 id="单Service资源型Ingress"><a href="#单Service资源型Ingress" class="headerlink" title="单Service资源型Ingress"></a>单Service资源型Ingress</h4><p>暴露单个服务的方法有很多种，例如服务类型中的NodePort、LoadBalancer等，不过一样可以考虑使用Ingress来暴露服务，此时只需要为Ingress指定默认后端即可。例如下面的示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp-ingress</span></span><br><span class="line"><span class="attr">spec:</span>  <span class="comment"># 未定义任何主机表示配置为默认虚拟主机，可服务于到达该地址80端口的所有流量</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>Ingress控制器会为配置清单中的ingress/demo-ingress资源分配一个IP地址以接入请求流量，并将流量转发至示例中定义的demoapp-svc后端。</p>
<h4 id="基于URL路径进行流量分发"><a href="#基于URL路径进行流量分发" class="headerlink" title="基于URL路径进行流量分发"></a>基于URL路径进行流量分发</h4><p>垂直拆分或微服务架构中，每个小的应用都有其专用的Service资源暴露服务，但在对外开放的站点上，它们可能是财经、新闻、电商、无线端或API接口等一类的独立应用，每个应用可通过主域名的URI路径（path）分别接入，例如<a target="_blank" rel="noopener" href="http://www.ilinux.io/api%E3%80%81www.ilinux.io/wap%E4%BE%BF%E5%8F%AF%E7%94%A8%E4%BA%8E%E5%8F%91%E5%B8%83%E9%9B%86%E7%BE%A4%E5%86%85%E5%90%8D%E4%B8%BAapi%E5%92%8Cwap%E7%9A%84services%E8%B5%84%E6%BA%90%E3%80%82%E4%BA%8E%E6%98%AF%EF%BC%8C%E5%AF%B9%E5%BA%94%E5%9C%B0%E5%8F%AF%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BC%E5%A6%82%E4%B8%8B%E7%9A%84Ingress%E8%B5%84%E6%BA%90%EF%BC%8C%E5%B0%86%E5%AF%B9www.ilinux.io/api%E7%9A%84%E8%AF%B7%E6%B1%82%E7%BB%9F%E7%BB%9F%E8%BD%AC%E5%8F%91%E8%87%B3api">www.ilinux.io/api、www.ilinux.io/wap便可用于发布集群内名为api和wap的services资源。于是，对应地可创建一个类似如下的Ingress资源，将对www.ilinux.io/api的请求统统转发至api</a> Service资源，把对<a target="_blank" rel="noopener" href="http://www.ilinux.io/wap%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E8%87%B3wap">www.ilinux.io/wap的请求转发至wap</a> Service资源。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ilinux.io</span>  <span class="comment"># 明确指定了虚拟主机，则仅服务到达该FQDN的流量</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/wap</span>   <span class="comment"># 通过URI路径接入的第一个应用，将到达该路径的流量转发给wap后端</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">wap</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/api</span>   <span class="comment"># 通过URI路径接入的第二个应用，将到达该路径的流量转发给api后端</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">api</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="基于FQDN的虚拟主机"><a href="#基于FQDN的虚拟主机" class="headerlink" title="基于FQDN的虚拟主机"></a>基于FQDN的虚拟主机</h4><p>根据上面类型2描述的需求，也可以把每个应用分别以独立的FQDN主机名进行输出，例如使用wap.ik8s.io和api.ik8s.io分别发布集群内部的wap与api这两个Service资源。这种实现方案其实就是Web站点部署中的“基于主机名的虚拟主机”，将多个FQDN解析至同一个IP地址，然后根据主机头信息进行转发。下面是以独立FQDN主机形式发布服务的Ingress资源示例。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">api.ik8s.io</span>   <span class="comment"># 第一个FQDN虚拟主机名称</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span>   <span class="comment"># 后端服务api，该服务下的每个端点都是该虚拟主机的一个被代理目标</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">api</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">wap.ik8s.io</span>   <span class="comment"># 第二个FQDN虚拟主机名称</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span>              <span class="comment"># 后端服务wap</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">wap</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="TLS类型的Ingress资源"><a href="#TLS类型的Ingress资源" class="headerlink" title="TLS类型的Ingress资源"></a>TLS类型的Ingress资源</h4><p>这种类型能以HTTPS协议发布Service资源，基于一个含有私钥和证书的Secret对象（后面章节中讲述）即可配置TLS协议的Ingress资源，目前来说，Ingress资源仅支持单TLS端口，且会卸载TLS会话。在Ingress资源中引用此Secret对象即可让Ingress控制器加载并配置为HTTPS服务。下面是一个简单的TLS类型的Ingress资源示例。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-host</span></span><br><span class="line"><span class="attr">spec:</span>   <span class="comment"># 资源规范，未明确指定主机意味着设定默认主机，且tls将默认应用于该主机</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">secretName:</span> <span class="string">tls-ik8s</span> <span class="comment"># 引用的Secret对象，需要事先存在</span></span><br><span class="line">  <span class="attr">backend:</span>               <span class="comment"># 后端服务</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">homesite</span></span><br><span class="line">    <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h2 id="Ingress控制器部署与应用"><a href="#Ingress控制器部署与应用" class="headerlink" title="Ingress控制器部署与应用"></a>Ingress控制器部署与应用</h2><p>Ingress控制器自身也是运行在Pod中的容器应用，它们是一类具有代理及负载均衡功能的守护进程，而注册监视API Server上的Ingress资源，可根据这些资源上定义的流量路由规则生成相应应用程序专有格式的配置文件，并通过重载或重启守护进程而生效新配置。例如，对于Nginx来说，Ingress规则需要转换为Nginx的配置信息。然而，同样运行为Pod资源的Ingress控制器进程接入外部的请求流量常用的解决方案有两种。<br>1）<font color="red">以Deployment控制器管理Ingress控制器的Pod资源，通过NodePort或LoadBalancer类型的Service对象或者通过拥有外部IP地址（externalIP）的Service对象为其接入集群外部的请求流量。</font>这意味着，在生产环境中定义一个Ingress控制器时，必须在其前端定义一个负载均衡器，负载均衡器可以是LoadBalancer类型的Service，或用户自行管理的边缘路由器，如图13-3所示。<br><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224182206457.png" alt="image-20220224182206457">2）借助DaemonSet控制器，Ingress控制器的各Pod分别以单一实例的方式运行在Kubernetes集群中所有或部分工作节点之上，并配置这类Pod对象以hostPort（见图13-4左图）或hostNetwork（见图13-4右图）的方式在当前节点接入外部流量。<br><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224182849722.png" alt="image-20220224182849722">接下来的使用示例中，我们会在部署Ingress Nginx时设置其Service同时支持ExternalIP和NodePort，以便在没有可用的边缘路由器时能通过指定的外部IP访问Ingress Nginx控制器上的服务。</p>
<h3 id="Ingress-Nginx部署与测试"><a href="#Ingress-Nginx部署与测试" class="headerlink" title="Ingress Nginx部署与测试"></a>Ingress Nginx部署与测试</h3><p>Ingress-Nginx控制器在其项目源码目录中分别为aws、kind和baremetal等Kubernetes部署场景提供了各自适用的部署清单，这些部署位于项目的deploy/static/provider/目录中。本书以kubeadm部署的Kubernetes集群可归入baremetal场景，因而我们使用该子目录下的部署清单完成Ingress-Nginx控制器部署即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/deploy.yaml -O ingress-nginx-deploy.yaml</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f ingress-nginx-deploy.yaml</span></span><br></pre></td></tr></table></figure>

<p>该部署清单把所有资源都部署在ingress-nginx名称空间下，包括由Deployment控制器编排的ingress-nginx-controller Pod及用于配置应用的configmap/ingress-nginx-controller等。为了便于用户使用，该清单还创建了一个NodePort类型的service/ingress-nginx-controller资源，该Service资源通过TCP端口80和443分别服务于HTTP与HTTPS客户端。下面命令结果中的NodePort由Service控制器随机分配，不同部署环境中会有所差别。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get service/ingress-nginx-controller -n ingress-nginx</span></span><br><span class="line">NAME                      TYPE      …  EXTERNAL-IP          PORT(S)              AGE</span><br><span class="line">ingress-nginx-controller  NodePort  …  172.29.9.11   80:32012/TCP,443:30532/TCP  1m</span><br></pre></td></tr></table></figure>

<p>待ingress-nginx-controller的Pod资源转为正常运行状态后，我们便可以基于Pod发起服务发布测试。不过，本示例中尚且缺少一个可用的边缘负载均衡器，如图13-3中所示的externalLB，因此，外部客户端对Ingress控制器的访问暂时还只能通过&lt;NodeIP&gt;: &lt;NodePort&gt;或者&lt;ExternalIP&gt;:&lt;ServicePort&gt;进行。<br>生产应用场景中，我们通常会以DaemonSet结合NodeAffinity、PodAntiAffinity使用，甚至是利用Taints/Tolerations调度机制将Ingress控制器以单实例的方式运行行在专用的节点之上，并让Ingress控制器共享相关节点的名称空间，或者在Service上使用externalIP等来解决引入外部流量的问题。<br>下面以demoapp应用为例说明如何通过Ingress将应用发布到集群外部。创建namespace/ dev名称空间，并在该名称空间中分别新建deployment/demoapp和service/demoapp资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create namespace dev</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create deployment demoapp --image=<span class="string">&quot;ikubernetes/demoapp:v1.0&quot;</span> -n dev</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp -n dev -o wide</span></span><br><span class="line">NAME                       ……  IP           NODE                  ……</span><br><span class="line">demoapp-6c5d545684-v6djh   ……  10.244.1.7   k8s-node01.ilinux.io  ……</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create service clusterip demoapp --tcp=80 -n dev</span></span><br></pre></td></tr></table></figure>

<p>假设要同时在HTTP和HTTPS协议上发布dev名称空间下的service/demoapp服务，我们可以使用类似如下的资源清单（demoapp-ingress.yaml）进行。一旦为某个虚拟主机启用TLS，ingress-nginx控制器默认会将以HTTP明文协议发往该主机的所有请求重定向至对应的HTTPS主机，若希望同时保留二者，需要将注解nginx.ingress.kubernetes.io/ssl-redirect的值设置为false来禁用这种重定向功能。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;false&quot;</span> <span class="comment"># 禁止重定向HTTP到HTTPS</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">demoapp</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.ilinux.io</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">tls-ingress-www-ilinux</span></span><br></pre></td></tr></table></figure>

<p>随后，我们需要在dev名称空间中准备由tls ingress引用的secret/tls-ingress-ilinux资源，以便ingress-nginx控制器能够引用相应的TLS证书和私钥。这里仅出于测试目的，因而创建一个自签的证书即能满足要求，相应的步骤如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">openssl genrsa -out ingress-www-ilinux.key 2048</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">openssl req -new -x509 -key ingress-www-ilinux.key -out ingress-www-ilinux.crt \</span></span><br><span class="line"><span class="language-bash">      -subj /C=CN/ST=Beijing/L=Beijing/O=DevOps/CN=www.ilinux.io -days 3650</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create secret tls tls-ingress-www-ilinux --cert=ingress-www-ilinux.crt \</span></span><br><span class="line"><span class="language-bash">      --key=ingress-www-ilinux.key -n dev</span></span><br></pre></td></tr></table></figure>

<p>接下来，将上面清单中定义的ingress/demoapp-ingress资源创建到集群之上，便可以在集群外测试访问通过Ingress发布的demoapp服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f demoapp-ingress.yaml</span> </span><br><span class="line">ingress.extensions/demoapp-ingress created</span><br></pre></td></tr></table></figure>

<p>资源的描述信息中以易读格式给出了各Ingress规则的简明配置及生效机制，而且通过Events段给出了关键事件的简单说明，如下面的命令结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe ingress demoapp-ingress -n dev</span></span><br><span class="line">Name:             demoapp-ingress</span><br><span class="line">Namespace:        dev</span><br><span class="line">Address:          172.29.9.12</span><br><span class="line">Default backend:  default-http-backend:80 (&lt;error: endpoints &quot;default-http-backend&quot; not found&gt;)</span><br><span class="line">TLS:</span><br><span class="line">  tls-ingress-www-ilinux terminates www.ilinux.io</span><br><span class="line">Rules:</span><br><span class="line">  Host           Path  Backends</span><br><span class="line"></span><br><span class="line">----           ----  --------</span><br><span class="line"></span><br><span class="line">  www.ilinux.io  </span><br><span class="line">                 /   demoapp:80 (10.244.1.7:80)</span><br><span class="line">Annotations:     kubernetes.io/ingress.class: nginx</span><br><span class="line">               nginx.ingress.kubernetes.io/ssl-redirect: false</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason  Age    From                      Message</span><br><span class="line"></span><br><span class="line">----    ------  ----   ----                      -------</span><br><span class="line"></span><br><span class="line">  Normal  CREATE  3m37s  nginx-ingress-controller  Ingress dev/demoapp-ingress</span><br><span class="line">  Normal  UPDATE  3m5s   nginx-ingress-controller  Ingress dev/demoapp-ingress</span><br></pre></td></tr></table></figure>

<p>最后，我们可在集群外部向Ingress控制器上的<a target="_blank" rel="noopener" href="http://www.ilinux.io主机发起请求测试.清单中默认的配置通过nodeport将ingress/">www.ilinux.io主机发起请求测试。清单中默认的配置通过NodePort将Ingress</a> Nginx控制器发布到集群之外，外部客户端对所有TLS虚拟主机的访问是通过service/ingress-nginx-controller上443端口相应的NodePort进行，而对非TLS虚拟主机的访问则是通过80端口相应的NodePort进行的。因而，这里需要先分别取出80和443端口对应的NodePort，下面的两个命令可实现该功能。或者，我们直接列出相关Service资源的信息亦可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get service/ingress-nginx-controller -n ingress-nginx \</span></span><br><span class="line"><span class="language-bash">        -o jsonpath=<span class="string">&quot;&#123;.spec.ports[?(@.port==80)].nodePort&#125;&quot;</span></span></span><br><span class="line">32012</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get service/ingress-nginx-controller -n ingress-nginx \</span></span><br><span class="line"><span class="language-bash">        -o jsonpath=<span class="string">&quot;&#123;.spec.ports[?(@.port==443)].nodePort&#125;&quot;</span></span></span><br><span class="line">30532</span><br></pre></td></tr></table></figure>

<p>我们在集群外部的主机上分别向Kubernetes集群任意节点的IP地址的32012和30532端口发起HTTP与HTTPS请求即能进行测试，但访问时需要基于主机名进行，因而需要将<a target="_blank" rel="noopener" href="http://www.ilinux.io解析到节点地址,或者直接通过自定义的host头部发起请求,如下面的两条命令所示./">www.ilinux.io解析到节点地址，或者直接通过自定义的host头部发起请求，如下面的两条命令所示。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -H <span class="string">&quot;host: www.ilinux.io&quot;</span> 172.29.9.13:32012</span></span><br><span class="line">…… ClientIP: 10.244.2.6, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -k -H <span class="string">&quot;host: www.ilinux.io&quot;</span> https://172.29.9.13:30532</span></span><br><span class="line">…… ClientIP: 10.244.2.6, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br></pre></td></tr></table></figure>

<p>两个请求均得到了正常响应，且命令结果显示出客户端IP地址是10.244.2.6，这其实是ingress-nginx-controller控制器的Pod对象的地址。这是两个Pod间的直接通信，它们不会再使用service/demoapp资源进行二次代理。<br>或者，我们也可直接向Ingress Nginx的Service中定义的ExternalIP上的ServicePort发起请求，甚至临时设置客户端hosts文件，将<a target="_blank" rel="noopener" href="http://www.ilinux.io的主机名解析到该externalip后可直接使用域名访问./">www.ilinux.io的主机名解析到该ExternalIP后可直接使用域名访问。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -H <span class="string">&quot;Host: www.ilinux.io&quot;</span> http://172.29.9.11:80/</span></span><br><span class="line">…… ClientIP: 10.244.2.6, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl http://www.ilinux.io</span></span><br><span class="line">…… ClientIP: 10.244.2.6, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br></pre></td></tr></table></figure>

<p>显然，在缺少对LoadBalancer类型Service的支持而且也没有自行管理的边缘路由器的环境中，ExternalIP Service结合外部的DNS名称解析也算是一种折中的可用解决方案。在本书后面章节的测试中，会不加区别地使用NodePort或者ExternalIP的方式对通过Ingress Nginx发布的服务进行访问。</p>
<h3 id="配置Ingress-Nginx"><a href="#配置Ingress-Nginx" class="headerlink" title="配置Ingress Nginx"></a>配置Ingress Nginx</h3><p>除使用Ingress资源自定义流量路由相关的配置外，Ingress Nginx应用程序还存在许多其他配置需要，例如日志格式、CORS、URL重写、代理缓冲和SSL透传等。这类的配置通常有ConfigMap、Annotations和自定义模板3种实现方式。<br>Ingress Nginx的ConfigMap和Annotations配置接口都支持使用大量的参数来定制所需要的功能，不同的是，前者通过在Ingress Nginx引用ConfigMap资源规范中data字段特定的键及可用取值进行定义，且多用于Nginx全局特性的定制，因而是集群级别的配置；而后者则于Ingress资源上使用资源注解配置，多用于虚拟主机级别，因而通常是服务级别的配置。<br>接下来，我们通过为虚拟主机<a target="_blank" rel="noopener" href="http://www.ilinux.io添加basic认证来说明使用ingress资源的注解来配置ingress/">www.ilinux.io添加Basic认证来说明使用Ingress资源的注解来配置Ingress</a> Nginx的方法。Ingress Nginx的Basic认证功能属于虚拟主机的配置，相关的常用注解有如下几个。</p>
<ul>
<li>nginx.ingress.kubernetes.io/auth-type: [basic|digest]。用于指定认证类型，仅有两个可用值。</li>
<li>nginx.ingress.kubernetes.io/auth-secret: secretName。保存有认证信息的Secret资源名称。</li>
<li>nginx.ingress.kubernetes.io/auth-secret-type: [auth-file|auth-map]。Secret中的数据类型，auth-file表示数据为htpasswd命令直接生成的文件，auth-map表示数据是直接给出用户的名称和hash格式的密钥信息。</li>
<li>nginx.ingress.kubernetes.io/auth-realm: “realm string”：认证时使用的realm信息。</li>
</ul>
<p>我们先使用htpasswd命令准备一个进行Basic认证的认证文件，并将其创建为待发布服务同一名称空间下的Secret资源对象。下面的前两个命令分别向ngxpasswd文件中添加了ilinux和mageedu两个用户，各自的密码与用户名相同，后一个命令将该文件创建成了Secret对象，其数据项的键名必须为auth。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">htpasswd -c -b -m ./ngxpasswd ilinux ilinux</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">htpasswd -b -m ./ngxpasswd mageedu mageedu</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create secret generic ilinux-passwd --from-file=auth=./ngxpasswd -n dev</span></span><br><span class="line">secret/ilinux-passwd created</span><br></pre></td></tr></table></figure>

<p>而后，在前一节定义的ingress/demoapp-ingress资源上添加类似如下注解信息并再次应用到集群上即可，完整的示例见demoapp-ingress-with-basicauth.yaml。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp-ingress</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-type:</span> <span class="string">basic</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-secret:</span> <span class="string">ilinux-passwd</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/auth-realm:</span> <span class="string">&quot;Authentication Required&quot;</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>

<p>为ingress/demoapp-ingress资源打补丁后，经由Ingress上<a target="_blank" rel="noopener" href="http://www.ilinux.io虚拟主机发布的demoapp必须先完成basic认证才能进行后续的访问.如下面的两个测试命令及结果所示./">www.ilinux.io虚拟主机发布的demoapp必须先完成Basic认证才能进行后续的访问。如下面的两个测试命令及结果所示。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -H <span class="string">&quot;HOST: www.ilinux.io&quot;</span> 172.29.9.13:32012/</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;&lt;title&gt;401 Authorization Required&lt;/title&gt;&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -u <span class="string">&quot;mageedu:mageedu&quot;</span> -H <span class="string">&quot;HOST: www.ilinux.io&quot;</span> 172.29.9.13:32012/</span></span><br><span class="line">…… ClientIP: 10.244.2.6, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br></pre></td></tr></table></figure>

<p>相应地，Nginx全局级别的配置通常由ConfigMap资源进行定义，默认部署的Ingress Nginx会引用ingress-nginx名称空间中的ingress/ingress-nginx-controller资源，不过该ConfigMap资源默认不含有任何有效的数据项。下面的示例代码为该ConfigMap资源添加了几个自定义配置项以进行测试。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-nginx-controller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">use-gzip:</span> <span class="string">&quot;true&quot;</span>      <span class="comment"># 启用页面资源压缩功能，默认为启用</span></span><br><span class="line">  <span class="attr">gzip-level:</span> <span class="string">&quot;6&quot;</span>       <span class="comment"># 设置页面资源的压缩级别，默认为5</span></span><br><span class="line">  <span class="attr">worker-processes:</span> <span class="string">&quot;8&quot;</span> <span class="comment"># 设置Nginx的工作进程数</span></span><br></pre></td></tr></table></figure>

<p>将该资源应用到Kubernetes集群之上，随后即可在ingress-nginx-controller相关的Pod中验证Nginx生效的配置文件中是否包含了自定义的项目，如下面的命令结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">INGRESS_POD=$(kubectl get pods -l app.kubernetes.io/component=controller \</span></span><br><span class="line"><span class="language-bash">       -n ingress-nginx -o jsonpath=&#123;.items[0].metadata.name&#125;)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> <span class="variable">$INGRESS_POD</span> -n ingress-nginx -- nginx -T \</span></span><br><span class="line"><span class="language-bash">      | grep -E <span class="string">&quot;gzip_comp_level|worker_processes&quot;</span></span></span><br><span class="line">worker_processes 8;</span><br><span class="line">gzip_comp_level 6;</span><br></pre></td></tr></table></figure>

<p>Ingress Nginx支持许多服务配置参数和全局配置参数，它们的功能也各不相同，尽管服务级别的特性有不少的自定义需求，但全局默认配置就能满足大多数情况下的需求。完整的参数列表请参考Ingress Nginx的文档。</p>
<h3 id="Ingress资源案例：发布Dashboard"><a href="#Ingress资源案例：发布Dashboard" class="headerlink" title="Ingress资源案例：发布Dashboard"></a>Ingress资源案例：发布Dashboard</h3><p>Kubernetes Dashboard基于默认的资源清单部署到kubernetes-dashboard名称空间中，而出于安全方面的需要，Dashboard必须通过HTTPS协议进行远程访问。在Kubernetes Dashboard项目官方提供的配置清单中，相应的service/kubernetes-dashboard需经由ClusterIP的443端口发布到集群内部，但经由浏览器访问Dashboard的请求几乎都来自Kubernetes集群外部。<br>而此前的方法中，将服务发布到集群外部的常用方式是将Service资源的类型修改为NodePort或LoadBalancer，但NodePort将会把端口映射为某个不知名端口，甚至是随机端口，而LoadBalancer则依赖于公有云环境中的LBaaS服务，二者均存在着诸多限制。所以在Kubernetes上，Ingress才是发布HTTP应用的更好的方式。下面的配置清单示例（ingress-kubernetes-dashboard.yaml）即可将基于默认清单部署的Kubernetes Dashboard发布到集群外部。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">    <span class="attr">ingress.kubernetes.io/ssl-passthrough:</span> <span class="string">&quot;true&quot;</span>   <span class="comment"># SSL透传</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/backend-protocol:</span> <span class="string">&quot;HTTPS&quot;</span>  <span class="comment"># 后端使用TLS协议</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/$2</span>   <span class="comment"># URL重定向</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span>   <span class="comment"># 未限定主机，表示可附着于任何主机之上进行访问</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/dashboard(/|$)(.*)</span>    <span class="comment"># 正则表达式格式的路径</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">serviceName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">        <span class="attr">servicePort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>将配置清单中定义的资源创建到Kubernetes集群上之后，它会在kubernetes-dashboard名称空间中创建一个名为dashboard的Ingress资源对象，该资源直接将客户端的HTTPS请求透传到后端的Kubernetes Dashboard相关的Pod资源之上，而不会做SSL会话的卸载，这是因为后端的服务自身要求SSL通信的缘故，资源中的两个注解ingress.kubernetes.io/ssl-passthrough和nginx.ingress.kubernetes.io/backend-protocol也正是因为这个目的而特地添加的。图13-5显示的页面正是通过ingress-nginx-controller服务与HTTPS协议相关的NodePort端口完成的。</p>
<p><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185456515.png" alt="image-20220224185456515"></p>
<h2 id="Contour控制器"><a href="#Contour控制器" class="headerlink" title="Contour控制器"></a>Contour控制器</h2><p>Contour（见图13-6）是Kubernetes Ingress控制器的另一款开源实现，它以高性能的Envoy代理程序作为数据平面，支持开箱即用的动态配置和多种高级路由机制，支持TCP代理，并且提供了自定义资源类型HTTPProxy资源以扩展Ingress API，以更丰富的功能集部分解决了Ingress原始设计中的缺点，是Ingress控制器较为出色的实现之一。</p>
<p><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185535602.png" alt="image-20220224185535602"></p>
<h3 id="Envoy数据平面"><a href="#Envoy数据平面" class="headerlink" title="Envoy数据平面"></a>Envoy数据平面</h3><p>Envoy是专为大型现代SOA架构设计的应用代理和通信总线，使用C++语言编写，是高性能的HTTP/HTTPS协议代理，支持负载均衡、超时、重试、熔断、限流和回退等多种高级路由功能，支持HTTP/2和gRPC，而且能够作为HTTP/1.1和HTTP/2之间的双向透明代理机制。Envoy原生支持动态配置和服务发现机制，能够通过xDS API从控制平面（管理服务器）获取配置信息，同时提供了良好的可观测性，未来甚至会作为UPDA（Universal Data Plane API）的标准实现之一。<br>作为代理服务，Envoy使用“侦听器”（listener）维护与下游客户端的连接，使用集群管理器管理上游服务器集群，并根据侦听器上配置的代理层级和路由策略“桥接”客户端与后端服务器，如图13-7所示。它支持配置任意数量的侦听器和任意数量的上游集群，这些配置可使用静态方式指定，也可分别基于不同的服务发现API动态生成。</p>
<p><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185613668.png" alt="image-20220224185613668"></p>
<p>Envoy通过侦听器监听网络套接字以接收客户端请求，并且支持在一个进程上启用任意数量的侦听器，从而赋予用户按需配置Envoy监听一至多个套接字的能力。每个侦听器都应独立配置一些网络（L3/L4）过滤器，在接收到请求后，侦听器负责实例化指定过滤器链中的各个过滤器，并由这些过滤器处理后续的相关事件。一般说来，用户可根据不同的过滤器链配置侦听器以完成不同代理任务，例如HTTP代理、TCP代理、TLS客户端认证、限速等。<br>HTTP是现代面向服务的架构中至关重要的组件，因此Envoy通过名为HTTP连接管理器的网络（L3/L4）过滤器实现HTTP协议的应用层代理，内置支持HTTP/1.1、WebSockets和HTTP/2几类协议。另外，Envoy在传输层和应用层分别提供了对gRPC协议的原生支持，gRPC是来自Google的RPC框架，它基于HTTP/2构建和传递请求/响应报文。Envoy内置的HTTP过滤器中的Router负责为HTTP代理实现高级路由功能，包括将DNS域映射到特定的虚拟主机、URL重定向、URL重写、重试、超时、基于权重或百分比进行流量分发、基于优先级的路由和基于哈希策略的路由等。Envoy通过配置的路由信息生成路由表，并由Router过滤器据此做出路由决策。<br>每个上游服务器可由一个称为端点的逻辑组件进行标识，它代表着此服务监听的套接字，因此也可直接作为上游服务的标识符使用。一个集群可以包含一到多个端点，而一个端点也可隶属于一到多个集群。<br>Envoy的集群管理器负责管理配置的所有上游集群，包括获知上游主机健康可用状态、负载状态、连接类型以及适用的上游通信协议（HTTP/1.1、HTTP/2）等，并向前端的过滤器堆栈暴露API，允许过滤器根据请求及处理结果按需建立与上游集群的L3/L4或L7的通信连接。一旦在配置中定义了集群，集群管理器需要知道如何解析集群中的成员，即端点配置信息。目前，Envoy支持的端点配置支持包括静态配置、严格DNS、逻辑DNS、原始目标和EDS几种。集群管理器可通过纯静态的配置信息加载并初始化集群，也可通过集群发现服务（Cluster Discovery Service，CDS）API动态获取相关的配置，而后一种方式允许将配置信息存储在集中式的配置服务中，从而减少重启Envoy或重新分发配置的次数。<br>服务发现是面向服务架构的基石。为了更好地适配云原生环境，Envoy内置了一个层次化的动态配置API用于集中式管理配置信息，该API可借助服务发现服务（Service Discovery Service，即服务发现自身作为一种服务）机制支持多种服务发现方式，从而为Envoy提供以下配置信息的动态发现和更新，如图13-8所示。<br><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185629970.png" alt="image-20220224185629970"></p>
<blockquote>
<p>1）端点发现服务（Endpoint Discovery Service，EDS）：用于为Envoy动态添加、更新和删除Service端点，这些端点通常是指上游集群后端提供特定服务的主机的套接字；EDS事实上是v1时代的SDS（Service Discovery Service）的替代品，而且，SDS在v2版本中专用于指代Secret Discovery Service。<br>2）集群发现服务（Cluster Discovery Service，CDS）：用于动态添加、更新和删除Upstream集群，其中，每个集群本身都有自己的端点发现（v1版本中的服务发现）机制。<br>3）路由发现服务（Route Discovery Service，RDS）：用于动态添加或更新HTTP路由表。<br>4）密钥发现服务（Secret Discovery Service，SDS）：传递TLS密钥信息，从而LDS/ CDS能将主要侦听器和集群配置通过密钥管理系统与密钥信息在传送时相分离。<br>5）侦听器发现服务（Listener Discovery Service，LDS）：用于动态添加、更新和删除整个侦听器，包括其完整的L4或L7过滤器堆栈。<br>6）健康发现服务（Health Discovery Service，HDS)：配置Envoy成为分布式健康状态检查网络的成员，负责将健康状态检查的相关信息报告给上级或集中式的健康状态检查服务。</p>
<p>7）聚合发现服务（Aggregated Discovery Service，ADS）：构建在单个Envoy API提供的数据平面服务之上的多个管理API（例如Istio、Linkerd等）；同时操作Envoy API时，使用单个管理服务器处理单个Envoy的所有更新操作有助于确保Envoy的数据一致性；此API允许所有其他API通过单个管理服务器的单个gRPC双向流进行编组，从而实现确定性排序。</p>
</blockquote>
<p>另外还有ALS（gRPC Access Log Service）、RTDS（Runtime Discovery Service）、RLS（Rate Limit Service）和CSDS（Client Status Discovery Service）等，这些API统称为xDS，相较于v1版本来说，它是一种新的REST-JSON API，其中JSON/YAML格式是基于proto3规范的JSON映射机制派生而来的。另外，xDS API通过gRPC流式传输进行更新，该方式有着较低资源需求，因而能降低更新延迟。<br>具体到应用层面，Envoy既可以工作于微服务基础设施内部，作为面向服务架构内部的流量通信总线（仅负责系统内部各服务间的通信），为服务管控Ingress或（和）Engress流量，也能够作为整个微服务系统的边缘代理管控系统与外部交互的流量。因此，根据分发位置及执行的功能，Envoy可以按如图13-9所示的方式分配到4种工作模式。<br><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185702279.png" alt="image-20220224185702279"></p>
<blockquote>
<p>1）边缘代理：工作在整个系统架构的前端，接收来自外部客户端的请求，并将它们路由到相应的后端服务；除了必要的高级路由功能之外，处理TLS/SSL连接也是其必要的功能之一。<br>2）服务入站侦听器：负责接收并分发某特定服务的入站流量，可能会涉及应用程序的多个端口，并实现诸如重试、缓冲和熔断一类的功能。<br>3）服务出站侦听器：负责管控离开某特定服务的流量，协调服务间通信，实现诸如负载均衡和速率限制之类的功能；此监听器支持HTTP/1.1或HTTP/2，具体取决于应用程序的功能。<br>4)外部服务出口侦听器：管理由系统内部服务到系统外部服务的流量。</p>
</blockquote>
<p>作为Contour的数据平面，作用于Kubernetes集群级别的Ingress控制器时，Envoy仅实现了上述4种部署类型中的第一种，即工作在Kubernetes系统的前端，主要用于管控南北向的流量。<br>而具体到配置层面，Envoy在启动时需要经由bootstrap配置文件加载整个配置框架，它支持纯静态、纯动态或动静混合的配置方式。静态配置是指不支持在Envoy运行中变动的配置，而动态配置是经由xDS API向管理服务器注册、监视并动态加载的配置，配置信息的任何变动都能够由Envoy及时获取和装载。<br>资源的动态配置定义在dynamic_resources参数中，资源由相应的资源管理器借助xDS API进行服务发现时的响应结果生成，而静态方式通过static_resources配置参数在引导配置中定义。同时，动态及静态两种资源定义方式也能够基于特定的逻辑混合编排，例如在静态资源定义中仅使用EDS、仅使用EDS和CDS，或者使用EDS、CDS和RDS等。一般说来，管理接口（admin）和资源定义（static_resources或dynamic_resources)是基本要件。更多更详细的使用信息请参考Envoy的文档。</p>
<h3 id="部署Contour"><a href="#部署Contour" class="headerlink" title="部署Contour"></a>部署Contour</h3><p>如前所述，Contour项目由Contour控制平面组件和Envoy数据平面组件组成，部署时需要由各自的控制器编排运行。Contour提供的示例部署清单将所有资源部署在名称空间projectcontour中，控制平面组件由Deployment控制器编排，出于高可用考虑，该组件通常运行两个副本，它们通过service/contour为Envoy提供管理服务，而数据平面组件Envoy则由DaemonSet控制器编排运行在Kubernetes集群中的每个节点之上，它们通过service/envoy为客户端提供接入Ingress控制器的服务。具体的部署组件及工作逻辑如图13-10所示。<br><img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224185720589.png" alt="image-20220224185720589">Contour提供的示例部署清单为<a target="_blank" rel="noopener" href="https://projectcontour.io/quickstart/contour.yaml%EF%BC%8C%E5%AE%83%E9%BB%98%E8%AE%A4%E4%B8%BAservice/contour%E4%BD%BF%E7%94%A8LoadBalancer%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%86%E6%88%91%E4%BB%AC%E7%9A%84Kubernetes%E9%9B%86%E7%BE%A4%E7%9A%84%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E4%B8%BABaremetal%EF%BC%8C%E5%9B%A0%E8%80%8C%E9%9C%80%E8%A6%81%E4%BF%AE%E6%94%B9%E5%85%B6%E7%B1%BB%E5%9E%8B%E4%B8%BANodePort%EF%BC%8C%E4%BD%86%E8%BF%99%E9%87%8C%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8ExternalIP%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%AF%A5%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%A4%96%E9%83%A8%E6%B5%81%E9%87%8F%E7%AD%96%E7%95%A5%E4%B8%BALocal%E3%80%82%E5%8F%A6%E5%A4%96%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9daemonset/envoy%E4%B8%AD%E7%9A%84Pod%E6%A8%A1%E6%9D%BF%EF%BC%8C%E4%BB%A5%E4%BD%BF%E5%BE%97%E5%90%84Pod%E5%AE%9E%E4%BE%8B%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8hostNetwork%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%8F%AF%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%83%BD%E4%B8%8EIngress">https://projectcontour.io/quickstart/contour.yaml，它默认为service/contour使用LoadBalancer类型，但我们的Kubernetes集群的部署环境为Baremetal，因而需要修改其类型为NodePort，但这里不建议使用ExternalIP，因为该服务的外部流量策略为Local。另外，我们也可以通过修改daemonset/envoy中的Pod模板，以使得各Pod实例能够直接使用hostNetwork，这些可用的解决方案都与Ingress</a> Nginx相似。这里仍然选择使用前者，具体的变动如下面的Service资源清单所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">envoy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">projectcontour</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Local</span> <span class="comment"># 仅将流量代理给本地的Envoy以减少跃点，提升性能</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">envoy</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>  <span class="comment"># 若无外部LoadBalancer可用，需要将该字段值修改为NodePort</span></span><br></pre></td></tr></table></figure>

<p>修改完成后，将contour.yaml清单应用到集群之上完成部署，即可测试其功效。Contour仅解析明确标明资源注解kubernetes.io/ingress.class的值为contour的Ingress资源。下面的示例代码（contour-ingress-demo.yaml）定义了一个将dev名称空间中的service/demoapp通过Contour发布到集群之外的Ingress资源，它与此前适配到Ingress Nginx控制器的Ingress资源的区别仅在于kubernetes.io/ingress.class注解信息的值或.spec.ingressClass字段的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">contour-ingress-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;contour&quot;</span>   <span class="comment"># 指明负责解析该资源的控制器类型</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;false&quot;</span>  <span class="comment"># 禁止HTTP重定向</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span> </span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">demoapp</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">www.ilinux.io</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-ingress-www-ilinux</span></span><br></pre></td></tr></table></figure>

<p>将上面的资源应用到集群上之后，即可通过projectcontour名称空间中service/envoy上80端口对应的NodePort来访问发布的demoapp应用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get service/envoy -n projectcontour \</span></span><br><span class="line"><span class="language-bash">     -o jsonpath=<span class="string">&quot;&#123;.spec.ports[?(@.port==80)].nodePort&#125;&quot;</span></span>                                     </span><br><span class="line">32139</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get service/envoy -n projectcontour \</span></span><br><span class="line"><span class="language-bash">     -o jsonpath=<span class="string">&quot;&#123;.spec.ports[?(@.port==443)].nodePort&#125;&quot;</span></span>   </span><br><span class="line">30530</span><br></pre></td></tr></table></figure>

<p>随后，在外部主机上，将主机名<a target="_blank" rel="noopener" href="http://www.ilinux.io解析到kubernetes集群任意一个工作节点的ip地址即可发起请求测试,如下面的curl命令及结果所示./">www.ilinux.io解析到Kubernetes集群任意一个工作节点的IP地址即可发起请求测试，如下面的curl命令及结果所示。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl http://www.ilinux.io:32139</span></span><br><span class="line">…… ClientIP: 10.244.3.9, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -k https://www.ilinux.io:30530</span></span><br><span class="line">…… ClientIP: 10.244.3.9, ServerName: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br></pre></td></tr></table></figure>

<p>由此或见，基于Kubernetes内置的Ingress发布服务时，底层使用的是Ingress Nginx还是Contour控制器并没有本质上的区别。但Contour提供的CRD资源类型HTTPProxy能够提供更为完整的路由功能集，大大丰富了Ingress的特性表现。</p>
<h3 id="HTTPProxy基础"><a href="#HTTPProxy基础" class="headerlink" title="HTTPProxy基础"></a>HTTPProxy基础</h3><p>HTTPProxy资源几乎兼容Ingress资源的所有功能，只不过它使用独有的资源规范，具体的格式及简要说明如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span>   <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span>               <span class="comment"># CRD资源的名称</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="string">name</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="string">namespace</span> <span class="string">&lt;string&gt;</span>          <span class="comment"># 名称空间级别的资源</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">virtualhost</span> <span class="string">&lt;VirtualHost&gt;</span>   <span class="comment"># 定义FQDN格式的虚拟主机，类似于Ingress中的host</span></span><br><span class="line"><span class="string">fqdn</span> <span class="string">&lt;string&gt;</span>             <span class="comment"># 虚拟主机FQDN格式的名称</span></span><br><span class="line"><span class="string">tls</span> <span class="string">&lt;TLS&gt;</span>                 <span class="comment"># 启用HTTPS，且默认以301将HTTP请求重定向至HTTPS</span></span><br><span class="line"><span class="string">secretName</span> <span class="string">&lt;string&gt;</span>     <span class="comment"># 存储证书和私钥信息的Secret资源名称</span></span><br><span class="line"><span class="string">minimumProtocolVersion</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 支持的SSL/TLS协议的最低版本</span></span><br><span class="line"><span class="string">passthrough</span> <span class="string">&lt;boolean&gt;</span>   <span class="comment"># 是否启用透传模式，启用时控制器不卸载HTTPS会话</span></span><br><span class="line"><span class="string">clientValidation</span> <span class="string">&lt;DownstreamValidation&gt;</span>   <span class="comment"># 验证客户端证书，可选配置</span></span><br><span class="line">  <span class="string">caSecret</span> <span class="string">&lt;string&gt;</span>     <span class="comment"># 用于验证客户端证书的CA证书</span></span><br><span class="line"><span class="string">routes</span> <span class="string">&lt;[]Route&gt;</span>            <span class="comment"># 定义路由规则</span></span><br><span class="line"><span class="string">conditions</span> <span class="string">&lt;[]Condition&gt;</span>  <span class="comment"># 流量匹配条件，支持PATH前缀和标头匹配两种检测机制</span></span><br><span class="line"><span class="string">prefix</span> <span class="string">&lt;String&gt;</span>         <span class="comment"># PATH路径前缀匹配，类似于Ingress中的path字段</span></span><br><span class="line"><span class="string">permitInsecure</span> <span class="string">&lt;Boolean&gt;</span>  <span class="comment"># 是否禁止默认的将HTTP重定向到HTTPS的功能</span></span><br><span class="line"><span class="string">services</span> <span class="string">&lt;[]Service&gt;</span>      <span class="comment"># 后端服务，会对应转换为Envoy的Cluster定义</span></span><br><span class="line"><span class="string">name</span> <span class="string">&lt;String&gt;</span>           <span class="comment"># 服务名称</span></span><br><span class="line"><span class="string">port</span> <span class="string">&lt;Integer&gt;</span>          <span class="comment"># 服务端口</span></span><br><span class="line"><span class="string">protocol</span> <span class="string">&lt;String&gt;</span>       <span class="comment"># 到达后端服务的协议，可用值为tls、h2或者h2c</span></span><br><span class="line"><span class="string">validation</span> <span class="string">&lt;UpstreamValidation&gt;</span>   <span class="comment"># 是否校验服务端证书</span></span><br><span class="line">  <span class="string">caSecret</span> <span class="string">&lt;String&gt;</span>  </span><br><span class="line">  <span class="string">subjectName</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 要求证书中使用的Subject值</span></span><br></pre></td></tr></table></figure>

<p><font color="red">在同一个conditions字段中使用多个prefix前缀时，前缀间将存在串联关系，例如对于第一个前缀/api和第二个前缀/docs来说，该条件实际匹配的是/api/docs路由前缀。但通常在一个条件中只应该使用单个prefix。</font><br>下面的资源清单示例（httpproxy-demo.yaml）将13.3.2节中Ingress的定义（ingress/contour-ingress-demo）对等切换成了HTTPProxy资源。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">httpproxy-demo</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">virtualhost:</span></span><br><span class="line"><span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line"><span class="attr">secretName:</span> <span class="string">tls-ingress-www-ilinux</span></span><br><span class="line"><span class="attr">minimumProtocolVersion:</span> <span class="string">&quot;tlsv1.1&quot;</span>   <span class="comment"># 支持的TLS协议最小版本</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">conditions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">/</span>   <span class="comment"># PATH路径前缀匹配</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">permitInsecure:</span> <span class="literal">true</span>   <span class="comment"># 禁止将HTTP重定向至HTTPS</span></span><br></pre></td></tr></table></figure>

<p>  下面删除此前创建的ingress/contour-ingress-demo，而后创建httpproxy/httpproxy-demo，以免二者在功能上相冲突。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete ingress/contour-ingress-demo -n dev</span></span><br><span class="line">ingress.extensions &quot;contour-ingress-demo&quot; deleted</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f httpproxy-demo.yaml</span> </span><br><span class="line">httpproxy.projectcontour.io/httpproxy-demo created</span><br></pre></td></tr></table></figure>

<p>创建完成后，我们可以通过HTTPProxy资源描述信息中的Status字段来了解其生效结果，有效的配置通常以valid进行标识，否则就需要排除问题后重新创建。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe httpproxy -n dev</span></span><br><span class="line">……</span><br><span class="line">Status:</span><br><span class="line">Current Status:  valid</span><br><span class="line">Description:     valid HTTPProxy</span><br><span class="line">Load Balancer:</span><br></pre></td></tr></table></figure>

<p>随后，即可采用类似于此前的方式，分别对通过HTTP和HTTPS协议发布的demoapp服务进行访问，如下面的命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl http://www.ilinux.io:32139</span></span><br><span class="line">iKubernetes demoapp v1.0 !! ……: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -k https://www.ilinux.io:30530</span>              </span><br><span class="line">iKubernetes demoapp v1.0 !! ……: demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br></pre></td></tr></table></figure>

<p>为了避免与后面几节中的测试产生冲突，测试完成后，建议使用如下方式删除该HTTPProxy资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete httpproxy/httpproxy-demo -n dev</span></span><br></pre></td></tr></table></figure>

<h3 id="HTTPProxy高级路由"><a href="#HTTPProxy高级路由" class="headerlink" title="HTTPProxy高级路由"></a>HTTPProxy高级路由</h3><p>除了能实现类似于Ingress资源的流量分发等基础功能，HTTPProxy还封装了Envoy相当一部分高级路由功能的API，例如基于标头的路由、流量镜像和流量分割等多种高级路由功能，能帮助用户实现诸如金丝雀部署、蓝绿部署和A/B测试等功能。相关的规范均定义在HTTPProxy的.spec.routes字段中，其简要格式及功能说明如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">routes</span> <span class="string">&lt;[]Route&gt;</span>              <span class="comment"># 定义路由规则</span></span><br><span class="line">    <span class="string">conditions</span> <span class="string">&lt;[]Condition&gt;</span></span><br><span class="line">      <span class="string">prefix</span> <span class="string">&lt;String&gt;</span></span><br><span class="line">      <span class="string">header</span> <span class="string">&lt;HeaderCondition&gt;</span>               <span class="comment"># 请求报文标头匹配</span></span><br><span class="line">        <span class="string">name</span> <span class="string">&lt;String&gt;</span>           <span class="comment"># 标头名称</span></span><br><span class="line">        <span class="string">present</span> <span class="string">&lt;Boolean&gt;</span>       <span class="comment"># true表示存在该标头即满足条件，值false没有意义</span></span><br><span class="line">        <span class="string">contains</span> <span class="string">&lt;String&gt;</span>       <span class="comment"># 标头值必须包含的子串</span></span><br><span class="line">        <span class="string">notcontains</span> <span class="string">&lt;String&gt;</span>    <span class="comment"># 标头值不能包含的子串</span></span><br><span class="line">        <span class="string">exact</span> <span class="string">&lt;String&gt;</span>          <span class="comment"># 标头值的精确匹配</span></span><br><span class="line">        <span class="string">notexact</span> <span class="string">&lt;String&gt;</span>       <span class="comment"># 标头值精确反向匹配，即不能与指定的值相同</span></span><br><span class="line">    <span class="string">services</span> <span class="string">&lt;[]Service&gt;</span>        <span class="comment"># 后端服务，转换为Envoy的集群</span></span><br><span class="line">      <span class="string">name</span> <span class="string">&lt;String&gt;</span></span><br><span class="line">      <span class="string">port</span> <span class="string">&lt;Integer&gt;</span></span><br><span class="line">      <span class="string">protocol</span> <span class="string">&lt;String&gt;</span>  </span><br><span class="line">      <span class="string">weight</span> <span class="string">&lt;Int64&gt;</span>            <span class="comment"># 服务权重，用于流量分割</span></span><br><span class="line">      <span class="string">mirror</span> <span class="string">&lt;Boolean&gt;</span>          <span class="comment"># 流量镜像</span></span><br><span class="line">      <span class="string">requestHeadersPolicy</span> <span class="string">&lt;HeadersPolicy&gt;</span>    <span class="comment"># 到上游服务器请求报文的标头策略</span></span><br><span class="line">        <span class="string">set</span> <span class="string">&lt;[]HeaderValue&gt;</span>     <span class="comment"># 添加标头或设置指定标头的值</span></span><br><span class="line">          <span class="string">name</span> <span class="string">&lt;String&gt;</span></span><br><span class="line">          <span class="string">value</span> <span class="string">&lt;String&gt;</span></span><br><span class="line">        <span class="string">remove</span> <span class="string">&lt;[]String&gt;</span>       <span class="comment"># 移除指定的标头</span></span><br><span class="line">      <span class="string">responseHeadersPolicy</span> <span class="string">&lt;HeadersPolicy&gt;</span>   <span class="comment"># 到下游客户端响应报文的标头策略</span></span><br><span class="line">    <span class="string">loadBalancerPolicy</span> <span class="string">&lt;LoadBalancerPolicy&gt;</span>   <span class="comment"># 指定要使用的负载均衡策略</span></span><br><span class="line">      <span class="string">strategy</span> <span class="string">&lt;String&gt;</span>         <span class="comment"># 具体使用的策略，支持Random、RoundRobin、Cookie</span></span><br><span class="line">　　　　　　　　                  <span class="comment"># 和WeightedLeastRequest，默认为RoundRobin</span></span><br><span class="line">    <span class="string">requestHeadersPolicy</span> <span class="string">&lt;HeadersPolicy&gt;</span>      <span class="comment"># 路由级别的请求报文标头策略</span></span><br><span class="line">    <span class="string">reHeadersPolicy</span> <span class="string">&lt;HeadersPolicy&gt;</span>           <span class="comment"># 路由级别的响应报文标头策略</span></span><br><span class="line">    <span class="string">pathRewritePolicy</span> <span class="string">&lt;PathRewritePolicy&gt;</span>     <span class="comment"># URL重写</span></span><br><span class="line">      <span class="string">replacePrefix</span> <span class="string">&lt;[]ReplacePrefix&gt;</span></span><br><span class="line">        <span class="string">prefix</span> <span class="string">&lt;String&gt;</span>         <span class="comment"># PATH路由前缀</span></span><br><span class="line">        <span class="string">replacement</span> <span class="string">&lt;String&gt;</span>    <span class="comment"># 要替换为的目标路径</span></span><br></pre></td></tr></table></figure>

<p>需要特别说明的是，在同一个conditions字段中以不同的列表项分别定义的多个头部条件彼此间存在“逻辑与”关系，这意味着请求报文需要同时满足头部条件的定义才能匹配到设置的规则。<br>高级路由功能的应用场景通常会依赖同一应用程序两个或以上数量的版本，为了避免其他依赖，这里选择在dev名称空间下准备好的demoapp-v1.1和demoapp-v1.2两个版本的应用，它们都使用Deployment控制器编排，且分别有各自的Service对象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create deployment demoappv11 --image=<span class="string">&quot;ikubernetes/demoapp:v1.1&quot;</span> -n dev</span></span><br><span class="line">deployment.apps/demoappv11 created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create deployment demoappv12 --image=<span class="string">&quot;ikubernetes/demoapp:v1.2&quot;</span> -n dev</span></span><br><span class="line">deployment.apps/demoappv12 created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create service clusterip demoappv11 --tcp=80 -n dev</span> </span><br><span class="line">service/demoappv11 created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create service clusterip demoappv12 --tcp=80 -n dev</span> </span><br><span class="line">service/demoappv12 created</span><br></pre></td></tr></table></figure>

<p>为了便于读者朋友们理解，下面将分别说明几种主流高级路由功能的配置方法。</p>
<h4 id="基于标头的路由"><a href="#基于标头的路由" class="headerlink" title="基于标头的路由"></a>基于标头的路由</h4><p>基于标头的流量匹配机制是指检测请求报文的特定头部是否存在，或者其值是否满足表述的条件，而后仅路由测试结果为True的请求报文，不能满足测试条件的报文将被忽略，它们可能会由后续的其他路由规则匹配后进行路由，或者由默认路由指定的后端予以服务。在conditions字段中的同一个列表项中同时指定的header和prefix之间是“与”关系，即报文必须同时满足两个条件，而不同列表项表达的筛选条件间为“与”关系，报文也需要同时满足其全部条件。<br>下面的配置清单示例（httpproxy-headers-routing.yaml）在dev名称空间中定义了一个名为httpproxy-headers-routing的HTTPProxy资源，它在规则一中定义了两个过滤条件，满足条件的请求将被路由至demoappv11服务上，其他请求的路由目标则是demoapp服务。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpproxy-headers-routing</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">virtualhost:</span></span><br><span class="line">    <span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">conditions:</span>          <span class="comment"># 规则一，内部各条件间为与关系，且至多使用一个prefix</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">header:</span>            <span class="comment"># 过滤条件一，未指定prefix则表示适用于所有PATH</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">X-Canary</span>   <span class="comment"># 指定要检测的头部名称</span></span><br><span class="line">      <span class="attr">present:</span> <span class="literal">true</span>    <span class="comment"># 报文头部存在即满足条件，无论其值是什么</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">header:</span>            <span class="comment"># 过滤条件二与条件一为“与”关系</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">User-Agent</span> <span class="comment"># 指定要检测的头部名称</span></span><br><span class="line">      <span class="attr">contains:</span> <span class="string">curl</span>   <span class="comment"># 指定的头部的值包含字符串&quot;curl&quot;方满足条件</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappv11</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">services:</span>            <span class="comment"># 规则二，虚拟主机上未被前一路由规则匹配到的请求都将由该后端处理</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>将httpproxy/httpproxy-headers-routing资源应用到集群之上即可展开测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f httpproxy-headers-routing.yaml</span> </span><br><span class="line">httpproxy.projectcontour.io/httpproxy-headers-routing created</span><br></pre></td></tr></table></figure>

<p>随后，由Envoy使用NodePort在集群外部向Kubernetes集群任一节点发起测试请求，只有同时满足规则一中的两个条件的请求报文才会被路由到demoappv11后端，例如明确指定了自定义标头X-Canary的curl命令发起的测试请求及结果，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -H <span class="string">&quot;X-Canary: true&quot;</span> http://www.ilinux.io:32139</span></span><br><span class="line">iKubernetes demoapp v1.1 !! ……demoappv11-59cddc6bff-9bfkg, ServerIP: 10.244.1.12!</span><br></pre></td></tr></table></figure>

<p>仅满足规则一中的一个条件或者不能满足规则一中的任何条件的请求报文，将被路由到demoapp后端，如下面的3个测试命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下面的命令仅满足规则一中的条件二</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl http://www.ilinux.io:32139</span></span><br><span class="line">iKubernetes demoapp v1.0 !! …… demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">下面的curl命令模拟自身为chrome浏览器，仅能满足规则一中的条件一</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -A <span class="string">&quot;chrome&quot;</span> -H <span class="string">&quot;X-Canary: On&quot;</span> http://www.ilinux.io:32139</span></span><br><span class="line">iKubernetes demoapp v1.0 !!…… demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">下面的命令无法满足规则一中的任何条件</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">wget -q -O - http://www.ilinux.io:32139</span> </span><br><span class="line">iKubernetes demoapp v1.0 !! …… demoapp-6c5d545684-v6djh, ServerIP: 10.244.1.7!</span><br></pre></td></tr></table></figure>

<p>基于标头路由有许多应用场景，例如用户分类路由或浏览器分类路由等，甚至是基于某些特定的标头模拟金丝雀发布等。</p>
<h4 id="流量切分"><a href="#流量切分" class="headerlink" title="流量切分"></a>流量切分</h4><p>HTTPProxy支持在单个路由规则中同时指定多个后端服务，默认情况下，所有流量将以等量切分的方式平均分发到多个后端之上，每个后端内部再按照代理服务器配置的调度算法进行二级负载均衡。同时，HTTPProxy也允许用户为每个后端服务使用weight字段指定一个特定流量百分比，从而将流量以指定的比例在不同的后端服务间进行分发，如图13-11所示。</p>
<p>  <img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224190429470.png" alt="image-20220224190429470"></p>
<p>  基于流量分割的流量切分是完成灰度发布的常用手段。上线应用的新版本时，无论是出于产品稳定性还是用户接受程度等因素的考虑，直接以新代旧都充满风险。因此，灰度发布是应用程序在生产环境安全上线的一种重要手段，而对于Envoy来说，灰度发布仅是其流量治理功能的一种典型应用，结合分割策略便能实现常见的金丝雀部署、蓝绿部署和A/B测试等应用场景。<br>  事实上，基于标头的流量分割算是“基于请求内容”灰度部署的一种实现，而流量分割则是“基于流量比例”进行灰度部署的方式。与Kubernetes的Deployment控制器的滚动更新机制相比，HTTPProxy允许用户按需指定要切分的流量比例，而非按照Pod数量来固定分割的方式。<br>  下面的配置清单示例（httpproxy-traffic-splitting.yaml）中定义的httpproxy资源将发往虚拟主机<a target="_blank" rel="noopener" href="http://www.ilinux.io的以“/%E2%80%9D%E4%B8%BA%E8%B7%AF%E5%BE%84%E5%89%8D%E7%BC%80%E7%9A%84%E6%B5%81%E9%87%8F%EF%BC%8C%E6%8C%89%E6%8C%87%E5%AE%9A%E7%9A%84%E6%AF%94%E4%BE%8B%E5%88%87%E5%88%86%E5%88%B0%E4%BA%86demoapp%E5%92%8Cdemoappv11%E4%B8%A4%E4%B8%AA%E5%90%8E%E7%AB%AF%E6%9C%8D%E5%8A%A1%E4%B9%8B%E4%B8%8A%E3%80%82">www.ilinux.io的以“/”为路径前缀的流量，按指定的比例切分到了demoapp和demoappv11两个后端服务之上。</a></p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"> <span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"> <span class="attr">metadata:</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">httpproxy-traffic-splitting</span></span><br><span class="line">   <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"> <span class="attr">spec:</span></span><br><span class="line">   <span class="attr">virtualhost:</span></span><br><span class="line">     <span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">   <span class="attr">routes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">90</span>   <span class="comment"># 该后端的流量比例</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappv11</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">weight:</span> <span class="number">10</span>  <span class="comment"># 该后端的流量比例</span></span><br></pre></td></tr></table></figure>

<p>  将上述配置清单中的资源创建到集群之上便可检验其工作状态，为了避免策略交叉生效，我们先卸载此前创建的其他HTTPProxy资源后再进行测试。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete httpproxy --all -n dev</span></span><br><span class="line">httpproxy.projectcontour.io &quot;httpproxy-headers-routing&quot; deleted</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f httpproxy-traffic-splitting.yaml</span></span><br><span class="line">httpproxy.projectcontour.io/httpproxy-traffic-splitting created</span><br></pre></td></tr></table></figure>

<p>  部署完成后，我们即可向该虚拟主机发起多次请求以进行测试，一般来说，样本空间越大，真实的流量切分比例越接近于规划。例如，下面的命令向该服务发起了100次请求，并统计分别由demoapp v1.0和demoapp v1.1响应的报文数比例。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">v10=0; v11=0; <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> \</span></span><br><span class="line"><span class="language-bash"><span class="keyword">if</span> curl -s http://www.ilinux.io:32139/ | grep <span class="string">&quot;v1.0&quot;</span> &gt; /dev/null; \</span></span><br><span class="line"><span class="language-bash"><span class="keyword">then</span> <span class="built_in">let</span> v10++; <span class="keyword">else</span> <span class="built_in">let</span> v11++;<span class="keyword">fi</span>; <span class="keyword">done</span>;</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;Version 1.0: <span class="variable">$v10</span>  Version 1.1: <span class="variable">$v11</span>&quot;</span></span></span><br><span class="line">Version 1.0: 89  Version 1.1: 11</span><br></pre></td></tr></table></figure>

<p>  事实上，我们可以把这10%的流量比例当作“金丝雀”，测试足够长一段时间，确认无误后可通过逐步修改httpproxy-traffic-splitting资源中各后端服务上流量比例的方式完成流量迁移，从而实现灰度发布。以不存在“中间状态”的方式在两个后端服务间分割流量，要么完全在第一个服务上，要么一次性迁往第二个服务的配置机制即为蓝绿发布。</p>
<h4 id="流量镜像"><a href="#流量镜像" class="headerlink" title="流量镜像"></a>流量镜像</h4><p>流量镜像用于百分百地在两个服务间复制流量。在支持蓝绿部署的场景中，流量镜像常用于将当前服务上的真实流量引入到未发布的新版本上进行测试。但流量镜像工作于“只读”模式，因为其响应报文会被全部丢弃。<br>  下面的配置清单示例（httpproxy-traffic-mirror.yaml）将demoapp服务上的所有流量都镜像给demoappv11一份完整的副本。感兴趣的读者可自行测试。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpproxy-traffic-mirror</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">virtualhost:</span></span><br><span class="line">    <span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">conditions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappv11</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">mirror:</span> <span class="literal">true</span>   <span class="comment"># 流量镜像，所有发往demoapp的流量都镜像给当前服务一份</span></span><br></pre></td></tr></table></figure>

<h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><p>HTTPProxy中的负载均衡策略是路由规则中的定义，每个路由规则都可以为其后端调用的服务按需指定最为合用的负载均衡机制。目前，HTTPProxy暴露了Envoy在集群上支持的部分调度算法，主要有如下几个。</p>
<ul>
<li>RoundRobin：按顺序轮询选择上游端点，此为默认策略。</li>
<li>WeightedLeastRequest：加权最少连接，但该算法仅随机选择两个健康的端点，并从中挑选出负载少的端点作为调度目标。</li>
<li>Random：从后端健康端点中随机挑选端点。</li>
<li>Cookie：粘性会话调度机制，把来自某客户端的所有请求始终调度给同一个后端端点。</li>
</ul>
<p>下面的配置清单示例（httpproxy-lb-strategy.yaml）定义的路由规则会将发往<a target="_blank" rel="noopener" href="http://www.ilinux.io的所有流量均分给demoapp和demoappv11这两个后端服务,各服务内部使用random调度算法将流量分发至后端端点./">www.ilinux.io的所有流量均分给demoapp和demoappv11这两个后端服务，各服务内部使用Random调度算法将流量分发至后端端点。</a></p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpproxy-lb-strategy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"> <span class="attr">spec:</span></span><br><span class="line">  <span class="attr">virtualhost:</span></span><br><span class="line">  <span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">   <span class="attr">routes:</span></span><br><span class="line"> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">conditions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">services:</span>            <span class="comment"># 在两个服务间均分流量</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappv11</span></span><br><span class="line">       <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">       <span class="attr">loadBalancerPolicy:</span>  <span class="comment"># 使用Random调度算法</span></span><br><span class="line">       <span class="attr">strategy:</span> <span class="string">Random</span></span><br></pre></td></tr></table></figure>

<p> HTTPProxy路由规则中，每个后端服务都会对应地转换为Envoy上配置的一个集群，于是，指定的负载均衡策略也就成为该路由规则中各服务对应集群上共用的调度策略。</p>
<h3 id="HTTPProxy服务韧性"><a href="#HTTPProxy服务韧性" class="headerlink" title="HTTPProxy服务韧性"></a>HTTPProxy服务韧性</h3><p>   Envoy提供了一系列的局部故障应对机制，包括超时、重试、主动健康状态检测、被动健康状态检测（异常值探测）和断路器等，Contour的HTTPProxy API封装提供了前3种类型的故障应对机制，它们都定义在路由规则之中。可用的字段及简要的功能说明如下所示。</p>
   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">spec:</span></span><br><span class="line"> <span class="string">routes</span> <span class="string">&lt;[]Route&gt;</span> </span><br><span class="line">  <span class="string">timeoutPolicy</span> <span class="string">&lt;TimeoutPolicy&gt;</span>    <span class="comment"># 超时策略</span></span><br><span class="line"> <span class="string">response</span> <span class="string">&lt;String&gt;</span>         <span class="comment"># 等待服务器响应报文的超时时长</span></span><br><span class="line"> <span class="string">idle</span> <span class="string">&lt;String&gt;</span>             <span class="comment"># 超时后，Envoy维持与客户端之间连接的空闲时长</span></span><br><span class="line">  <span class="string">retryPolicy</span> <span class="string">&lt;RetryPolicy&gt;</span>   <span class="comment"># 重试策略</span></span><br><span class="line"> <span class="string">count</span> <span class="string">&lt;Int64&gt;</span>             <span class="comment"># 重试的次数，默认为1</span></span><br><span class="line"> <span class="string">perTryTimeout</span> <span class="string">&lt;String&gt;</span>    <span class="comment"># 每次重试的超时时长</span></span><br><span class="line"> <span class="string">healthCheckPolicy</span> <span class="string">&lt;HTTPHealthCheckPolicy&gt;</span>   <span class="comment"># 主动健康状态检测</span></span><br><span class="line"><span class="string">path</span> <span class="string">&lt;String&gt;</span>             <span class="comment"># 检测针对的路径（HTTP端点）</span></span><br><span class="line"><span class="string">host</span> <span class="string">&lt;String&gt;</span>             <span class="comment"># 检测时请求的虚拟主机</span></span><br><span class="line"><span class="string">intervalSeconds</span> <span class="string">&lt;Int64&gt;</span>   <span class="comment"># 时间间隔，即检测频度，默认为5秒</span></span><br><span class="line"><span class="string">timeoutSeconds</span> <span class="string">&lt;Int64&gt;</span>    <span class="comment"># 超时时长，默认为2秒</span></span><br><span class="line"><span class="string">unhealthyThresholdCount</span> <span class="string">&lt;Int64&gt;</span>  <span class="comment"># 判定为非健康状态的阈值，即连续错误次数</span></span><br><span class="line"><span class="string">healthyThresholdCount</span> <span class="string">&lt;Int64&gt;</span>    <span class="comment"># 判定为健康状态的阈值</span></span><br></pre></td></tr></table></figure>

<p>  HTTPProxy上实施的这类局部故障应对机制均属于路由级别，HTTPProxy将对该路由下的每个Service无差别地同时生效。</p>
<h4 id="超时和重试"><a href="#超时和重试" class="headerlink" title="超时和重试"></a>超时和重试</h4><p>   分布式环境中对远程资源和服务的调用可能会由于瞬态故障而失败，例如网络连接速度慢、超时、资源过量使用或暂时不可用等，这些故障多数情况下都能够在短时间内自行纠正，因而基于特定的策略重新发送请求（重试机制）可解决大部分的此类故障，其工作逻辑如图13-12所示。而且，通过透明地重试失败的操作，使应用程序在尝试连接到服务或网络资源时能够处理瞬态故障，可以显著提高应用程序的稳定性。<br>  <img src="/blog/2022/02/28/Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83/image-20220224190904842.png" alt="image-20220224190904842">但是，也可能存在由于意外事件导致故障并且可能需要更长时间才能恢复的情形，而故障的严重性级别有所不同，从部分连接中断到服务完全不可用皆有可能。这种情况下，连续重试和长时间的等待都没有太大意义，因而应用程序应迅速（等待一定的时间后自动超时）接受该操作已经失败并相应地处理这种失败。<br>  下面的资源清单示例（httpproxy-retry-timeout.yaml)为部署的demoapp服务定义了超时和重试策略，当上游服务器响应以5xx状态码时，demoapp将启动重试机制，最大尝试次数为3次，总体超时时长为2秒。</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpproxy-retry-timeout</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">virtualhost:</span></span><br><span class="line">    <span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">timeoutPolicy:</span>          <span class="comment"># 超时机制</span></span><br><span class="line">      <span class="attr">response:</span> <span class="string">2s</span></span><br><span class="line">      <span class="attr">idle:</span> <span class="string">5s</span></span><br><span class="line">    <span class="attr">retryPolicy:</span>            <span class="comment"># 重试策略</span></span><br><span class="line">      <span class="attr">count:</span> <span class="number">3</span>              <span class="comment"># 最大重试次数</span></span><br><span class="line">      <span class="attr">perTryTimeout:</span> <span class="string">500ms</span>  <span class="comment"># 单次尝试的超时时长</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>  HTTPProxy仅支持当上游服务器响应以5xx状态码时重试，因此它所能够应对的错误场景有限，而Envoy能够支持更多的重试条件，这些条件或许在未来的Contour版本中能够得到支持。上面的配置清单示例中的HTTPProxy资源为Envoy生成的重试策略的配置片段如下所示，它取自Envoy内置Admin接口输出的配置信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster:</span> <span class="string">dev/demoapp/80/da39a3ee5e</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="string">2s</span></span><br><span class="line"><span class="attr">retry_policy:</span></span><br><span class="line">  <span class="attr">retry_on:</span> <span class="string">5xx</span></span><br><span class="line">  <span class="attr">num_retries:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">per_try_timeout:</span> <span class="number">0.</span><span class="string">500s</span></span><br><span class="line"><span class="attr">idle_timeout:</span> <span class="string">5s</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，重试策略需要匹配应用程序的业务需求和故障性质，对于某些非关键操作，最好是快速失败而不是重试几次，以免影响应用程序的吞吐量。另外，还需要考虑操作幂等与否，对于幂等类操作，重试本质上是安全的；而对于非幂等类操作，重试可能导致该操作被执行多次，并产生意外的副作用。</p>
<h4 id="健康状态检测"><a href="#健康状态检测" class="headerlink" title="健康状态检测"></a>健康状态检测</h4><p>HTTPProxy资源支持的健康状态检测功能，是由Envoy在集群级别对后端端点主动检测实现的，Envoy通过发往每个上游端点的HTTP请求的响应状态码来判定端点健康与否。这种健康状态检测机制与Kubernetes上对容器实施的StartupProbe、LivenessProbe和ReadinessProbe机制有所不同，它并不经由Pod上定义的检测点，而是使用自定义的检测端点。我们知道，Service会对其关联的后端Pod经由Endpoint进行健康状态检测，而Contour的健康状态检测是在这各种检测之外，对Service关联的Pod对象又施加的一层自定义检测机制。<br>下面的资源清单（httpproxy-health-checks.yaml）示例在HTTPProxy上定义的健康状态检测将转换为Envoy的配置，并由Envoy实施检测。但相关的检测策略定义在路由规则上，而非服务级别，这意味着同一路由规则下的所有服务对应的Envoy集群将共享这种检测机制。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">httpproxy-health-check</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">virtualhost:</span></span><br><span class="line">    <span class="attr">fqdn:</span> <span class="string">www.ilinux.io</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">conditions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">healthCheckPolicy:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">intervalSeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">unhealthyThresholdCount:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">healthyThresholdCount:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappv11</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>将上述配置清单的资源创建到集群上之后，它会为Envoy在demoapp和demoappv11两个服务对应的集群上各生成一组类似如下内容的健康状态检测策略配置段。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">health_checks:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">timeout:</span> <span class="string">2s</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">  <span class="attr">unhealthy_threshold:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">healthy_threshold:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">http_health_check:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">contour-envoy-healthcheck</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<p>对于Envoy来说，集群中的各端点的健康状态检测机制必须显式定义，否则发现的所有上游主机在发现那一刻起即被视为可用。一般正确实施了存活状态和就绪状态检测的Pod，额外定义健康状态检测机制并非特别必要，而且会增加后端端点的服务压力。但对于未能在Pod的主容器级别实施存活状态和就绪状态检测的场景来说，在Ingress控制器代理上实施主动健康状态检测就变得不可或缺。</p>
<h3 id="TCP代理"><a href="#TCP代理" class="headerlink" title="TCP代理"></a>TCP代理</h3><p>如前所述，Envoy通过侦听器监听网络套接字以接收客户端请求，而连接处理功能则是由侦听器上配置的网络（L3/L4）过滤器负责处理，HTTPConnectionManager是最著名的过滤器之一，它是Envoy处理HTTP协议报文的核心框架，并引入了众多相关的7层（L7）过滤器。事实上，Envoy完全能够根据4层的TCP Proxy过滤器直接进行TCP协议的代理，但它支持的路由能力有限，通常仅能够将客户端流量按照调度算法在后端集群的各端点上进行流量分发。<br>Contour的HTTPProxy资源也能够支持TCP代理的功能，但它仅能支持HTTPS协议的透传功能，相关的设定要定义在.spec.tcpProxy字段中。下面给出了TCP的基础配置框架及简要说明，其中大多数字段的意义与此前HTTP代理中的功能相同。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">projectcontour.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HTTPProxy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">virtualhost</span> <span class="string">&lt;VirtualHost&gt;</span> </span><br><span class="line">  <span class="string">tcpProxy</span> <span class="string">&lt;TCPProxy&gt;</span>      <span class="comment"># TCP代理，即4层代理的定义</span></span><br><span class="line">    <span class="string">services</span> <span class="string">&lt;[]Service&gt;</span>   <span class="comment"># 后端服务，每个服务对应于一个集群</span></span><br><span class="line">    <span class="string">loadBalancerPolicy</span> <span class="string">&lt;LoadBalancerPolicy&gt;</span>    <span class="comment"># 负载均衡策略</span></span><br><span class="line">    <span class="string">healthCheckPolicy</span> <span class="string">&lt;TCPHealthCheckPolicy&gt;</span>   <span class="comment"># TCP层的主动健康状态检测</span></span><br><span class="line">      <span class="string">intervalSeconds</span> <span class="string">&lt;Int64&gt;</span> </span><br><span class="line">      <span class="string">timeoutSeconds</span> <span class="string">&lt;Int64&gt;</span> </span><br><span class="line">      <span class="string">unhealthyThresholdCount</span> <span class="string">&lt;Int64&gt;</span> </span><br><span class="line">      <span class="string">healthyThresholdCount</span> <span class="string">&lt;Int64&gt;</span></span><br></pre></td></tr></table></figure>

<p>TCP代理能够卸载TLS会话，也能够将TLS协议报文直接透传到后端端点，具体配置取决于用户的实际需要。例如，下面的配置清单示例（httpproxy-kubernetes-dashboard.yaml）在kubernetes-dashboard名称空间中将同名的服务通过Contour以TLS透传的方式进行发布。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: projectcontour.io/v1</span><br><span class="line">kind: HTTPProxy</span><br><span class="line">metadata:</span><br><span class="line">  name: dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  virtualhost:</span><br><span class="line">    fqdn: dashboard.ilinux.io</span><br><span class="line">    tls:</span><br><span class="line">      passthrough: true</span><br><span class="line">  tcpproxy:</span><br><span class="line">    services:</span><br><span class="line">    - name: kubernetes-dashboard</span><br><span class="line">      port: 443</span><br></pre></td></tr></table></figure>

<p>显然，若是在Envoy上卸载了TLS会话，它就能够直接处理HTTP协议的7层报文，从而完成高级路由功能，除非必须以TCP代理的方式进行转发。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Kubernetes/" rel="tag"># Kubernetes</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/02/24/Pod%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/" rel="prev" title="Pod资源调度器">
      <i class="fa fa-chevron-left"></i> Pod资源调度器
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/02/28/Kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90/" rel="next" title="Kubernetes自定义资源">
      Kubernetes自定义资源 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ingress%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83"><span class="nav-number">2.</span> <span class="nav-text">Ingress与服务发布</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ingress%E8%B5%84%E6%BA%90"><span class="nav-number">2.1.</span> <span class="nav-text">Ingress资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ingress%E4%B8%8EIngress%E6%8E%A7%E5%88%B6%E5%99%A8%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91"><span class="nav-number">2.1.1.</span> <span class="nav-text">Ingress与Ingress控制器流量转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ingress%E8%B5%84%E6%BA%90%E8%A7%84%E8%8C%83"><span class="nav-number">2.1.2.</span> <span class="nav-text">Ingress资源规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#v1beta1%E7%89%88%E6%9C%AC%E7%9A%84Ingress%E8%B5%84%E6%BA%90"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">v1beta1版本的Ingress资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v1%E7%89%88%E6%9C%AC%E7%9A%84Ingress%E8%B5%84%E6%BA%90"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">v1版本的Ingress资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IngressClass%E8%B5%84%E6%BA%90"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">IngressClass资源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ingress%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">Ingress资源类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95Service%E8%B5%84%E6%BA%90%E5%9E%8BIngress"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">单Service资源型Ingress</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EURL%E8%B7%AF%E5%BE%84%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E5%88%86%E5%8F%91"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">基于URL路径进行流量分发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EFQDN%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">基于FQDN的虚拟主机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS%E7%B1%BB%E5%9E%8B%E7%9A%84Ingress%E8%B5%84%E6%BA%90"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">TLS类型的Ingress资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ingress%E6%8E%A7%E5%88%B6%E5%99%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">Ingress控制器部署与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ingress-Nginx%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">Ingress Nginx部署与测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEIngress-Nginx"><span class="nav-number">2.2.2.</span> <span class="nav-text">配置Ingress Nginx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ingress%E8%B5%84%E6%BA%90%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%8F%91%E5%B8%83Dashboard"><span class="nav-number">2.2.3.</span> <span class="nav-text">Ingress资源案例：发布Dashboard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Contour%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">Contour控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Envoy%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="nav-number">2.3.1.</span> <span class="nav-text">Envoy数据平面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2Contour"><span class="nav-number">2.3.2.</span> <span class="nav-text">部署Contour</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPProxy%E5%9F%BA%E7%A1%80"><span class="nav-number">2.3.3.</span> <span class="nav-text">HTTPProxy基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPProxy%E9%AB%98%E7%BA%A7%E8%B7%AF%E7%94%B1"><span class="nav-number">2.3.4.</span> <span class="nav-text">HTTPProxy高级路由</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%A0%87%E5%A4%B4%E7%9A%84%E8%B7%AF%E7%94%B1"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">基于标头的路由</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E5%88%87%E5%88%86"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">流量切分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E9%95%9C%E5%83%8F"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">流量镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">负载均衡策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPProxy%E6%9C%8D%E5%8A%A1%E9%9F%A7%E6%80%A7"><span class="nav-number">2.3.5.</span> <span class="nav-text">HTTPProxy服务韧性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E8%AF%95"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">超时和重试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">健康状态检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%BB%A3%E7%90%86"><span class="nav-number">2.3.6.</span> <span class="nav-text">TCP代理</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description">myBlog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
