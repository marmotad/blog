<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marmotad.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Kubernetes访问控制API Server作为Kubernetes集群系统的网关，是访问及管理资源对象的唯一入口，通过HTTPS协议暴露了一个RESTful风格的接口。所有需要访问集群资源的集群组件或客户端，包括kube-controller-manager、kube-scheduler、kubelet和kube-proxy等集群基础组件，CoreDNS等集群的附加组件，以及此前使用的kub">
<meta property="og:type" content="article">
<meta property="og:title" content="认证、授权与准入控制">
<meta property="og:url" content="https://marmotad.github.io/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="marmotad">
<meta property="og:description" content="Kubernetes访问控制API Server作为Kubernetes集群系统的网关，是访问及管理资源对象的唯一入口，通过HTTPS协议暴露了一个RESTful风格的接口。所有需要访问集群资源的集群组件或客户端，包括kube-controller-manager、kube-scheduler、kubelet和kube-proxy等集群基础组件，CoreDNS等集群的附加组件，以及此前使用的kub">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218174842501.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218175532065.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183109261.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183126472.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183202775.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183221066.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183239124.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183729156.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183747264.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184626677.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184647841.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184704051.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184720792.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218190623307.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191548207.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191725068.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191931776.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191947673.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218192221358.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220221114926133.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220221121230803.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218192802902.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218193332606.png">
<meta property="article:published_time" content="2022-02-21T13:13:08.000Z">
<meta property="article:modified_time" content="2022-02-23T07:55:56.318Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marmotad.github.io/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218174842501.png">

<link rel="canonical" href="https://marmotad.github.io/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>认证、授权与准入控制 | marmotad</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="marmotad" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">marmotad</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://marmotad.github.io/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="myBlog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="marmotad">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          认证、授权与准入控制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-21 21:13:08" itemprop="dateCreated datePublished" datetime="2022-02-21T21:13:08+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-23 15:55:56" itemprop="dateModified" datetime="2022-02-23T15:55:56+08:00">2022-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Kubernetes访问控制"><a href="#Kubernetes访问控制" class="headerlink" title="Kubernetes访问控制"></a>Kubernetes访问控制</h2><p>API Server作为Kubernetes集群系统的网关，是访问及管理资源对象的唯一入口，通过HTTPS协议暴露了一个RESTful风格的接口。所有需要访问集群资源的集群组件或客户端，包括kube-controller-manager、kube-scheduler、kubelet和kube-proxy等集群基础组件，CoreDNS等集群的附加组件，以及此前使用的kubectl命令等都必须要经此网关请求与集群进行通信。所有客户端均要经由API Server访问或改变集群状态以及完成数据存储，并且API Server会对每一次的访问请求进行合法性检验，包括用户身份鉴别、操作权限验证以及操作是否符合全局规范的约束等。所有检查均正常完成且对象配置信息合法性检验无误之后才能访问或存入数据到后端存储系统etcd中，如图9-1所示。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218174842501.png" alt="image-20220218174842501"></p>
<p>客户端认证操作由API Server配置的一到多个认证插件完成。收到请求后，API Server依次调用配置的认证插件来校验客户端身份，直到其中一个插件可以识别出请求者的身份为止。授权操作则由一到多个授权插件完成，这些插件负责确定通过认证的用户是否有权限执行发出的资源操作请求，该类操作包括创建、读取、删除或修改指定的对象等。随后，通过授权检测的用户请求修改相关的操作还要经由一到多个准入控制插件的遍历式检测，例如使用默认值补足要创建的目标资源对象中未定义的各字段、检查目标Namespace资源对象是否存在、检查请求创建的Pod对象是否违反系统资源限制等，而其中任何的检查失败都可能会导致写入操作失败。</p>
<h3 id="用户账户与用户组"><a href="#用户账户与用户组" class="headerlink" title="用户账户与用户组"></a>用户账户与用户组</h3><p>Kubernetes系统上的用户账户及用户组的实现机制与常规应用略有不同。Kubernetes集群将那些通过命令行工具kubectl、客户端库或者直接使用RESTful接口向API Server发起请求的客户端上的请求主体分为两个不同的类别：现实中的“人”和Pod对象，它们的用户身份分别对应用户账户（User Account，也称为普通用户）和服务账户（Service Account，简称SA）。<br>1）用户账户：其使用主体往往是“人”，<font color="red">一般由外部的用户管理系统存储和管理，Kubernetes本身并不维护这一类的任何用户账户信息，它们不会存储到API Server之上，仅仅用于检验用户是否有权限执行其所请求的操作。</font><br>2）服务账户：其使用主体是“应用程序”，专用于为Pod资源中的服务进程提供访问Kubernetes API时的身份标识（identity）；<font color="red">ServiceAccount资源通常要绑定到特定的名称空间，它们由API Server自动创建或通过API调用，由管理员手动创建，通常附带着一组访问API Server的认证凭据——Secret，可由同一名称的Pod应用访问API Server时使用。</font><br>用户账户通常用于复杂的业务逻辑管控，作用于系统全局，因而名称必须全局唯一。Kubernetes并不会存储由认证插件从客户端请求中提取的用户及所属的组信息，因而也就没有办法对普通用户进行身份认证，它们仅仅用于检验该操作主体是否有权限执行其所请求的操作。相比较来说，服务账户则隶属于名称空间级别，仅用于实现某些特定操作任务，因此功能上要轻量得多。这两类账户都可以隶属于一个或多个用户组。<br>用户组只是用户账户的逻辑集合，它本身没有执行系统操作的能力，但附加于组上的权限可由其内部的所有用户继承，以实现高效的授权管理机制。Kubernetes有以下几个内置用于特殊目的的组。</p>
<ul>
<li>system:unauthenticated：未能通过任何一个授权插件检验的账户的、所有未通过认证测试的用户统一隶属的用户组。</li>
<li>system:authenticated：认证成功后的用户自动加入的一个专用组，用于快捷引用所有正常通过认证的用户账户。</li>
<li>system:serviceaccounts：所有名称空间中的所有ServiceAccount对象。</li>
<li>system:serviceaccounts:&lt;namespace&gt;：特定名称空间内所有的ServiceAccount对象。<br>对API Server来说，来自客户端的请求要么与用户账户绑定，要么以某个服务账户的身份进行，要么被视为匿名请求。群集内部或外部的每个进程，包括由人类用户使用kubectl，以及各节点上运行的kubelet进程，再到控制平面的成员组件，必须在向API Server发出请求时进行身份验证，否则即被视为匿名用户。</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Kubernetes使用身份验证插件对API请求进行身份验证，它允许管理员自定义服务账户和用户账户要启用或禁用的插件，并支持各自同时启用多种认证机制。具体设定时，至少应该为服务账户和用户账户各自启用一个认证插件。<br>如果启用了多种认证机制，账号认证过程由认证插件以串行方式进行，直到其中一种认证机制成功完成即结束。若认证失败，服务器则响应以401状态码，反之，请求者就会被Kubernetes识别为某个具体的用户（以其用户名进行标识），并且该连接上随后的操作都会以此用户身份进行。API Server对于接收到的每个访问请求会调用认证插件，尝试将以下属性与访问请求相关联。</p>
<ul>
<li>Username：用户名，例如kubernetes-admin等。</li>
<li>UID：用户的数字标签符，用于确保用户身份的唯一性。</li>
<li>Groups：用户所属的组，用于权限指派和继承。</li>
<li>Extra：键值数据类型的字符串，用于提供认证需要用到的额外信息。</li>
</ul>
<p>API Server支持以下几种具体的认证方式，其中所有的令牌认证机制通常被统称为“承载令牌认证”。</p>
<blockquote>
<ul>
<li>1）静态密码文件认证：将用户名和密码等信息以明文形式存储在CSV格式的文件中，由kube-apiserver在启动时通过–basic-auth-file选项予以加载，添加或删除用户都需要重启API Server；客户端通过在HTTP Basic认证（Authorization: Basic <a href="base64-encoded-username:password">base64-encoded-username:password</a>标头）方式中将用户名和密码编码后对该文件进行认证；显然，该认证方式应该在非生产性的环境中使用。<font color="red"> 静态密码文件认证插件自Kubernetes v1.20版本中预以弃用，因而，后面9.1.3节中使用该插件的测试操作部分在v1.20及之后的版本上不可用，但在v1.19及之前的版本中，仍然可用。</font></li>
<li>2）静态令牌文件认证：即保存用于认证的令牌信息的静态文件，由kube-apiserver的命令行选项–token-auth-file加载，且API Sever进程启动后不可更改；HTTP协议的客户端能基于承载令牌（Authorization: Bearer <token>标头）对静态令牌文件进行身份验证，它将令牌编码后通过请求报文中的Authorization头部承载并传递给API Server即可；建议仅将该认证方式用于非生产性环境中。</token></li>
<li>3）X509客户端证书认证：客户端在请求报文中携带X.509格式的数字证书用于认证，其认证过程类似于HTTPS协议通信模型；认证通过后，证书中的主体标识（Subject）将被识别为用户标识，其中的字段CN（Common Name）的值是用户名，字段O（Organization）的值是用户所属的组。例如/CN=ilinux/O=opmasters/O=admin中，用户名为ilinux，它属于opmasters和admin两个组；该认证方式可通过–client-ca-file=SOMEFILE选项启用。</li>
<li>4）引导令牌（Bootstrap Token）认证：一种动态管理承载令牌进行身份认证的方式，常用于简化组建新Kubernetes集群时将节点加入集群的认证过程，需要由kube-apiserver通过–experimental-bootstrap-token-auth选项启用；新的工作节点首次加入时，Master使用引导令牌确认节点身份的合法性之后自动为其签署数字证书以用于后续的安全通信，kubeadm初始化的集群也是这种认证方式；这些令牌作为Secrets存储在kube-system命名空间中，可以动态管理和创建它们，并由TokenCleaner控制器负责删除过期的引导令牌。</li>
<li>5）ServiceAccount令牌认证：该认证方式会由kube-apiserver程序自动启用，它同样使用签名的承载令牌来验证请求；该认证方式还支持通过可选项–service-account-key-file加载签署承载令牌的密钥文件，未指定时将使用API Server自己的TLS私钥；ServiceAccount通常由API Server自动创建，并通过ServiceAccount准入控制器将其注入Pod对象，包括ServiceAccount上的承载令牌，容器中的应用程序请求API Server的服务时以此完成身份认证。</li>
<li>6）OpenID Connect令牌认证：简称为OIDC，是OAuth 2协议的一种扩展，由Azure AD、Salesforce和Google Accounts等OAuth 2服务商所支持，协议的主要扩展是返回的附加字段，其中的访问令牌也称为ID令牌；它属于JSON Web令牌（JWT）类型，有服务器签名过的常用字段，例如email等；kube-apiserver启用这种认证功能的相关选项较多。</li>
<li>7）Webhook令牌认证：Webhook身份认证是用于验证承载令牌的钩子；HTTP协议的身份验证允许将服务器的URL注册为Webhook，并接收带有承载令牌的POST请求进行身份认证；客户端使用kubeconfig格式的配置文件，在文件中，users指的是API Server的Webhook，而clusters则指的是API Server。</li>
<li>8）代理认证：API Server支持从请求头部的值中识别用户，例如常用的X-Remote-User、X-Remote-Group和几个以X-Remote-Extra-开头的头部，它旨在与身份验证代理服务相结合，由该代理设置相应的请求头部；为了防止头欺骗，在检查请求标头之前，需要身份认证代理服务向API Server提供有效的客户端证书，以验证指定CA（由选项–requestheader-client-ca-file等进行指定）的代理服务是否合法。</li>
</ul>
</blockquote>
<p>未能被任何验证插件明确拒绝的请求中的用户即为匿名用户，该类用户会被冠以system:anonymous用户名，隶属于system:unauthenticated用户组。若API Server启用了除AlwaysAllow以外的认证机制，则匿名用户处于启用状态。但是，出于安全因素的考虑，建议管理员通过–anonymous-auth=false选项将其禁用。<br>API Server还允许用户通过模拟头部冒充另一个用户，这些请求可以以手动方式覆盖请求中用于身份验证的用户信息。例如，管理员可以使用此功能临时模拟其他用户来查看请求是否被拒绝，以进行授权策略调试。<br>除了身份信息，请求报文还需要提供操作方法及其目标对象，例如针对某Pod资源对象进行的创建、查看、修改或删除操作等。具体来说，它包含如下信息。</p>
<ul>
<li>API：用于定义请求的目标是否为一个API资源。</li>
<li>Request path：请求的非资源型路径，例如/api或/healthz。</li>
<li>API group：要访问的API组，仅对资源型请求有效；默认为core API group。</li>
<li>Namespace：目标资源所属的名称空间，仅对隶属于名称空间类型的资源有效。</li>
<li>API request verb：API请求类的操作，即资源型请求（对资源执行的操作），包括get、list、create、update、patch、watch、proxy、redirect、delete和deletecollection等。</li>
<li>HTTP request verb：HTTP请求类的操作，即非资源型请求要执行的操作，如get、post、put和delete。</li>
<li>Resource：请求的目标资源的ID或名称。</li>
<li>Subresource：请求的子资源。</li>
</ul>
<p>为了核验用户的操作许可，成功通过身份认证后的操作请求还需要转交给授权插件进行许可权限检查，以确保其拥有执行相应操作的许可。API Server主要支持使用4类内置的授权插件来定义用户的操作权限。</p>
<ul>
<li>Node：基于Pod资源的目标调度节点来实现对kubelet的访问控制。</li>
<li>ABAC：Attribute-based access control，基于属性的访问控制。</li>
<li>RBAC：Role-based access control，基于角色的访问控制。</li>
<li>Webhook：基于HTTP回调机制实现外部REST服务检查，确认用户授权的访问控制。</li>
</ul>
<p>还有AlwaysDeny和AlwaysAllow两个特殊的授权插件，其中AlwaysDeny（总是拒绝）仅用于测试，而AlwaysAllow（总是允许）则用于不期望进行授权检查时直接在授权检查阶段放行所有的操作请求。–authorization-mode选项用于定义API Server要启用的授权机制，多个选项值彼此间以逗号进行分隔。<br>而准入控制器（admission controller）则用于在客户端请求经过身份验证和授权检查之后，将对象持久化存储到etcd之前拦截请求，从而实现在资源的创建、更新和删除操作期间强制执行对象的语义验证等功能，而读取资源信息的操作请求则不会经由准入控制器检查。API Server内置了许多准入控制器，常用的包含下面列出的几种。不过，其中的个别控制器仅在较新版本的Kubernetes中才被支持。</p>
<blockquote>
<p>1）AlwaysAdmit和AlwaysDeny：前者允许所有请求，后者则拒绝所有请求。<br>2）AlwaysPullImages：总是下载镜像，即每次创建Pod对象之前都要去下载镜像，常用于多租户环境中，以确保私有镜像仅能够由拥有权限的用户使用。<br>3）NamespaceLifecycle：拒绝在不存在的名称空间中创建资源，而删除名称空间则会级联删除其下的所有其他资源。<br>4）LimitRanger：可用资源范围界定，用于对设置了LimitRange的对象所发出的所有请求进行监控，以确保其资源请求不会超限。<br>5）ServiceAccount：用于实现服务账户管控机制的自动化，实现创建Pod对象时自动为其附加相关的Service Account对象。<br>6）PersistentVolumeLabel：为那些由云计算服务商提供的PV自动附加region或zone标签，以确保这些存储卷能正确关联且仅能关联到所属的region或zone。<br>7）DefaultStorageClass：监控所有创建PVC对象的请求，以保证那些没有附加任何专用StorageClass的请求会被自动设定一个默认值。<br>8）ResourceQuota：用于为名称空间设置可用资源上限，并确保当其中创建的任何设置了资源限额的对象时，不会超出名称空间的资源配额。<br>9）DefaultTolerationSeconds：如果Pod对象上不存在污点宽容期限，则为它们设置默认的宽容期，以宽容notready:NoExecute和unreachable:NoExecute类的污点5分钟时间。<br>10）ValidatingAdmissionWebhook：并行调用匹配当前请求的所有验证类的Webhook，任何一个校验失败，请求即失败。<br>11）MutatingAdmissionWebhook：串行调用匹配当前请求的所有变异类的Webhook，每个调用都可能会更改对象。<br>早期的准入控制器代码需要由管理员编译进kube-apiserver中才能使用，实现方式缺乏灵活性。于是，Kubernetes自v1.7版本引入了Initializers和External Admission Webhooks来尝试突破此限制，而且自v1.9版本起，External Admission Webhooks被分为Mutating-AdmissionWebhook和ValidatingAdmissionWebhook两种类型，分别用于在API中执行对象配置的变异和验证操作。检查期间，仅那些顺利通过所有准入控制器检查的资源操作请求的结果才能保存到etcd中，而任何一个准入控制器的拒绝都将导致写入请求失败。</p>
</blockquote>
<h3 id="测试使用API-Server的访问控制机制"><a href="#测试使用API-Server的访问控制机制" class="headerlink" title="测试使用API Server的访问控制机制"></a>测试使用API Server的访问控制机制</h3><p> 如前所述，认证、授权和准入控制功能都以API Server插件形式存在，它们都可由kube-apiserver相应的选项进行启用和配置。由kubeadm部署的Kubernetes集群的API Server以静态Pod形式运行，相关配置清单（/etc/kubernetes/manifests/kube-apiserver.yaml）中配置kube-apiserver如下的一部分选项：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--secure-port=6443</span>  <span class="comment"># API Server监听的安全端口（HTTPS协议）</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--insecure-port=0</span>   <span class="comment"># API Server监听的非安全端口（HTTP协议），0表示禁用</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">……</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--client-ca-file=/etc/kubernetes/pki/ca.crt</span> <span class="comment"># 启用X509数字证书认证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--authorization-mode=Node,RBAC</span>              <span class="comment"># 启用Node和RBAC授权插件</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--enable-admission-plugins=NodeRestriction</span>  <span class="comment"># 额外启用的准入控制器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--enable-bootstrap-token-auth=true</span>          <span class="comment"># 启用Bootstrap Token认证</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">……</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--requestheader-extra-headers-prefix=X-Remote-Extra-</span> <span class="comment">#代理认证相关的配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--requestheader-group-headers=X-Remote-Group</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--requestheader-username-headers=X-Remote-User</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">--service-account-key-file=/etc/kubernetes/pki/sa.pub</span></span><br></pre></td></tr></table></figure>

<p>API Server的几乎每个认证插件都有自己专用的一至多个配置选项，例如上面配置中启用的X509证书认证、Bootstrap Token认证和代理认证，Server Account认证默认处于启用状态，–service-account-key-file选项仅指定用于签署承载令牌的密钥文件，未配置时默认使用API Server的TLS私钥。<font color="red">认证操作由各插件以“短路”方式进行，客户端请求会依次经由认证插件进行检查，任何一个插件认证成功即终止认证过程。</font><br>启用的授权插件需要显式指定，它们需要以列表值的格式统一定义在–authorization-mode选项之上，例如上面配置中启用了Node和RBAC授权插件。启用的各授权插件同样以“短路”机制运行，任何一个授权插件鉴权成功即可结束授权检查过程。<br>API Server默认会启用一部分准入控制器，额外需要启用的准入控制器需要以列表值的形式定义在–enable-admission-plugins选项之上，需要显式禁用准入控制器以列表值的形式定义在–disable-admission-plugins选项之上。与认证和授权不同的是，一个请求必须要成功通过所有准入控制器的检查，否则即会被拒绝。提示<br>不同版本的Kubernetes默认启用的准入控制器可能存在区别，要了解当前使用的版本上默认启用的准入控制器，可在kube-system名称空间中API Server相关的静态Pod内部运行“kube-apiserver -h | grep ‘enable-admission-plugins’”命令获取。<br>测试或研发环境中，使用静态密码文件认证是添加普通用户的快捷途径。API Server的静态密码认证文件遵循CSV格式，每一行存储一个用户账户信息，格式为password,user,uid,”group1,group2,group3”，用户组一段可以省略，而多个用户组也以逗号分隔，但需要使用双引号将所有用户组进行整体引用。例如，我们可以在Master节点上的/etc/kubernetes/authfiles目录中创建拥有类似如下内容的文件passwd.csv，它提供了ilinux和ik8s两个用户，二者都属于kubeusers用户组。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ilinux@MageEdu,ilinux,1009,&quot;kubeusers,defaultadmin&quot;</span><br><span class="line">ik8s@MageEdu,ik8s,1010,&quot;kubeusers,defaultadmin&quot;</span><br></pre></td></tr></table></figure>

<p>API Server的–basic-auth-file选项要通过本地路径加载该文件以启用静态密码文件认证方式，这里采用hostPath存储卷的方式将宿主机目录/etc/kubernetes/authfiles/关联到静态Pod资源kube-apiserver的相同目录下。修改Master节点上的/etc/kubernetes/manifests/kube-apiserver.yaml文件，添加hostPath存储卷及卷挂载配置，需要改动的配置部分如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">command:</span>       <span class="comment"># 在command中为kube-apiserver添加--basic-auth-file选项</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">--basic-auth-file=/etc/kubernetes/authfiles/passwd.csv</span></span><br><span class="line">  <span class="string">……</span></span><br><span class="line">  <span class="attr">volumeMounts:</span>  <span class="comment"># 为容器指定额外多挂载的hostPath存储卷，存储有静态密码文件</span></span><br><span class="line">  <span class="string">……</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/kubernetes/authfiles</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">static-auth-files</span></span><br><span class="line">    <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="string">……</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hostPath:</span>    <span class="comment"># 将宿主机上存储有静态密码文件的目录作为hostPath存储卷</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/etc/kubernetes/authfiles</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">static-auth-files</span></span><br></pre></td></tr></table></figure>

<p>kubelet的调谐循环会监视节点上指定的用于加载静态Pod配置清单的目录，默认为/etc/kubernetes/manifests。该目录中的任何清单发生变动时，都会由kubelet自动做出相应的处理，例如重新创建相关的Pod资源，因而配置清单修改完成后很快就会由kubelet重新创建kube-apiserver相关的静态Pod对象，从而启动静态密码文件认证机制。<font color="red">安全起见，passwd.csv文件仅应该让必要用户拥有访问权限，并拒绝其他一切用户的任何操作，即将该文件属主和属组设置为root，并设定其权限模型为0400。</font><br>API Server默认监听TCP的6443端口，未指定用户身份并以curl命令向Master节点的该端口上HTTPS服务的根路径发起请求测试，会被识别为匿名用户，但会出现该用户不具有访问相应资源权限的错误信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -s -k https://k8s-master01.ilinux.io:6443/ | grep message</span>                    </span><br><span class="line">  &quot;message&quot;: &quot;forbidden: User \&quot;system:anonymous\&quot; cannot get path \&quot;/\&quot;&quot;,</span><br></pre></td></tr></table></figure>

<p>但以静态密码文件passwd.csv中的某一个用户名及其密码发起访问请求，则会由API Server标识出成功认证并识别的用户名，例如下面的测试命令及响应结果所示，但该用户同样因不具有指定资源的访问权限而被拒绝。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -s -u ilinux:ilinux@MageEdu -k https://172.29.9.1:6443/ | grep message</span></span><br><span class="line">  &quot;message&quot;: &quot;forbidden: User \&quot;ilinux\&quot; cannot get path \&quot;/\&quot;&quot;,</span><br></pre></td></tr></table></figure>

<p><font color="red">使用来自HTTP/HTTPS客户端的基本身份验证时，API Server需要客户端提供一个特定标头Authorization，它的值采用Basic BASE64ENCODED (USER:PASSWORD)格式。</font><br>为了让ilinux用户获取资源操作权限，我们可以将API Server的–authorization-mode的选项值直接修改为AlwaysAllow，但这样也会将所有权限开放给任意用户，包括匿名用户，这将为系统引入无法预料的风险。因而，我们接下来基于RBAC授权插件，将默认的集群角色（ClusterRole）admin通过角色绑定（RoleBinding）机制，为ilinux用户授权default名称空间的管理权限来测试认证用户的授权功能。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create rolebinding default-ns-admin --clusterrole=admin --user=ilinux -n default</span>       </span><br><span class="line">rolebinding.rbac.authorization.k8s.io/default-ns-admin created</span><br></pre></td></tr></table></figure>

<p>此时，ilinux用户拥有default名称空间及其内部资源对象的管理权限，我们可以通过该用户尝试访问该名称空间，以及该名称空间下的所有资源、指定类型的资源或指定的资源对象，例如下面的命令获取到了default名称空间的资源规范。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -s -u ilinux:ilinux@MageEdu -k https://172.29.9.1:6443/api/v1/namespaces/default/</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Namespace&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;default&quot;,</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但同样能够认证通过的ik8s用户因未被授权，便不具有访问default名称空间的权限，如下面的测试命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -s -u ik8s:ik8s@MageEdu -k https://k8s-master01.ilinux.io:6443/api/v1/namespaces/default/</span></span><br><span class="line">……</span><br><span class="line">&quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">&quot;message&quot;: &quot;namespaces \&quot;default\&quot; is forbidden: User \&quot;ik8s\&quot; cannot get resource \&quot;namespaces\&quot; in API group \&quot;\&quot; in the namespace \&quot;default\&quot;&quot;,</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>另外，静态令牌文件同样是CSV格式的文件，它与静态密码文件的不同之处仅在于第一个字段提供的是令牌而非密码字符串，该令牌采用[a-z0-9]{6}.[a-z0-9]{16}的格式，第一部分代表令牌ID，第二部分则是令牌密钥。客户端认证时，直接在HTTP中以Authorization: Bearer &lt;token&gt;标头完成认证。我们可以在前面静态密码文件认证配置的基础上完成静态令牌文件认证的测试。</p>
<ul>
<li>步骤1：执行类似如下命令，在/etc/kubernetes/authfiles目录下创建token.csv文件，生成相关的用户配置。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">sudo <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(openssl rand -hex 3)</span>.<span class="subst">$(openssl rand -hex 8)</span>,ilinux,1009,\&quot;kubeusers,defaultadmin\&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">&gt;&gt; /etc/kubernetes/authfiles/token.csv</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">sudo <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(openssl rand -hex 3)</span>.<span class="subst">$(openssl rand -hex 8)</span>,ik8s,1010,\&quot;kubeusers,defaultadmin\&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">&gt;&gt; /etc/kubernetes/authfiles/token.csv</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> 400 /etc/kubernetes/authfiles/token.csv</span></span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：编辑/etc/kubernetes/manifests/kube-apiserver.yaml配置清单，为kube-apiserver添加配置选项–token-auth-file=/etc/kubernetes/authfiles/token.csv。</li>
<li>步骤3：以ilinux用户承载令牌认证的方式向API Server发起资源操作请求进行访问测试，由下面的命令及结果可知，认证和授权均得以成功完成。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">TOKEN=$(sudo awk -F <span class="string">&quot;,&quot;</span> <span class="string">&#x27;$2==&quot;ilinux&quot;&#123;print $1&#125;&#x27;</span> /etc/kubernetes/authfiles/token.csv)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -s -H <span class="string">&quot;Authorization: Bearer <span class="variable">$TOKEN</span>&quot;</span> -k \</span></span><br><span class="line"><span class="language-bash">      https://172.29.9.1:6443/api/v1/namespaces/default/</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;kind&quot;: &quot;Namespace&quot;,</span><br><span class="line">    &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">    &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;default&quot;,</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，静态密码文件认证及静态令牌文件认证配置简单，很适合学习和试用Kubernetes的访问控制功能，但它们包含明文密码或令牌信息，且改动配置需要重启API Server，添加用户代价较大，不安全且不灵活，因此不建议用于生产环境。</p>
<h2 id="ServiceAccount及认证"><a href="#ServiceAccount及认证" class="headerlink" title="ServiceAccount及认证"></a>ServiceAccount及认证</h2><p>Kubernetes原生的程序一般能够直接与API Server进行交互（见图9-2），并进行资源状态的查询或更新，例如Flannel和CoreDNS等。API Server同样需要对这类来自Pod资源中的客户端程序进行身份验证，服务账户也是专用于这类场景的账号。ServiceAccount资源一般由用户身份信息及保存了认证信息的Secret对象组成。</p>
<h3 id="ServiceAccount自动化"><a href="#ServiceAccount自动化" class="headerlink" title="ServiceAccount自动化"></a><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218175532065.png" alt="image-20220218175532065">ServiceAccount自动化</h3><p>此前创建的每个Pod资源都自动关联了一个Secret存储卷，并由其容器挂载至/var/run/secrets/kubernetes.io/serviceaccount目录，下面的信息取自某Pod对象详细描述信息中自动挂载的存储卷相关的片段。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Containers:</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line">    <span class="attr">Mounts:</span></span><br><span class="line">      <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span> <span class="string">from</span> <span class="string">default-token-</span> <span class="string">w54hg</span> <span class="string">(ro)</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="attr">Volumes:</span></span><br><span class="line">  <span class="attr">default-token-bq6zc:</span></span><br><span class="line">    <span class="attr">Type:</span>        <span class="string">Secret</span> <span class="string">(a</span> <span class="string">volume</span> <span class="string">populated</span> <span class="string">by</span> <span class="string">a</span> <span class="string">Secret)</span></span><br><span class="line">    <span class="attr">SecretName:</span>  <span class="string">default-token-</span> <span class="string">w54hg</span></span><br><span class="line">    <span class="attr">Optional:</span>    <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><font color="red">该挂载点目录中通常存在3个文件：ca.crt、namespace和token，其中，token文件保存了ServiceAccount的认证令牌，容器中的进程使用该账户认证到API Server，进而由认证插件完成用户认证并将其用户名传递给授权插件。</font><br>每个Pod对象只有一个服务账户，若创建Pod资源时未予明确指定，则ServiceAccount准入控制器会为其自动附加当前名称空间中默认的服务账户，其名称通常为default。下面的命令显示了default这个服务账户的详细信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe serviceaccounts/default -n default</span></span><br><span class="line">Name:                default</span><br><span class="line">……</span><br><span class="line">Mountable secrets:   default-token-w54hg</span><br><span class="line">Tokens:              default-token-w54hg</span><br><span class="line">Events:              &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>Kubernetes系统通过3个独立的组件间相互协作实现了上面描述的Pod对象服务账户的自动化过程：<font color="red">ServiceAccount准入控制器、令牌控制器和ServiceAccount控制器。ServiceAccount控制器负责为名称空间管理相应的资源对象，它需要确保每个名称空间中都存在一个名为default的服务账户对象。ServiceAccount准入控制器内置在API Server中，负责在创建或更新Pod时按需进行ServiceAccount资源对象相关信息的修改，包括如下操作。</font></p>
<ul>
<li>若Pod没有显式定义使用的ServiceAccount对象，则将其设置为default。</li>
<li>若Pod显式引用了ServiceAccount，则负责检查被引用的对象是否存在，不存在时将拒绝Pod资源的创建请求。</li>
<li>若Pod中不包含ImagePullSecerts，则把ServiceAccount的ImagePullSecrets附加其上。</li>
<li>为带有访问API的令牌的Pod对象添加一个存储卷。</li>
<li>为Pod对象中的每个容器添加一个volumeMounts，将ServiceAccount的存储卷挂载至/var/run/secrets/kubernetes.io/serviceaccount。</li>
</ul>
<p>令牌控制器是控制平面组件Controller Manager中的一个专用控制器，它工作于异步模式，负责完成如下任务：</p>
<ul>
<li>监控ServiceAccount的创建操作，并为其添加用于访问API的Secret对象；</li>
<li>监控ServiceAccount的删除操作，并删除其相关的所有ServiceAccount令牌密钥；</li>
<li>监控Secret对象的添加操作，确保其引用的ServiceAccount存在，并在必要时为Secret对象添加认证令牌；</li>
<li>监控Secret对象的删除操作，以确保删除每个ServiceAccount对此Secret的引用。</li>
</ul>
<p>为确保完整性等，必须为kube-controller-manager使用–service-account-private-key-file选项指定一个私钥文件，用于对生成的ServiceAccount令牌进行签名，该私钥文件必须是PEM格式。同时，要使用–service-account-key-file为kube-apiserver指定与前面的私钥配对的公钥文件，实现在认证期间对认证令牌进行校验。</p>
<h3 id="ServiceAccount基础应用"><a href="#ServiceAccount基础应用" class="headerlink" title="ServiceAccount基础应用"></a>ServiceAccount基础应用</h3><p>ServiceAccount是Kubernetes API上的一种资源类型，它属于名称空间级别，用于让Pod对象内部的应用程序在与API Server通信时完成身份认证。如前所述，同样名为ServiceAccount的准入控制器实现了服务账户自动化，该准入控制器为每个名称空间都自动生成了一个名为default的默认资源对象。<br>每个Pod对象可附加其所属名称空间中的一个ServiceAccount资源，且只能附加一个。不过，一个ServiceAccount资源可由其所属名称空间中的多个Pod对象共享使用。创建Pod资源时，用户可使用spec.serviceAccountName属性直接指定要使用的ServiceAccount对象，或者省略此字段而由准入控制器自动附加当前名称空间中默认的ServiceAccount，以确保每个Pod对象至少基于该服务账户有权限读取当前名称空间中其他资源对象的元数据信息。<br>Kubernetes也支持用户按需创建ServiceAccount资源并将其指定到特定应用的Pod对象之上，结合集群启用的授权机制为该ServiceAccount资源赋予所需要的更多权限，从而构建出更加灵活的权限委派模型。</p>
<h4 id="命令式ServiceAccount资源创建"><a href="#命令式ServiceAccount资源创建" class="headerlink" title="命令式ServiceAccount资源创建"></a>命令式ServiceAccount资源创建</h4><p>kubectl create serviceaccount命令能够快速创建自定义的ServiceAccount资源，我们仅需要在命令后给出目标ServiceAccount资源的名称。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create serviceaccount my-service-account</span></span><br><span class="line">serviceaccount/my-service-account created</span><br></pre></td></tr></table></figure>

<p>Kubernetes会为创建的ServiceAccount资源自动生成并附加一个Secret对象，该对象以ServiceAccount资源名称为前缀，如下面命令的执行结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get serviceaccounts/my-service-account -o jsonpath=&#123;.secrets[0].name&#125;</span></span><br><span class="line">my-service-account-token-zjbxb</span><br></pre></td></tr></table></figure>

<p>该Secret对象属于特殊的kubernetes.io/service-account-token类型，它包含ca.crt、namespace和token这3个数据项，它们分别包含Kubernetes Root CA证书、Secret对象所属的名称空间和访问API Server的令牌。由Pod对象以Secret存储卷的方式将该类型的Secret对象挂载至/var/run/secrets/kubernetes.io/serviceaccount目录后，这3个数据项映射为同名的3个文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get secrets/my-service-account-token-zjbxb -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN5REN……</span><br><span class="line">  namespace: ZGVmYXVsdA==</span><br><span class="line">  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNklsUldZWFp……</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/service-account.name: my-service-account</span><br><span class="line">    kubernetes.io/service-account.uid: 0a7937c3-d4fd-4d1a-b685-3f775b3c1a21</span><br><span class="line">  ……</span><br><span class="line">type: kubernetes.io/service-account-token</span><br></pre></td></tr></table></figure>

<h4 id="ServiceAccount资源清单"><a href="#ServiceAccount资源清单" class="headerlink" title="ServiceAccount资源清单"></a>ServiceAccount资源清单</h4><p>事实上，以资源规范形式创建Secret对象时，以类似如上命令结果的形式，为Secret对象使用资源注解kubernetes.io/service-account.name引用一个现存的ServiceAccount对象，并指定资源类型为特定的kubernetes.io/service-account-token，我们便可以将指定的ServiceAccount对象引用的Secret对象予以置换，该Secret对象同样会自动生成固定的3个数据项。<br>更完善地创建ServiceAccount资源的方式是使用资源规范，该规范比较简单，它没有spec字段，而是将几个关键定义直接通过一级字段给出，具体的规范格式如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>               <span class="comment"># ServiceAccount所属的API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span>         <span class="comment"># 资源类型标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>              <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>         <span class="comment"># ServiceAccount是名称空间级别的资源</span></span><br><span class="line"><span class="string">automountServiceAccountToken</span> <span class="string">&lt;boolean&gt;</span>   <span class="comment"># 是否让Pod自动挂载API令牌</span></span><br><span class="line"><span class="string">secrets</span> <span class="string">&lt;[]Object&gt;</span>           <span class="comment"># 以该SA运行的Pod要使用的Secret对象所组成的列表</span></span><br><span class="line">  <span class="string">apiVersion</span> <span class="string">&lt;string&gt;</span>        <span class="comment"># 引用的Secret对象所属的API群组及版本，可省略</span></span><br><span class="line">  <span class="string">kind</span> <span class="string">&lt;string&gt;</span>              <span class="comment"># 引用的资源类型，这里是指Secret，可省略</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>              <span class="comment"># 引用的Secret对象的名称，通常仅给出该字段即可</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>         <span class="comment"># 引用的Secret对象所属的名称空间</span></span><br><span class="line">  <span class="string">uid</span>  <span class="string">&lt;string&gt;</span>              <span class="comment"># 引用的Secret对象的标识符</span></span><br><span class="line"><span class="string">imagePullSecrets</span> <span class="string">&lt;[]Object&gt;</span>  <span class="comment"># 引用的用于下载Pod中容器镜像的Secret对象列表</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>              <span class="comment"># docker-registry类型的Secret资源名称</span></span><br></pre></td></tr></table></figure>

<p>下面的配置清单是一个ServiceAccount资源示例，它位于serviceaccount-demo.yaml文件中，它仅指定了资源名称，以及允许Pod对象将其自动挂载为存储卷，引用的Secret对象则交由系统自动生成。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">namespace-admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">automountServiceAccountToken:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>将配置清单中定义的default-ns-admin资源创建到集群上，ServiceAccount控制器会自动为其附加以该资源名称为前缀的Secret对象，如下面的命令结果所示。随后，用户便可以在创建的Pod对象上引用该ServiceAccount对象，以借助权限管理机制实现自主控制Pod对象资源访问权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f serviceaccount-demo.yaml</span> </span><br><span class="line">serviceaccount/namespace-admin created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get serviceaccount/namespace-admin -o jsonpath=&#123;.secrets[0].name&#125;</span></span><br><span class="line">namespace-admin-token-mhdbn</span><br></pre></td></tr></table></figure>

<p>另外，ServiceAccount资源还可以基于spec.imagePullSecret字段附带一个由下载镜像专用的Secret资源组成的列表，让Pod对象在创建容器时且从私有镜像仓库下载镜像文件之前完成身份认证。下面的示例定义了一个从本地私有镜像仓库Harbor下载镜像文件时的Secret对象信息的ServiceAccount。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">eshop-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">eshop</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local-harbor-secret</span></span><br></pre></td></tr></table></figure>

<p>其中，local-harbor-secret是docker-registry类型的Secret对象，包含目标Docker Registry的服务入口、用户名、密码及用户的电子邮件等信息，它必须要由用户提前手动创建。该Pod资源所在节点上的kubelet进程使用Secret对象中的令牌认证到目标Docker Registry，以下载运行容器所需要的镜像文件。</p>
<h3 id="Pod资源上的服务账户"><a href="#Pod资源上的服务账户" class="headerlink" title="Pod资源上的服务账户"></a>Pod资源上的服务账户</h3><p>借助权限分配模型，按需应用“最小权限法则”将不同的资源操作权限配置给不同的账户，是有效降低安全风险的法则之一。有相当一部分Kubernetes原生应用程序依赖的权限都会大于从Pod默认ServiceAccount继承到的权限，且彼此间各有不同，为这类应用定制一个专用的ServiceAccount并授予所需的全部权限是主流的解决方案。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-with-sa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">adminbox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ikubernetes/admin-toolbox:v1.0</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">namespace-admin</span></span><br></pre></td></tr></table></figure>

<p>该Pod资源创建完成后会以Secret存储卷的形式自动挂载serviceaccounts/default-ns-admin的Secret对象，如下面的命令结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f pod-with-serviceaccount.yaml</span> </span><br><span class="line">pod/pod-with-sa created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods/pod-with-sa -o jsonpath=<span class="string">&#x27;&#123;range .spec.volumes[*]&#125;&#123;.name&#125;&#123;end&#125;&#x27;</span></span></span><br><span class="line">namespace-admin-token-mhdbn</span><br></pre></td></tr></table></figure>

<p>Secret对象默认的挂载路径是/var/run/secrets/kubernetes.io/serviceaccount。与API Server交互时，工作负载进程会使用该目录下的ca.crt证书文件验证API Server的服务器证书是否为自己信任的证书颁发机构（所在集群的kubernetes-ca）所签发；验证服务器身份成功通过后，工作负载向API Server请求操作namespace文件指定的名称空间中的资源时，会将token文件中的令牌以承载令牌的认证方式提交给API Server进行验证，权限校验则由授权插件完成。我们可在pods/pod-with-sa的交互式接口中进行访问测试。</p>
<ul>
<li>1）切换到pods/pod-with-sa的adminbox容器的Secret对象的挂载点为工作目录以便于加载所需要的文件：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it pod-with-sa -- /bin/sh</span></span><br><span class="line">[root@pod-with-sa /]# cd /var/run/secrets/kubernetes.io/serviceaccount/</span><br></pre></td></tr></table></figure>

<ul>
<li>2）在容器中使用curl命令向API Server发起访问请求，–cacert选项用于指定验证服务器端的CA证书，而-H选项用于自定义头部，它指定了使用的承载令牌；下面的命令使用了“命令引用”机制来加载token和namespace文件的内容，其结果显示容器进程使用指定的ServiceAccount进行身份认证成功。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@pod-with-sa …]# curl --cacert ./ca.crt -H &quot;Authorization: Bearer $(cat ./token)&quot; \</span><br><span class="line">              https://kubernetes/api/v1/namespaces/$(cat ./namespace)/</span><br><span class="line">  ……</span><br><span class="line">  &quot;status&quot;: &quot;Failure&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;……forbidden: User \&quot;system:serviceaccount:default:namespace-</span><br><span class="line">  admin\&quot;……&quot;</span><br><span class="line">  &quot;reason&quot;: &quot;Forbidden&quot;,</span><br><span class="line">  ……</span><br></pre></td></tr></table></figure>

<p>接下来，单独向serviceaccount/namespace-admin授予default名称空间的管理权限，pods/pod-with-sa中的进程便能借助该ServiceAccount的身份管理相应名称空间下的资源，这可以使用类似于向普通用户ilinux授权的方式进行，感兴趣的读者可自行进行测试。</p>
<ul>
<li>1）切换至kubectl管理终端运行如下资源创建命令：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create rolebinding namespace-admin-binding-admin --clusterrole=admin \</span></span><br><span class="line"><span class="language-bash">     --serviceaccount=default:namespace-admin -n default</span></span><br><span class="line">rolebinding.rbac.authorization.k8s.io/namespace-admin-binding-admin created</span><br></pre></td></tr></table></figure>

<ul>
<li>2）回到pods/pod-with-sa的adminbox容器中再次运行访问测试命令即可验证授权结果，如下命令表示namespace-admin用户已然有权限访问default名称空间。事实上，它拥有该名称空间中所有资源的CRUD权限。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@pod-with-sa /run/secrets/kubernetes.io/serviceaccount]# curl --cacert ./ca.crt \</span><br><span class="line">    -H &quot;Authorization: Bearer $(cat ./token)&quot; \</span><br><span class="line">    https://kubernetes/api/v1/namespaces/$(cat ./namespace)/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;kind&quot;: &quot;Namespace&quot;,</span><br><span class="line">  &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;default&quot;,</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>但是，default名称空间引用了serviceaccounts/default资源中Pod的容器进程却不具有如上权限，因为它们并未获得相应的授权。事实上，kube-system名称空间中的许多应用都使用了专用的ServiceAccount资源，例如Flannel、CoreDNS、kube-proxy以及多种控制器等，感兴趣的读者可自行通过命令了解相应的ServiceAccount资源信息。</p>
<h2 id="X509数字证书认证"><a href="#X509数字证书认证" class="headerlink" title="X509数字证书认证"></a>X509数字证书认证</h2><p>X509数字证书认证常用的方式有“单向认证”和“双向认证”。SSL / TLS最常见的应用场景是将X.509数字证书与服务器端关联，但客户端不使用证书。单向认证是客户端能够验证服务端的身份，但服务端无法验证客户端的身份，至少不能通过SSL / TLS协议进行。之所以如此，是因为SSL / TLS安全性最初是为互联网应用开发，保护客户端是高优先级的需求，它可以让客户端确保目标服务器不会被冒名顶替，如图9-3所示。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183109261.png" alt="image-20220218183109261"></p>
<p>基于其他机制（如HTTP基本认证）验证客户端身份可能更容易些，而且这些机制没有生成和分发X.509数字证书的高昂开销。但安全性要求较高的场景中，使用组织私有的证书分发系统也一样能够借助数字证书完成客户端认证。图9-4展示了服务端与客户端的双向认证机制。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183126472.png" alt="image-20220218183126472"></p>
<p>双向认证的场景中，服务端与客户端需各自配备一套数字证书，并拥有信任的签证机构的证书列表。使用私有签证机构颁发的数字证书时，除了证书管理和分发，通常还要依赖用户手动将此私有签证机构的证书添加到信任的签证机构列表中。X509数字证书认证是Kubernetes默认使用的认证机制，采用双向认证模式。</p>
<h3 id="Kubernetes的X509数字证书认证体系"><a href="#Kubernetes的X509数字证书认证体系" class="headerlink" title="Kubernetes的X509数字证书认证体系"></a>Kubernetes的X509数字证书认证体系</h3><p>构建安全基础通信环境的Kubernetes集群时，需要用到PKI基础设施以完成独立HTTPS安全通信及X509数字证书认证的场景有多种，如图9-5所示。API Server是整个Kubernetes集群的通信网关，controller-manager、scheduler、kubelet及kube-proxy等API Server的客户端均需要经由API Server与etcd通信，完成资源状态信息获取及更新等。同样出于安全通信的目的，Master的各组件（API Server、controller-manager和scheduler）需要基于SSL/TLS向外提供服务，而且与集群内部组件间通信时（主要是各节点上的kubelet和kube-proxy）还需要进行双向身份验证。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183202775.png" alt="image-20220218183202775"></p>
<p>Kubernetes集群中存在3个需要独立完成X509数字证书认证和HTTPS通信的体系：一是etcd集群成员、服务器及其客户端；二是API Server及其客户端，以及kubelet API及其客户端；三是Kubernetes认证代理体系中的服务器和客户端。这3个独立的体系各自需要一个独立证书颁发机构为体系内的服务器和客户端颁发证书，完成体系内的组件身份认证同时又彼此隔离，如表9-1所示。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183221066.png" alt="image-20220218183221066"></p>
<p>（1）etcd集群CA及相关的数字证书</p>
<p>Kubernetes的API Server将集群的状态数据存储到集群存储服务etcd中，包括含有敏感数据的Secret资源对象。出于提升服务可用性、数据冗余及安全性等目的，生产环境通常应该配置有3、5或7个节点的etcd集群，集群内各节点间基于HTTPS协议进行通信，它们使用Peer类型的数字证书进行通信时的身份认证。而且，各etcd节点提供Server类型的数字证书与客户端建立安全连接，并验证其客户端Client类型的数字证书。Kubernetes集群各组件中，kube-apiserver是唯一一个可直接与集群存储通信的组件，它是etcd服务的客户端。<br>（2）Kubernetes集群CA及相关的数字证书<br>我们知道，Kubernetes集群的其他各组件均需要通过kube-apiserver访问集群资源，同样出于安全性等目的，API Server也要借助HTTPS协议与其客户端通信，而X509双向数字证书认证仅是API Server支持的认证方式中的一种，客户端也可能会使用HTTP Basic或Bearer Token认证方式接入到API Server。<br>另外，kubelet也通过HTTPS端点暴露了一组API，这些API提供了多个不同级别的敏感数据接口，并支持来自客户端的请求在节点和容器上执行不同级别的操作。默认情况下，匿名请求将自动隶属于system:unauthenticated用户组，其用户名为system:anonymous。不过，kubelet可使用–anonymous-auth=false选项拒绝匿名访问，并通过–client-ca-file选项指定CA方式验证客户端身份。kubelet可直接使用kubernetes-ca，同时应该为kube-apiserver使用–kubelet-client-certificate和–kubelet-client-key选项指定认证到kubelet的客户端证书与私钥。<br>（3）认证代理服务体系CA及相关的数字证书<br>API Server支持将认证功能交由外部的其他认证服务代为完成，这些服务通过特定的响应头部返回身份验证的结果状态，API Server扩展服务就是认证代理的最常见应用场景之一。<br>除了API Server提供的核心API，Kubernetes还支持通过聚合层（aggregation layer）对其进行扩展。简单来说，聚合层允许管理员在群集中部署使用其他Kubernetes风格的API，例如service catalog或用户自定义的API Server等。聚合层本身打包在kube-apiserver程序中，并作为进程的一部分运行，但仅在管理员通过指定的APIService对象注册扩展资源之后，它才会代理转发相应的请求。而APIService则会由运行在Kubernetes集群上的Pod中的extention-apiserver实现。<br>创建一个APIService资源时，作为注册和发现过程的一部分，kube-aggregator控制器（位于kube-apiserver内部）将与extention-apiserver的HTTP2连接，而后将经过身份验证的用户请求经由此连接代理到extention-apiserver上，于是，kube-aggregator被设置为执行RequestHeader客户端认证。<br>不过，只有kube-apiserver在启动时使用了如下选项时，才能启用其内置的聚合层：</p>
<ul>
<li>–requestheader-client-ca-file=&lt;path to aggregator CA cert&gt;</li>
<li>–requestheader-allowed-names=front-proxy-client</li>
<li>–requestheader-extra-headers-prefix=X-Remote-Extra-</li>
<li>–requestheader-group-headers=X-Remote-Group</li>
<li>–requestheader-username-headers=X-Remote-User</li>
<li>–proxy-client-cert-file=&lt;path to aggregator proxy cert&gt;</li>
<li>–proxy-client-key-file=&lt;path to aggregator proxy key&gt;</li>
</ul>
<p>proxy-client-cert-file和proxy-client-key-file包含kube-aggregator执行客户端证书身份验证的证书/密钥对，它使用requestheader-client-ca-file中指定的CA文件对聚合器证书进行签名。requestheader-allowed-names包含允许充当伪装前端代理的身份/名称列表（客户端证书中使用的CN），而requestheader-username-headers、requestheader-group-headers和requestheader-extraheaders-prefix携带一个HTTP头的列表，用于携带远程用户信息。<br>完整运行的Kubernetes系统需要为etcd、API Server及前端代理（front proxy）生成多个数字证书，如表9-2所示。<br>表9-2　Kubernetes上的数字证书</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183239124.png" alt="image-20220218183239124"></p>
<p>另外，其他集群上运行的应用（Pod）同其客户端的通信经由不可信的网络传输时也可能需要用到TLS/SSL协议，例如Nginx Pod与其客户端间的通信，客户端来自于互联网时，此处通常需配置一个公信的服务端证书。<br>显然，普通用户使用这种认证方式的前提是，它们各自拥有自己的数字证书，证书中的CN和O属性分别提供了准确的用户标识和用户组。API Server可接受或拒绝这些证书，评估标准在于证书是否由API Server信任的客户端证书CA（由选项–client-ca-file指定，默认为kubernetes-ca）所签发，但API Server自身并不了解这些证书，因此也不了解各个用户，它仅知道负责为各个客户端颁发证书的CA。因此，相较于静态密码文件认证和静态令牌文件认证来说，X509数字证书认证实现了用户管理与Kubernetes集群的分离，且有着更好的安全性。<br>X509数字证书认证因其可不依赖第三方服务、有着更好的安全性以及与API Server相分离等优势，成为Kubernetes系统内部默认使用的认证方式。但是，将X509数字证书用于普通用户认证的缺陷也是显而易见的，它主要表现在如下两个方面。</p>
<ul>
<li>证书的到期时间在颁发时设定，其生命周期往往很长（数月甚至数年），且事实上的身份验证功能也是在颁发时完成，若撤销用户的可用身份只能使用证书吊销功能完成。</li>
<li>现实使用中，证书通常由一些通用的签证机构签发，而API Server需要信任该CA；显然，获得该CA使用权限的用户便能够授予自己可认证到的Kubernetes的任意凭据或身份，因而集群管理员必须自行集中管理证书，这任务往往并不轻松。<br>对于大型组织来说，Kubernetes系统用户量大且变动频繁，静态密码文件和静态令牌文件认证方式动辄需要重启API Server，而X509认证中的证书维护开销较高且无法灵活变动凭据生效期限，因此这些认证方式都非理想选择。实践中，人们通常使用ID Token进行Kubernetes的普通用户身份认证，API Server的OpenID Connect令牌认证插件即用于该场景。</li>
</ul>
<h3 id="TLS-Bootstrapping机制"><a href="#TLS-Bootstrapping机制" class="headerlink" title="TLS Bootstrapping机制"></a>TLS Bootstrapping机制</h3><p>TLS Bootstrapping机制有什么用途呢？Kubernetes采用了由kubelet自行生成私钥和证书签署请求，而后发送给集群上的证书签署进程（CA），由管理员审核后予以签署或直接由控制器进程自动统一签署。这种方式就是kubelet TLS Bootstrapping机制。<br>然而，一旦开启TLS Bootstrapping功能，任何kubelet进程都可以向API Server发起验证请求并加入到集群中，包括那些非计划或非授权主机，这必将增大管理验证操作时的审核工作量。为此，API Server设计了可经由–enable-bootstrap-token-auth选项启用的Bootstrap Token（引导令牌）认证插件。该插件用于加强TLS Bootstrapping机制，仅那些通过Bootstrap Token认证的请求才可以使用TLS Bootstrapping发送证书签署请求给控制平面，并由相应的审批控制器（approval controller）完成证书签署和分发。<br>kubeadm启用了节点加入集群时的证书自动签署功能，因此加入过程在kubeadm join命令成功后即完成。<br>Kubelet会把签署后的证书及配对的私钥存储到–cert-dir选项指定的目录下，并以之生成kubeconfig格式的配置文件，该文件的保存路径以–kubeconfig选项指定，它保存有API Server的地址以及认证凭据。若指定的kubeocnfig配置文件不存在，kubelet会转而使用Bootstrap Token，从API Server自动请求完成TLS Bootstrapping过程。<br>kube-controller-manager内部有一个用于证书颁发的控制循环，它采用了类似于cfssl签证器格式的自动签证器，颁发的所有证书默认具有一年有效期限。正常使用中的Kubernetes集群需要在证书过期之前完成更新，以免集群服务不可用。较新版本的kubeadm部署工具已经能够自动完成更新，如下第一条命令用于检测证书有效期限，在接近过期时间的情况下，即可使用第二条命令进行更新。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~# </span><span class="language-bash">kubeadm alpha certs check-expiration</span></span><br><span class="line"><span class="meta">~# </span><span class="language-bash">kubeadm alpha certs renew all</span></span><br></pre></td></tr></table></figure>

<p>Kubernetes 1.8之后的版本中使用的csrapproving审批控制器内置于kube-controller-manager，并且默认为启用状态。此审批控制器使用SubjectAccessview API确认给定的用户是否有权限请求CSR（证书签署请求），而后根据授权结果判定是否予以签署。不过，为了避免同其他审批器冲突，内置的审批器并不显式拒绝CSR，而只是忽略它们。</p>
<h2 id="kubeconfig配置文件"><a href="#kubeconfig配置文件" class="headerlink" title="kubeconfig配置文件"></a>kubeconfig配置文件</h2><p>  Kubernetes设计了一种称为kubeconfig的配置文件，它保存有接入一到多个Kubernetes集群的相关配置信息，并允许管理员按需在各配置间灵活切换，如图9-6所示。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183729156.png" alt="image-20220218183729156"></p>
<p>客户端程序可通过默认路径、–kubeconfig选项或者KUBECONFIG环境变量自定义要加载的kubeconfig文件，从而能够在每次的访问请求中可认证到目标API Server。</p>
<h3 id="kubeconfig文件格式"><a href="#kubeconfig文件格式" class="headerlink" title="kubeconfig文件格式"></a>kubeconfig文件格式</h3><p>kubeconfig文件中，各集群的接入端点以列表形式定义在clusters配置段中，每个列表项代表一个Kubernetes集群，并拥有名称标识；各身份认证信息（credentials）定义在users配置段中，每个列表项代表一个能够认证到某Kubernetes集群的凭据。将身份凭据与集群分开定义以便复用，具体使用时还要以context（上下文）在二者之间按需建立映射关系，各context以列表形式定义在contexts配置段中，而当前使用的映射关系则定义在current-context配置段中。kubeconfig文件的格式如图9-7所示。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218183747264.png" alt="image-20220218183747264"></p>
<p>使用kubeadm初始化Kubernetes集群过程中，在Master节点上生成的/etc/kubernetes/admin.conf文件就是一个kubeconfig格式的文件，它由kubeadm init命令自动生成，可由kubectl加载后接入当前集群的API Server。kubectl加载kubeconfig文件的默认路径为$HOME/.kube/config，在kubeadm init命令初始化集群过程中有一个步骤便是将/etc/kubernetes/admin.conf复制为该默认搜索路径上的文件。当然，我们也可以通过–kubeconfig选项或KUBECONFIG环境变量将其修改为其他路径。<br>kubectl config view命令能打印kubeconfig文件的内容，下面的命令结果显示了默认路径下的文件配置，包括集群列表、用户列表、上下文列表以及当前使用的上下文（current-context）等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config view</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority-data: DATA+OMITTED</span><br><span class="line">    server: https://k8s-api.ilinux.io:6443</span><br><span class="line">  name: kubernetescontexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: kubernetes</span><br><span class="line">    user: kubernetes-admin</span><br><span class="line">  name: kubernetes-admin@kubernetescurrent-context: kubernetes-admin@kubernetesusers:</span><br><span class="line">- name: kubernetes-admin</span><br><span class="line">  user:</span><br><span class="line">    client-certificate-data: REDACTED</span><br><span class="line">    client-key-data: REDACTED</span><br></pre></td></tr></table></figure>

<p>用户也可以在kubeconfig配置文件中按需自定义相关的配置信息，以实现使用不同的用户账户接入集群等功能。kubeconfig是一个文本文件，尽管可以使用文本处理工具直接编辑它，但强烈建议用户使用kubectl config及其子命令进行该文件的设定，以便利用其他自动进行语法检测等额外功能。kubectl config的常用子命令有如下几项。</p>
<ul>
<li>view：打印kubeconfig文件内容。</li>
<li>set-cluster：设定新的集群信息，以单独的列表项保存于clusters配置段。</li>
<li>set-credentials：设置认证凭据，保存为users配置段的一个列表项。</li>
<li>set-context：设置新的上下文信息，保存为contexts配置段的一个列表项。</li>
<li>use-context：设定current-context配置段，确定当前以哪个用户的身份接入到哪个集群之中。</li>
<li>delete-cluster：删除clusters中指定的列表项。</li>
<li>delete-context：删除contexts中指定的列表项。</li>
<li>get-clusters：获取clusters中定义的集群列表。</li>
<li>get-contexts：获取contexts中定义的上下文列表。</li>
</ul>
<p>kubectl config命令的相关操作将针对加载的单个kubeconfig文件进行，它根据其优先级由高到低，依次搜索–kubeconfig选项指定的文件、KUBECONFIG环境变量指定的文件和默认的.HOME/.kube/config文件，以其中任何一种方式加载到配置文件后即可终止搜索过程。不过，kubectl config命令支持同时使用多个kubeconfig文件，以及将多个配置文件合并为一个。</p>
<h3 id="自定义kubeconfig文件"><a href="#自定义kubeconfig文件" class="headerlink" title="自定义kubeconfig文件"></a>自定义kubeconfig文件</h3><p>通常，一个完整kubeconfig配置的定义至少应该包括集群、身份凭据、上下文及当前上下文4项，但在保存有集群和身份凭据的现有kubeconfig文件基础上添加新的上下文时，可能只需要提供身份凭据而复用已有的集群定义，具体的操作步骤要按实际情况进行判定。<br>例如，我们下面尝试创建一个新的kubeconfig文件，设定它使用此前定义的基于静态密码文件认证的ilinux用户接入到现有的Kubernetes集群，该集群API Server的网络端点为<a href="https://k8s-api.ilinux.io:6443，相关的CA证书保存在Master节点上的/etc/kubernetes/pki/ca.crt文件中，而配置结果则使用--kubeconfig选项保存在当前用户主目录下的.kube/kube-dev.config文件中。">https://k8s-api.ilinux.io:6443，相关的CA证书保存在Master节点上的/etc/kubernetes/pki/ca.crt文件中，而配置结果则使用--kubeconfig选项保存在当前用户主目录下的.kube/kube-dev.config文件中。</a><br>步骤1：添加集群配置，包括集群名称、API Server URL和信任的CA的证书；clusters配置段中的各列表项名称需要唯一。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-cluster kube-dev --embed-certs=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">    --certificate-authority=/etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="language-bash">    --server=<span class="string">&quot;https://k8s-api.ilinux.io:6443&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">Cluster &quot;kube-dev&quot; set.</span><br></pre></td></tr></table></figure>

<p>步骤2：添加身份凭据，使用静态密码文件认证的客户端提供用户名和密码即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-credentials ilinux \</span></span><br><span class="line"><span class="language-bash">    --username=ilinux --password=ilinux@MageEdu \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">User &quot;ilinux&quot; set.</span><br></pre></td></tr></table></figure>

<p>步骤3：以用户ilinux的身份凭据与kube-dev集群建立映射关系。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-context ilinux@kube-dev \</span></span><br><span class="line"><span class="language-bash">    --cluster=kube-dev --user=ilinux \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">Context &quot;ilinux@kube-dev&quot; created.</span><br></pre></td></tr></table></figure>

<p>步骤4：设置当前上下文为ilinux@kube-dev。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config use-context ilinux@kube-dev --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">Switched to context &quot;ilinux@kube-dev&quot;.</span><br></pre></td></tr></table></figure>

<p>步骤5：预览kube-dev.config文件，确认其配置信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config view --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br></pre></td></tr></table></figure>

<p>步骤6：使用该kubeconfig中的当前上下文进行测试访问；该用户仅被授权了default名称空间的所有权限，因而不具有列出集群级别资源的权限，但能查看default名称空间的状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get namespaces --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">Error from server (Forbidden): namespaces is forbidden: User &quot;ilinux&quot; cannot list resource &quot;namespaces&quot; in API group &quot;&quot; at the cluster scope</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get namespaces/default --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">NAME       STATUS     AGE</span><br><span class="line">default    Active     3d</span><br></pre></td></tr></table></figure>

<p>上面的第6步确认了自定义配置中的ilinux用户有效可用，它被API Server借助静态密码文件认证插件完成认证并标识为ilinux用户，从而拥有该用户的资源操作权限。为了进一步测试并了解kubeconfig的使用格式，下面把基于令牌文件认证的ik8s用户添加进同一个kubeconfig文件中。ik8s用户同ilinux用户位于同一集群上，因此，我们可省略添加集群的步骤而直接复用它。<br>步骤7：添加身份凭据，使用静态令牌文件认证的客户端认证时只需要提供静态令牌信息；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">TOKEN=$(sudo awk -F <span class="string">&quot;,&quot;</span> <span class="string">&#x27;$2==&quot;ik8s&quot;&#123;print $1&#125;&#x27;</span> /etc/kubernetes/authfiles/token.csv)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-credentials ik8s --token=<span class="string">&quot;<span class="variable">$TOKEN</span>&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">User &quot;ik8s&quot; set.</span><br></pre></td></tr></table></figure>

<p>步骤8：为用户ik8s的身份凭据与kube-dev集群建立映射关系。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-context ik8s@kube-dev \</span></span><br><span class="line"><span class="language-bash">    --cluster=kube-dev --user=ik8s \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">Context &quot;ik8s@kube-dev&quot; created.</span><br></pre></td></tr></table></figure>

<p>步骤9：将当前上下文切换为ik8s@kube-dev。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config use-context ik8s@kube-dev --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">Switched to context &quot;ik8s@kube-dev&quot;.</span><br></pre></td></tr></table></figure>

<p>步骤10：预览kube-dev.config文件，确认ik8s用户相关的各项配置信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config view --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br></pre></td></tr></table></figure>

<p>步骤11：依旧使用当前上下文发起集群访问测试，ik8s用户未获得任何授权，但它能够被系统识别为ik8s用户，这表示身份认证请求成功返回；我们这次使用kubectl的whoami插件进行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ kubectl whoami --kubeconfig=$HOME/.kube/kube-dev.config</span><br><span class="line">ik8s</span><br></pre></td></tr></table></figure>

<p><font color="red">除了静态令牌，客户端认证到API Server的各种令牌都可以使用前面的这种方式添加到kubeconfig文件中，包括ServiceAccount令牌、OpenID Connnect令牌和Bootstrap令牌等。</font><br>当kubectl引用了拥有两个及以上context的kubeconfig文件时，可随时通过kubectl config use-context命令在不同上下文之间切换，它们可能使用不同的身份凭据接入相同的集群或不同的集群之上。如下命令结果表示当前加载的配置文件中共有两个context，而拥有星号标识的是当前使用的context，即current-context。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config get-contexts --kubeconfig=<span class="variable">$HOME</span>/.kube/kube-dev.config</span></span><br><span class="line">CURRENT   NAME               CLUSTER    AUTHINFO   NAMESPACE</span><br><span class="line">*         ik8s@kube-dev      kube-dev   ik8s       </span><br><span class="line">          ilinux@kube-dev    kube-dev   ilinux</span><br></pre></td></tr></table></figure>

<p>实践中，API Server支持的X509数字证书认证和OpenID Connect令牌认证才是客户端使用最多的认证方式，我们后面使用一节的篇幅来专门介绍它们的配置。</p>
<h3 id="X509数字证书身份凭据"><a href="#X509数字证书身份凭据" class="headerlink" title="X509数字证书身份凭据"></a>X509数字证书身份凭据</h3><p>kubeadm部署Kubernetes集群的过程中会自动生成多个kubeconfig文件，它们是默认位于/etc/kubernetes目录下以.conf为后缀名的文件，前缀名称代表了它的适用场景，其中的admin.conf中保存了以X509数字证书格式提供身份凭据的kubernetes-admin用户，该用户能够以管理员的身份对当前集群发起资源操作请求。<br>由kubeadm初始化的Kubernetes集群上，kube-apiserver默认信任的CA就是集群自己的kubernetes-ca，该CA的数字证书是Master节点之上的/etc/kubernetes/pki/ca.crt文件。于是，客户端按需生成证书签署请求，再由管理员通过kubernetes-ca为客户端签署证书，便可让客户端以其证书中的CN为用户名认证到API Server上。为了便于说明问题，下面将客户端生成私钥和证书签署请求，服务器签署该请求，以及客户端将证书配置为kubeconfig文件的步骤统一进行说明，所有操作都在Master节点上运行。<br>步骤1：以客户端的身份，生成目标用户账号mason的私钥及证书签署请求，保存在用户主目录下的.certs目录中。<br>① 生成私钥文件，注意其权限应该为600以阻止其他用户读取。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">mkdir</span> <span class="variable">$HOME</span>/.certs</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">(<span class="built_in">umask</span> 077; openssl genrsa -out <span class="variable">$HOME</span>/.certs/mason.key 2048)</span></span><br></pre></td></tr></table></figure>

<p>② 创建证书签署请求，-subj选项中CN的值将被API Server识别为用户名，O的值将被识别为用户组。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">openssl req -new -key <span class="variable">$HOME</span>/.certs/mason.key \</span></span><br><span class="line"><span class="language-bash">-out <span class="variable">$HOME</span>/.certs/mason.csr \</span></span><br><span class="line"><span class="language-bash">-subj <span class="string">&quot;/CN=mason/O=developers&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>步骤2：以kubernetes-ca的身份签署ikubernetes的证书请求，这里直接读取相关的CSR文件，并将签署后的证书仍然保存在当前系统用户主目录下的.certs中。<br>① 基于kubernetes-ca签署证书，并为其设置合理的生效时长，例如365天。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">sudo openssl x509 -req -days 365 -CA /etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="language-bash">-CAkey /etc/kubernetes/pki/ca.key -CAcreateserial \</span></span><br><span class="line"><span class="language-bash">-<span class="keyword">in</span> <span class="variable">$HOME</span>/.certs/mason.csr -out <span class="variable">$HOME</span>/.certs/mason.crt</span></span><br><span class="line">Signature ok</span><br><span class="line">subject=CN = mason, O = developers</span><br><span class="line">Getting CA Private Key</span><br></pre></td></tr></table></figure>

<p>② 必要时，还可以验证生成的数字证书的相关信息（可选）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> <span class="variable">$HOME</span>/.certs/mason.crt -text -noout</span></span><br></pre></td></tr></table></figure>

<p>步骤3：以ikubernetes的身份凭据生成kubeconfig配置，将其保存在kubectl默认搜索路径指向的$HOME/.kube/config文件中。另外，因指向当前集群的配置项已经存在，即位于clusters配置段中的kubernetes，这里直接复用该集群定义。<br>① 根据X509数字证书及私钥创建身份凭据，列表项名称同目标用户名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-credentials mason --embed-certs=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">  --client-certificate=<span class="variable">$HOME</span>/.certs/mason.crt \</span></span><br><span class="line"><span class="language-bash">  --client-key=<span class="variable">$HOME</span>/.certs/mason.key</span>          </span><br><span class="line">User &quot;mason&quot; set.</span><br></pre></td></tr></table></figure>

<p>② 配置context，以mason的身份凭据访问已定义的Kubernetes集群，该context的名称为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mason@kubernetes。</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-context mason@kubernetes --cluster=kubernetes --user=mason</span></span><br><span class="line">Context &quot;mason@kubernetes&quot; created.</span><br></pre></td></tr></table></figure>

<p>③ 将当前上下文切换为mason@kubernetes，或直接在kubectl命令上使用“–context= ‘mason@kubernetes’”以完成该用户的认证测试，下面的命令选择了以第二种方式进行认证，虽然提示权限错误，但mason用户已被API Server正确识别；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get namespaces/default --context=<span class="string">&#x27;mason@kubernetes&#x27;</span></span></span><br><span class="line">Error from server (Forbidden): namespaces &quot;default&quot; is forbidden: User &quot;mason&quot; cannot get resource &quot;namespaces&quot; in API group &quot;&quot; in the namespace &quot;default&quot;</span><br></pre></td></tr></table></figure>

<p>以上，我们通过创建自定义的数字证书，实现了将mason用户认证到API Server，并将该用户的身份凭据保存至kubeconfig文件中。</p>
<h3 id="多kubeconfig文件与合并"><a href="#多kubeconfig文件与合并" class="headerlink" title="多kubeconfig文件与合并"></a>多kubeconfig文件与合并</h3><p>至此，我们可以看到kubectl config一次仅能使用单个kubeconfig文件。事实上，若将两个文件路径以冒号分隔并赋值给KUBECONFIG环境变量，也能够让kubectl config一次加载多个文件信息，优先级由高到低为各文件自左而右的次序。下面两条命令的结果显示，左侧文件拥有较高的优先级，因而其配置的current-context成为默认使用的context。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">export</span> KUBECONFIG=<span class="string">&quot;<span class="variable">$HOME</span>/.kube/config:<span class="variable">$HOME</span>/.kube/kube-dev.config&quot;</span></span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config get-contexts</span></span><br><span class="line">CURRENT   NAME             CLUSTER         AUTHINFO     NAMESPACE</span><br><span class="line">      ik8s@kube-dev                 kube-dev     ik8s               </span><br><span class="line">      ilinux@kube-dev               kube-dev     ilinux             </span><br><span class="line">*     kubernetes-admin@kubernetes   kubernetes   kubernetes-admin   </span><br><span class="line">      mason@kubernetes              kubernetes   mason</span><br></pre></td></tr></table></figure>

<p>联合使用多个kubeconfig时，同样可以按需调整当前使用的context，其实现方式同使用单个kubeconfig文件并没有不同之处。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config use-context mason@kubernetes</span></span><br><span class="line">Switched to context &quot;mason@kubernetes&quot;.</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config get-contexts</span>                                       </span><br><span class="line">CURRENT   NAME         CLUSTER      AUTHINFO      NAMESPACE</span><br><span class="line">          ik8s@kube-dev                 kube-dev     ik8s               </span><br><span class="line">          ilinux@kube-dev               kube-dev     ilinux             </span><br><span class="line">          kubernetes-admin@kubernetes   kubernetes   kubernetes-admin   </span><br><span class="line">*         mason@kubernetes              kubernetes   mason</span><br></pre></td></tr></table></figure>

<p>kubectl config view命令会将多个配置文件的内容按给定的次序连接并输出，其风格类似于Linux系统的cat命令。但我们也能够在view命令中将加载的多个配置文件展平为单个配置文件的格式予以输出，并将结果保存在指定路径下便能将多个kubeconfig文件合并为一。例如，下面的命令便将KUBECONFIG环境变量中指定的两个kubeconfig文件合并成了单个配置文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config view --merge --flatten  &gt; <span class="variable">$HOME</span>/.kube/kube.config</span></span><br></pre></td></tr></table></figure>

<p>此时，切换kubectl config加载新生成的kubeconfig配置文件，它便直接拥有了此前两个文件中定义的所有信息，且current-context亦遵循此前命令中的设定，即mason@kubernetes。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">KUBECONFIG=<span class="string">&quot;<span class="variable">$HOME</span>/.kube/kube.config&quot;</span></span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config get-contexts</span></span><br></pre></td></tr></table></figure>

<p>后面章节会继续用到ilinux、ik8s和mason等多个用户来测试授权结果，因而这里直接把$HOME/.kube目录下合并生成的kube.config覆盖到默认的config，以便能随时切换到各用户。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">unset</span> KUBECONFIG</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">cp</span> <span class="variable">$HOME</span>/.kube/kube.config <span class="variable">$HOME</span>/.kube/config</span></span><br></pre></td></tr></table></figure>

<p>为了不影响后续的操作需求，我们这里还把context切换回集群管理员kubernetes-admin@kubernetes。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-context kubernetes-admin@kubernetes</span></span><br><span class="line">Switched to context &quot;kubernetes-admin@kubernetes&quot;.</span><br></pre></td></tr></table></figure>

<h2 id="基于角色的访问控制：RBAC"><a href="#基于角色的访问控制：RBAC" class="headerlink" title="基于角色的访问控制：RBAC"></a>基于角色的访问控制：RBAC</h2><p>DAC（自主访问控制）、MAC（强制访问控制）、RBAC（基于角色的访问控制）和ABAC（基于属性的访问控制）这4种主流的权限管理模型中，Kubernetes支持使用后两种完成普通账户和服务账户的权限管理，另外支持的权限管理模型还有Node和Webhook两种。<br>RBAC是一种新型、灵活且使用广泛的访问控制机制，它将权限授予角色，通过让“用户”扮演一到多个“角色”完成灵活的权限管理，这有别于传统访问控制机制中将权限直接赋予使用者的方式。相对于Kubernetes支持的ABAC和Webhook等授权机制，RBAC具有如下优势。</p>
<ul>
<li>对集群中的资源和非资源型URL的权限实现了完整覆盖。</li>
<li>整个RBAC完全由少数几个API对象实现，而且与其他API对象一样可以用kubectl或API调用进行操作。</li>
<li>支持权限的运行时调整，无须重新启动API Server。提示</li>
</ul>
<h3 id="RBAC授权模型"><a href="#RBAC授权模型" class="headerlink" title="RBAC授权模型"></a>RBAC授权模型</h3><p>RBAC是一种特定的权限管理模型，它把可以施加在“资源对象”上的“动作”称为“许可权限”，这些许可权限能够按需组合在一起构建出“角色”及其职能，并通过为“用户账户或组账户”分配一到多个角色完成权限委派。这些能够发出动作的用户在RBAC中也称为“主体”。图9-8展现了RBAC中用户、角色与权限之间的关系。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184626677.png" alt="image-20220218184626677">RBAC就是一种访问控制模型，它以角色为中心界定“谁”（subject）能够“操作”（verb）哪个或哪类“对象”（object）。动作的发出者即“主体”，通常以“账号”为载体，在Kubernetes系统上，它可以是普通账户，也可以是服务账户。“动作”用于表明要执行的具体操作，包括创建、删除、修改和查看等行为，对于API Server来说，即PUT、POST、DELETE和GET等请求方法。而“对象”则是指管理操作能够施加的目标实体，对Kubernetes API来说主要指各类资源对象以及非资源型URL。<br>API Server是RESTful风格的API，各类客户端由认证插件完成身份验证，而后通过HTTP协议的请求方法指定对目标对象的操作请求，并由授权插件进行授权检查，而操作的对象则是URL路径指定的REST资源。表9-3给出了HTTP方法和API Server资源操作的对应关系。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184647841.png" alt="image-20220218184647841">Kubernetes系统上的普通账户或服务账户向API Server发起资源操作请求，并以相应HTTP方法承载，如图9-9所示，由运行在API Server之上的授权插件RBAC进行鉴权。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184704051.png" alt="image-20220218184704051"><font color="red">Kubernetes系统的RBAC授权插件将角色分为Role和ClusterRole两类，它们都是Kubernetes内置支持的API资源类型，其中Role作用于名称空间级别，用于承载名称空间内的资源权限集合，而ClusterRole则能够同时承载名称空间和集群级别的资源权限集合。Role无法承载集群级别的资源类型的操作权限，这类的资源包括集群级别的资源（例如Nodes）、非资源类型的端点（例如/healthz），以及作用于所有名称空间的资源（例如跨名称空间获取任何资源的权限)等。</font><br>利用Role和ClusterRole两类角色进行赋权时，需要用到另外两种资源RoleBinding和ClusterRoleBinding，它们同样是由API Server内置支持的资源类型。RoleBinding用于将Role绑定到一个或一组用户之上，它隶属于且仅能作用于其所在的单个名称空间。RoleBinding可以引用同一名称中的Role，也可以引用集群级别的ClusterRole，但引用ClusterRole的许可权限会降级到仅能在RoleBinding所在的名称空间生效。而ClusterRoleBinding则用于将ClusterRole绑定到用户或组，它作用于集群全局，且仅能够引用ClusterRole。四者之间的关系如图9-10所示。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218184720792.png" alt="image-20220218184720792"></p>
<p>图9-10中，全局作用范围的User2因通过A名称空间中的RoleBinding关联至Role-A上，因而它仅能在NamespaceA名称空间中发挥作用。名称空间B中的ServiceAccount1通过RoleBinding关联至集群级别的ClusterRole-M上，对该账户来说，ClusterRole-M上的操作权限也仅限于该名称空间。全局级别的用户User1通过ClusterRoleBindig关联到ClusterRole-M，因而，该用户将在集群级别行使该角色的权限。<br>通常，我们可以把Kubernetes集群用户大体规划为集群管理员、名称空间管理员和用户（通常为开发人员）3类。</p>
<ul>
<li>集群管理员可以创建、读取、更新和删除任何策略对象，能够创建命名空间并将其分配给名称空间管理员；此角色适用于在整个集群中管理所有租户或项目的管理员。</li>
<li>名称空间管理员可以管理其名称空间中的用户，此角色适用于特定单一租户或项目的管理员。</li>
<li>开发者用户可以创建、读取、更新和删除名称空间内的非策略对象，如Pod、Job和Ingress等，但只在它们有权访问的名称空间中拥有这些权限。</li>
</ul>
<h3 id="Role与ClusterRole"><a href="#Role与ClusterRole" class="headerlink" title="Role与ClusterRole"></a>Role与ClusterRole</h3><p>Role和ClusterRole是API Server内置的两种资源类型，它们在本质上都只是一组许可权限的集合。Role和ClusterRole的资源规范完全相同，该规范没有使用spec字段，而是直接使用rules字段嵌套授权规则列表。规则的基本要素是动作（verb）和相关的目标资源，后者支持指定一个或多个资源类型、特定资源类型下的单个或多个具体的资源，以及非资源类型的URL等。在Role和ClusterRole资源上定义的rules也称为PolicyRule，即策略规则，它可以内嵌的字段有如下几个。</p>
<blockquote>
<p>1）apiGroups &lt;[]string&gt;：目标资源的API群组名称，支持列表格式指定多个组，空值（””）表示核心群组。<br>2）resources &lt;[]string&gt;：规则应用的目标资源类型，例如pods、services、deployments和daemonsets等，未同时使用resourceNames字段时，表示指定类型下的所有资源。ResourceAll表示所有资源。<br>3）resourceNames &lt;[]string&gt;：可选字段，指定操作适用的具体目标资源名称。<br>4）nonResourceURLs &lt;[]string&gt;：用于定义用户有权限访问的网址列表，它并非名称空间级别的资源，因此只能应用于ClusterRole，Role支持此字段仅是为了格式上的兼容；该字段在一条规则中与resources和resourceNames互斥。<br>5）verbs &lt;[]string&gt;：可应用在此规则匹配到的所有资源类型的操作列表，可用选项有get、list、create、update、patch、watch、proxy、redirect、delete和deletecollection；此为必选字段。</p>
</blockquote>
<p>下面的配置清单示例（pods-reader-rbac.yaml）在default名称空间中定义了一个名称为Role的资源，它设定了读取、列出及监视pods和services资源，以及pods/log子资源的许可权限。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pods-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]   <span class="comment"># &quot;&quot; 表示核心API群组</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>, <span class="string">&quot;services&quot;</span>, <span class="string">pods/log&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>绝大多数资源可通过其资源类型的名称引用，例如pods或services等，这些名称与它们在API endpoint中的形式相同。另外，有些资源类型支持子资源，例如Pod对象的/log，Node对象的/status等，它们在API Server上的URL形如下面的表示格式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/api/v1/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/log</span><br></pre></td></tr></table></figure>

<p>RBAC角色引用这种类型的子资源时需要使用resource/subresource的格式，例如上面示例规则中的pods/log。另外，还可以通过直接给定资源名称（resourceName）来引用特定的资源，但此时仅支持get、delete、update和patch等。<br>ClusterRole资源隶属于集群级别，它引用名称空间级别的资源意味着相关的操作权限能够在所有名称空间生效，同时，它也能够引用Role所不支持的集群级别的资源类型，例如nodes和persistentvolumes等。下面的清单示例（nodes-admin-rbac.yaml）定义了ClusterRole资源nodes-admin，它拥有管理集群节点信息的权限。ClusterRole不属于名称空间，所以其配置不能够使用metadata.namespace字段。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nodes-admin</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;*&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>将上面两个清单中分别定义的Role和ClusterRole资源创建到集群上，以便按需调用并验证其权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f pods-reader-rbac.yaml -f nodes-admin-rbac.yaml</span> </span><br><span class="line">role.rbac.authorization.k8s.io/pods-reader created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/nodes-admin created</span><br></pre></td></tr></table></figure>

<p>Role或ClusterRole资源的详细描述能够以比较直观的方式打印相关的规则定义，图9-11就是由kubectl describe roles/pods-reader clusterroles/nodes-admin命令输出的规则定义。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218190623307.png" alt="image-20220218190623307"></p>
<p>另外，kubectl命令也分别提供了创建Role和ClusterRole资源的命令式命令，create role和create clusterrole，它们支持如下几个关键选项。</p>
<ul>
<li>–verb：指定可施加于目标资源的动作，支持以逗号分隔的列表值，也支持重复使用该选项分别指定不同的动作，例如–verb=get,list,watch，或者–verb=get –verb=list –verb=watch。<br>+</li>
<li>–resource：指定目标资源类型，使用格式类似于–verb选项。</li>
<li>–resource-name：指定目标资源，使用格式类似于–verb选项。</li>
<li>–non-resource-url：指定非资源类型的URL，使用格式类似于–verb选项，但仅适用于clusterrole资源。</li>
</ul>
<p>例如，下面的第一条命令创建了dev名称空间，第二条命令在该名称空间创建了一个具有所有资源管理权限的roles/admin资源，第三条命令则创建了一个有PVC和PV资源管理权限的clusterroles/pv-admin资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create namespace dev</span> </span><br><span class="line">namespace/dev created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create role admin -n dev --resource=<span class="string">&quot;*.*&quot;</span> \</span></span><br><span class="line"><span class="language-bash">         --verb=<span class="string">&quot;get,list,watch,create,delete,deletecollection,patch,update&quot;</span></span></span><br><span class="line">role.rbac.authorization.k8s.io/admin created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create clusterrole pv-admin --verb=<span class="string">&quot;*&quot;</span> \</span></span><br><span class="line"><span class="language-bash">         --resource=<span class="string">&quot;persistentvolumeclaims,persistentvolumes&quot;</span></span></span><br><span class="line">clusterrole.rbac.authorization.k8s.io/pv-admin created</span><br></pre></td></tr></table></figure>

<p>但是，Role或ClusterRole对象本身并不能作为动作的执行主体，它们需要“绑定”到主体（例如User、Group或Service Account）之上完成赋权，而后由相应主体执行资源操作。</p>
<h3 id="RoleBinding与ClusterRoleBinding"><a href="#RoleBinding与ClusterRoleBinding" class="headerlink" title="RoleBinding与ClusterRoleBinding"></a>RoleBinding与ClusterRoleBinding</h3><p>RoleBinding负责在名称空间级别向普通账户、服务账户或组分配Role或ClusterRole，而ClusterRoleBinding则只能用于在集群级别分配ClusterRole。但二者的配置规范格式完全相同，它们没有spec字段，直接使用subjects和roleRef两个嵌套的字段。其中，subjects的值是一个对象列表，用于给出要绑定的主体，而roleRef的值是单个对象，用于指定要绑定的Role或ClusterRole资源。subjects字段的可嵌套字段如下。</p>
<ul>
<li>apiGroup &lt;string&gt;：要引用的主体所属的API群组，对于ServiceAccount类的主体来说默认为””，而User和Group类主体的默认值为”rbac.authorization.k8s.io”。</li>
<li>kind &lt;string&gt;：要引用的资源对象（主体）所属的类别，可用值为User、Group和ServiceAccount，必选字段。</li>
<li>name &lt;string&gt;：引用的主体的名称，必选字段。</li>
<li>namespace &lt;string&gt;：引用的主体所属的名称空间，对于非名称空间类型的主体，例如User和Group，其值必须为空，否则授权插件将返回错误信息。<br>roleRef的可嵌套字段如下。</li>
<li>apiGroup &lt;string&gt;：引用的资源（Role或ClusterRole）所属的API群组，必选字段。</li>
<li>kind &lt;string&gt;：引用的资源所属的类别，可用值为Role或ClusterRole，必选字段。</li>
<li>name &lt;string&gt;：引用的资源（Role或ClusterRole）的名称。</li>
</ul>
<p>需要注意的是，RoleBinding仅能够引用同一名称空间中的Role资源，例如下面配置清单中的RoleBindings在dev名称空间中把admin角色分配给用户mason，从而mason拥有了此角色之上的所有许可授权。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mason-admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mason</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<p>把示例中的RoleBinding资源mason-admin创建到集群上，便能够以该用户的身份测试其继承而来的权限是否已然生效。下面以–context选项临时将用户切换为mason@kubernetes进行资源管理，测试命令及结果显示，mason已然具有dev名称空间下的资源操作权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run demoapp --image=<span class="string">&quot;ikubernetes/demoapp:v1.0&quot;</span> -n dev --context=<span class="string">&quot;mason@kubernetes&quot;</span></span></span><br><span class="line">pod/demoapp created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get all -n dev --context=<span class="string">&quot;mason@kubernetes&quot;</span></span>  </span><br><span class="line">NAME         READY    STATUS    RESTARTS      AGE</span><br><span class="line">pod/demoapp   1/1     Running      0          52s</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete pods/demoapp -n dev --context=<span class="string">&quot;mason@kubernetes&quot;</span></span></span><br><span class="line">pod &quot;demoapp&quot; deleted</span><br></pre></td></tr></table></figure>

<p>RoleBinding也能够为主体分配集群角色，但它仅能赋予主体访问RoleBinding资源本身所在的名称空间之内的、由ClusterRole所持有的权限。例如，对于具有PVC和PV管理权限的clusterroles/pv-admin来说，在dev名称空间中使用RoleBinding将其分配给用户mason，意味着mason仅对dev名称空间下的PVC资源具有管理权限，它无法继承clusterroles/pv-admin除dev名称空间之外的其他名称空间中的PVC管理权限，更不能继承集群级别资源PV的任何权限。<br>一种高效分配权限的做法是，由集群管理员在集群范围预先定义好一组具有名称空间级别资源权限的ClusterRole资源，而后由RoleBinding分别在不同名称空间中引用它们，从而在多个名称空间向不同用户授予RoleBinding所有名称空间下的相同权限。<br>由此可见，Role和RoleBinding是名称空间级别的资源，它们仅能用于完成单个名称空间内的访问控制，需要赋予某主体多个名称空间中的访问权限时就不得不在各名称空间分别进行。若需要完成集群全局的资源管理授权，或者希望资源操作能够针对Nodes、Namespaces和PersistentVolumes等集群级别的资源进行，或者针对/api、/apis、/healthz或/version等非资源型URL路径进行，就需要使用ClusterRoleBinding。提示<br>nonResourceURLs资源仅支持get访问权限。<br>下面的配置清单示例（rolebinding-and-clusterrolebinding-rbac.yaml）中，rolebinding/mason-pvc-admin资源位于dev名称空间，它使用RoleBinding为用户mason分配了pv-admin这一集群角色，而clusterrolebinding/ik8s-pv-admin隶属集群级别，它使用ClusterRoleBinding为ik8s分配了pv-admin这一集群。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mason-pvc-admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mason</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ik8s-pv-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ik8s</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s</span></span><br></pre></td></tr></table></figure>

<p>将示例中的两个资源创建到集群之上，即可通过对比测试RoleBinding和ClusterRole-Binding为用户分配集群角色在功能上的不同之处。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f rolebinding-and-clusterrolebinding-rbac.yaml</span> </span><br><span class="line">rolebinding.rbac.authorization.k8s.io/mason-pvc-admin created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/ik8s-pv-admin created</span><br></pre></td></tr></table></figure>

<p>首先，我们使用mason用户进行测试，它仅能访问dev名称空间下的名称空间级别的PVC资源，且无法通过RoleBinding从clusterroles/pv-admin继承指定名称空间之外的任何权限，如下面的命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pvc -n dev --context=<span class="string">&quot;mason@kubernetes&quot;</span></span></span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pvc -n default --context=<span class="string">&quot;mason@kubernetes&quot;</span></span></span><br><span class="line">Error from server (Forbidden): persistentvolumeclaims is forbidden: User &quot;mason&quot; cannot list resource &quot;persistentvolumeclaims&quot; in API group &quot;&quot; in the namespace &quot;default&quot;</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pv --context=<span class="string">&quot;mason@kubernetes&quot;</span></span>         </span><br><span class="line">Error from server (Forbidden): persistentvolumes is forbidden: User &quot;mason&quot; cannot list resource &quot;persistentvolumes&quot; in API group &quot;&quot; at the cluster scope</span><br></pre></td></tr></table></figure>

<p>然后，我们使用ik8s用户进行测试，它通过ClusterRoleBinding从clusterroles/pv-admin继承了该集群角色的所有授权，如下面的命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pvc -n default --context=<span class="string">&quot;ik8s@kube-dev&quot;</span></span>   </span><br><span class="line">No resources found in default namespace.</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pvc -n dev --context=<span class="string">&quot;ik8s@kube-dev&quot;</span></span>    </span><br><span class="line">No resources found in dev namespace.</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pv --context=<span class="string">&quot;ik8s@kube-dev&quot;</span></span>        </span><br><span class="line">No resources found in default namespace.</span><br></pre></td></tr></table></figure>

<p>另外，kubectl也提供了分别创建RoleBinding和ClusterRoleBinding资源的命令式命令：create rolebinding和create clusterrolebinding，它们使用的选项基本相同，常用的选项如下。<br>▪–role=””：绑定的角色，仅RoleBinding支持。<br>▪–clusterrole=””：绑定的集群角色，RoleBinding和ClusterRoleBinding均支持。<br>▪–group=[]：绑定的组，支持逗号分隔的列表格式。<br>▪–user=[]：绑定的普通账户，支持逗号分隔的列表格式。<br>▪–serviceaccount=[]：绑定的服务账户，支持逗号分隔的列表格式。<br>例如，下面的命令为用户组kubeusers分配了集群角色nodes-admin，从而该组的所有用户均自动继承该角色上的所有许可权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create clusterrolebinding kubeusers-nodes-admin \</span></span><br><span class="line"><span class="language-bash">      --clusterrole=<span class="string">&#x27;nodes-admin&#x27;</span> --group=<span class="string">&#x27;kubeusers&#x27;</span></span></span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/kubeusers-nodes-admin created</span><br></pre></td></tr></table></figure>

<p>kubectl命令的rolesum和rbac-view等插件能辅助使用RBAC及相关的组件，感兴趣的读者可自行测试其用法。</p>
<h3 id="聚合型ClusterRole"><a href="#聚合型ClusterRole" class="headerlink" title="聚合型ClusterRole"></a>聚合型ClusterRole</h3><p>Kubernetes自1.9版本开始支持在ClusterRole的rules字段中嵌套aggregationRule字段来整合其他ClusterRole资源的规则，这种类型的ClusterRole对象的实际可用权限受控于控制器，具体许可授权由所有被标签选择器匹配到的ClusterRole的聚合授权规则合并生成。<br>下面的配置清单中首先定义了两个拥有标签的集群角色global-resources-view和global-resources-edit，而后在第三个集群角色资源global-resources-admin上使用聚合规则的标签选择器来匹配前两个资源的标签，因此，集群角色global-resources-admin的权限将由匹配到的其他ClusterRole资源的规则列表自动聚合而成。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">global-resources-view</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">rbac.ilinux.io/aggregate-to-global-admin:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>, <span class="string">&quot;namespaces&quot;</span>, <span class="string">&quot;persistentvolumes&quot;</span>, <span class="string">&quot;clusterroles&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">global-resources-edit</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">rbac.ilinux.io/aggregate-to-global-admin:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>, <span class="string">&quot;namespaces&quot;</span>, <span class="string">&quot;persistentvolumes&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;deletecollection&quot;</span>, <span class="string">&quot;patch&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">global-resources-admin</span></span><br><span class="line"><span class="attr">aggregationRule:</span></span><br><span class="line">  <span class="attr">clusterRoleSelectors:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">rbac.ilinux.io/aggregate-to-global-admin:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">rules:</span> []  <span class="comment"># 该规则列表为空，它将由控制器自动聚合生成</span></span><br></pre></td></tr></table></figure>

<p>任何能够被示例中clusterrole/globa-resources-admin资源的标签选择器匹配到的Cluster-Role资源的相关规则将一同合并为它的授权规则，并且相关作用域内的任何ClusterRole资源的变动都将实时反馈到聚合资源之上。因而，聚合型ClusterRole的规则会随着标签选择器的匹配结果动态变化。<br>事实上，Kubernetes系统上面向用户的内置ClusterRole admin和edit也是聚合型的ClusterRole对象，因为这可以使得默认角色中包含自定义资源的相关规则，例如由CustomResourceDefinitions或Aggregated API服务器提供的规则等。</p>
<h3 id="面向用户的内置ClusterRole"><a href="#面向用户的内置ClusterRole" class="headerlink" title="面向用户的内置ClusterRole"></a>面向用户的内置ClusterRole</h3><p>API Server内置了一组默认的ClusterRole和ClusterRoleBinding资源预留给系统使用，其中大多数都以system:为前缀。另外有一些不以system:为前缀的默认的ClusterRole资源是为面向用户的需求而设计，包括集群管理员角色cluster-admin，以及专用于授予特定名称空间级别权限的集群角色admin、edit和view，如图9-12所示。掌握这些默认的内置ClusterRole资源有助于按需创建用户并分配相应权限。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191548207.png" alt="image-20220218191548207">内置的clusterroles/cluster-admin资源拥有管理集群所有资源的权限，而内置的clusterrolebindings/cluster-admn将该角色分配给了system:masters用户组，这意味着所有隶属于该组的用户都将自动具有集群的超级管理权限。kubeadm安装设置集群时，自动创建的配置文件/etc/kubernetes/admin.conf中定义的用户kubernetes-admin使用证书文件/etc/kubernetes/pki/apiserver-kubelet-client.crt向API Server进行验证。而该数字证书的Subject属性值为/O=system:masters，API Server会在成功验证该用户的身份之后将其识别为system: master用户组的成员。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver-kubelet-client.crt  -noout -subject</span>     </span><br><span class="line">subject=O = system:masters, CN = kube-apiserver-kubelet-client</span><br></pre></td></tr></table></figure>

<p>于是，为Kubernetes集群自定义超级管理员的方法至少有两种：一是将用户归入system:masters组，二是通过ClusterRoleBinding直接将用户绑定至内置的集群角色cluster-admin上。具体实现方法可参照9.5.4节和本节中的内容略加变通实现。<br>另外，在多租户、多项目或多环境等使用场景中，用户通常应该获得名称空间级别绝大多数资源的管理（admin）、只读（view）或编辑（edit)权限，可通过在指定的名称空间中创建RoleBinding资源引用内置的ClusterRole资源进行这类权限的快速授予。例如，在名称空间dev中创建一个RoleBinding资源，为ik8s用户分配集群角色admin，将使得该用户具有管理dev名称空间中除了名称空间本身及资源配额之外的所有资源的权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create rolebinding ik8s-admin --clusterrole=admin --user=ik8s -n dev</span>           </span><br><span class="line">rolebinding.rbac.authorization.k8s.io/ik8s-admin created</span><br></pre></td></tr></table></figure>

<p>若仅需要授予编辑或只读权限，在创建RoleBinding时引用ClusterRole的edit或view便能实现。表9-4总结了典型的面向用户的内置ClusterRole及其功用。<br>表9-4　面向用户的内置ClusterRole资源<br>另外，API Server默认创建的以system:为前缀的大多数ClusterRole和ClusterRoleBinding专为Kubernetes系统的基础架构而设计，修改这些资源可能会导致集群功能不正常。例如，若修改了为kubelet赋权的system:node将会导致kubelet无法正常工作。所有默认的ClusterRole和ClusterRoleBinding都打上了kubernetes.io/bootstrapping=rbac-defaults标签。<br>每次启动时，API Server都会自动为所有默认的ClusterRole重新赋予缺失的权限，同时为默认的ClusterRoleBinding绑定缺失的主体。这种机制给了集群从意外修改中自动恢复的能力，以及升级版本后自动将ClusterRole和ClusterRoleBinding升级到满足新版本需求的能力。提示<br>必要时，在默认的ClusterRole或ClusterRoleBinding上设置annnotation中的rbac.authorization.kubernetes.io/autoupdate属性的值为false，即可禁止这种自动恢复功能。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191725068.png" alt="image-20220218191725068"></p>
<p>另外，启用RBAC后，Kubernetes系统的各核心组件、附加组件，以及由controller-manager运行的核心控制器等，几乎都要依赖于合理的授权才能正常运行。因而，RBAC权限模型为这些组件内置了可获得最小化的资源访问授权的ClusterRole和ClusterRoleBinding，例如system:kube-sheduler、system:kube-controller-manager、system:node、system:node-proxier和system:kube-dns等，其中大多数组件都可以做到见名知义，这里不再逐一给出说明。</p>
<h2 id="认证与权限应用案例：Dashboard"><a href="#认证与权限应用案例：Dashboard" class="headerlink" title="认证与权限应用案例：Dashboard"></a>认证与权限应用案例：Dashboard</h2><p>Kubernetes Dashboard项目为Kubernetes集群提供了一个基于Web的通用UI，支持集群管理、应用管理及应用排障等功能，截至本书编写时最新的版本为2.x系列。Dashboard项目包含前端和后端两个组件，如图9-13所示。前端运行于客户端浏览器中，由TypeScript编写，它使用标准的HTTP方法将请求发送到后端并从后端获取业务数据；后端是使用Go语言编写的HTTP服务器，它负责接收前端的请求、将数据请求发送到适配的远程后端（例如Kubernetes API Server等）或实现业务逻辑等。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191931776.png" alt="image-20220218191931776">Dashboard依赖Metrics Server完成指标数据的采集和可视化，因而在部署该组件之前，Dashboard的部分功能将处于不可用状态。<br>Dashboard 1.7（不含）之前的版本在部署时直接赋予管理权限，这种方式可能存在安全风险，因此1.7及之后的版本默认在部署时仅定义运行Dashboard所需要的最小权限，并且只有在Master主机上通过kubectl proxy命令创建代理后，才能在本机进行访问。</p>
<h3 id="部署Dashboard"><a href="#部署Dashboard" class="headerlink" title="部署Dashboard"></a>部署Dashboard</h3><p>出于安全因素的考虑，Dashboard在其项目仓库中推荐的默认部署清单（recommended.yaml）中仅定义了运行自身所需要的最小权限，并且强制要求远程访问必须要基于HTTPS通信，否则应该通过kubectl proxy以代理方式进行。因而，若需要绕过kubectl proxy代理直接访问Dashboard，必须要为其HTTP服务进程提供用于建立HTTPS连接的服务器端证书。<br>推荐的部署清单默认便会在内存中生成自签证书，并以之生成名为kubernetes-dashboard-certs的Secret对象，Dashboard Pod将从该Secret中加载证书（tls.crt）和私钥（tls.key)。若需要使用自定义的证书，则应该在执行如下部署命令之前先把准备好的证书与私钥文件分别以tls.crt和tls.key为键名，创建成kubernetes-dashboard名称空间下名为kubernetes-dashboard-certs的Secret对象，需要用到时，在Dashboard部署之前参考Secret对象的管理方式完成创建即可。下面的命令未自定义Secret，它直接使用Dashboard项目master分支中的配置清单完成应用部署：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended.yaml</span></span><br></pre></td></tr></table></figure>

<p>部署完成的Dashboard支持多种不同的访问方式，例如kubectl proxy、kubectl port-forward、节点端口、Ingress或API Server等，这里重点介绍节点端口。默认创建的Service对象（kubernetes-dashboard）类型为ClusterIP，它仅能在Pod客户端中访问，若需要在集群外使用浏览器访问Dashboard，可将该Service对象类型修改为NodePort后，通过节点端口进行访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl patch svc kubernetes-dashboard -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;type&quot;:&quot;NodePort&quot;&#125;&#125;&#x27;</span> -n kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>

<p>未显式指定的NodePort属性值将会由Service控制器随机分配，下面获取该端口号以便在集群外通过浏览器访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get services/kubernetes-dashboard -n kubernetes-dashboard \</span></span><br><span class="line"><span class="language-bash">      -o jsonpath=<span class="string">&#x27;&#123;.spec.ports[0].nodePort&#125;&#x27;</span></span></span><br><span class="line">30272</span><br></pre></td></tr></table></figure>

<p>图9-14显示了Dashboard的默认登录页面，它支持直接通过目标Service Account的令牌加载身份凭据，或者以该令牌为身份凭据生成专用的kubeconfig文件，并通过指定的文件路径向Dashboard提交认证信息。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218191947673.png" alt="image-20220218191947673">Dashboard的资源访问权限继承自登录时的Service Account用户，我们可以向相关的Service Account分配特定的角色或集群角色完成Dashboard用户权限模型的构建。</p>
<p>例如，为登录的用户授权集群级别管理权限时，可直接使用ClusterRoleBinding为Service Account分配内置的集群角色cluster-admin，而授权名称空间级别的管理权限时，可在目标名称空间上向Service Account分配内置的集群角色admin。当然，也可以直接自定义RBAC的角色或集群角色，以完成特殊需求的权限委派。</p>
<h3 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h3><p>Kubernetes Dashboard自身并不进行任何形式的身份验证和鉴权，它仅是把用户提交的身份凭据转发至后端的API Server完成验证，资源操作请求及权限检查同样会提交至后端的API Server进行。从某种意义上讲，Dashboard更像是用户访问Kubernetes的代理程序，发送给API Server的身份认证及资源操作请求都是由Dashboard应用程序完成，因而用户提交的身份凭据需要关联至某个Service Account。<br>集群全局的资源管理操作依赖于集群管理员权限，因而需要为专用于访问Dashboard的Service Account分配内置的cluster-admin集群角色。随后，将相应Service Account的令牌信息提交给Dashboard并认证到API Server，便可使得Dashboard继承了该账户的所有管理权限。例如，下面在kubernetes-dashboard名称空间创建一个名为dashboard-admin的Service Account完成该目标。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create serviceaccount admin-user -n kubernetes-dashboard</span></span><br><span class="line">serviceaccount/admin-user created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create clusterrolebinding admin-user --clusterrole=cluster-admin \</span></span><br><span class="line"><span class="language-bash">      --serviceaccount=kubernetes-dashboard:admin-user</span></span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/admin-user created</span><br></pre></td></tr></table></figure>

<p>随后，获取到服务账户kubernetes-dashboard:admin-user关联的Secret对象中的令牌信息，提交给Dashboard即可完成认证。下面第一个命令检索到该服务账户的Secret对象名称并保存到变量中，第二个命令则从该Secret中获取经过Base64编码后的令牌信息，并打印出解码后的令牌信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">ADMIN_SECRET=$(kubectl -n kubernetes-dashboard get secret | awk <span class="string">&#x27;/^admin-user/&#123;print $1&#125;&#x27;</span>)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">ADMIN_TOKEN=$(kubectl get secrets <span class="variable">$ADMIN_SECRET</span> -n kubernetes-dashboard \</span></span><br><span class="line"><span class="language-bash">       -o jsonpath=<span class="string">&#x27;&#123;.data.token&#125;&#x27;</span> | base64 -d)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$ADMIN_TOKEN</span></span></span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IlRWYXZxTGE5UE9SY0JZUHV0NUdRN1hIeXBMa……</span><br></pre></td></tr></table></figure>

<p>将上面打印出的令牌信息复制到Dashboard的登录界面便可完成认证，随后Dashboard便会打开类似图9-15所示的主面板页面。</p>
<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218192221358.png" alt="image-20220218192221358"></p>
<p>显然，每次访问Dashboard之前都要先通过如上命令获取相应的令牌是件相当烦琐的事情，更简便的办法是依该身份凭据创建出一个专用的kubeconfig文件并存储到客户端，随后登录时在浏览器中通过本地路径加载该kubeconfig文件即可完成认证，更加安全和便捷。<br>创建kubeconfig文件的方法在9.4节中已经有过详细介绍，下面仅给出相关步骤，实现为服务账户kubernetes-dashboard:admin-user创建相关的配置文件。<br>1）添加集群配置，包括集群名称、API Server URL和信任的CA的证书；clusters配置段中的各列表项名称需要唯一。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-cluster kubernetes --embed-certs=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">    --certificate-authority=/etc/kubernetes/pki/ca.crt \</span></span><br><span class="line"><span class="language-bash">    --server=<span class="string">&quot;https://k8s-api.ilinux.io:6443&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/admin-user.config</span></span><br></pre></td></tr></table></figure>

<p>2）添加身份凭据，可使用静态密码文件认证的客户端提供用户名和密码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-credentials admin-user --token=<span class="variable">$ADMIN_TOKEN</span> \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/admin-user.config</span></span><br></pre></td></tr></table></figure>

<p>3）以用户admin-user的身份凭据与Kubernetes集群建立映射关系。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config set-context admin-user@kubernetes --cluster=kubernetes \</span></span><br><span class="line"><span class="language-bash">    --user=admin-user --kubeconfig=<span class="variable">$HOME</span>/.kube/admin-user.config</span></span><br></pre></td></tr></table></figure>

<p>4）设置当前上下文为admin-user@kubernetes。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl config use-context admin-user@kubernetes \</span></span><br><span class="line"><span class="language-bash">    --kubeconfig=<span class="variable">$HOME</span>/.kube/admin-user.config</span></span><br></pre></td></tr></table></figure>

<p>至此为止，一个用于Dashboard登录认证的、拥有管理员权限的kubeconfig配置文件设置完成，把文件复制到远程客户端上即可用于Dashboard kubeconfig类型的登录认证。<br>另外，若需要设定的用户仅具有某个名称空间的管理权限，或者仅拥有集群或名称空间级别的资源读取权限，都能够通过RBAC权限管理模型来实现。这类用户的设定过程与前述步骤中的关键不同之处仅在于角色分配步骤。例如，在名称空间kubernetes-dashboard中创建服务账户monitor-user，并通过ClusterRoleBinding为其分配默认的集群角色view，便可创建一个仅具有全局读取权限的Dashboard用户，所需步骤如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create serviceaccount monitor -n kubernetes-dashboard</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create clusterrolebinding monitor --clusterrole=view \</span></span><br><span class="line"><span class="language-bash">      --serviceaccount=kubernetes-dashboard:monitor</span></span><br></pre></td></tr></table></figure>

<p>或者在名称空间dev中创建一个服务账户dev-ns-admin，并通过RoleBinding为其分配默认的集群角色admin，就能创建一个仅具有dev名称空间管理权限的Dashboard用户，所需要的步骤如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create serviceaccount ns-admin -n dev</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create rolebinding ns-admin --clusterrole=admin --serviceaccount=dev:ns-admin</span></span><br></pre></td></tr></table></figure>

<p>无论分配了何种集群角色或拥有ServiceAccount账户的特定角色，它们的认证信息提取及使用kubeconfig配置文件的方式都是相同的，这里不再给出具体的步骤，感兴的读者可自行测试。另外，Dashboard能大大简化kubectl命令行里的各种操作，但二者的核心功能相似之处甚多，读者朋友们根据界面提示信息很快就能掌握其使用方法。</p>
<h2 id="准入控制器"><a href="#准入控制器" class="headerlink" title="准入控制器"></a>准入控制器</h2><p>API Server中的准入控制器同样以插件形式存在，它们会拦截所有已完成认证的，且与资源创建、更新和删除操作相关的请求，以强制实现控制器中定义的功能，包括执行对象的语义验证和设置缺失字段的默认值等，具体功能取决于API Server启用的插件。目前，Kubernetes内置了30多个准入控制器。</p>
<h3 id="准入控制器概述"><a href="#准入控制器概述" class="headerlink" title="准入控制器概述"></a>准入控制器概述</h3><p>Kubernetes自1.7版本引入了Initializers和External Admission Webhooks来尝试突破此限制，而且自1.9版本起，External Admission Webhooks又被分为MutatingAdmissionWebhook和ValidatingAdmissionWebhook两种类型，分别用于在API中执行对象配置的“变异”和“验证”操作，前一种类型的控制器会“改动”和“验证”资源规范，而后一种类型仅“验证”资源规范是否合规。<br>在具体的代码实现上，一个准入控制器可以是验证型、变异型或兼具此两项功能。例如，LimitRanger准入控制器可以使用默认资源请求和限制（变异阶段）来扩展Pod，也能够校验有着显式资源需求定义的Pod是否超出LimitRange对象（验证阶段）的定义。而在具体运行时，准入控制也会根据准入控制器类型分阶段运行，第一个阶段串行运行各变异型控制器，第二阶段则串行运行各验证型控制器，如图9-16所示。在此过程中，任何控制器拒绝请求都将导致整个请求被即刻拒绝，并将错误信息返回给客户端。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220221114926133.png" alt="image-20220221114926133"></p>
<p>Kubernetes集群内置功能的某些方面实际上就是由准入控制器控制的，例如，删除名称空间并进入Terminating状态时，NamespaceLifecycle准入控制器将会阻止在该名称空间中创建任何新的资源对象。甚至于，必须启用准入控制器才能使用Kubernetes集群的某些更高级的安全功能，例如在整个命名空间上强制实施安全配置基线的Pod安全策略等。<br>API Server默认便会启用部分准入控制器，它也支持通过–enable-admission-plugins选项显式指定要加载的准入控制器，使用–disable-admission-plugins选项显式指定要禁用的准入控制器。提示<br>Kubernetes内置支持的所有准入控制器及其功能说明请参考官方文档中的说明，具体地址为<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/%E3%80%82">https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/。</a><br>Kubernetes正是依赖LimitRange资源和相应的LimitRanger准入控制器、ResourceQuota资源和同名的准入控制器，以及PodSecurityPolicy资源和同名的准入控制器为多租户或多项目的集群环境提供了基础的安全策略框架。</p>
<h3 id="LimitRange"><a href="#LimitRange" class="headerlink" title="LimitRange"></a>LimitRange</h3><p>LimitRange支持在Pod级别与容器级别分别设置CPU和内存两种计算资源的可用范围，它们对应的资源范围限制类型分别为Pod和Container。一旦在名称空间上启用LimitRange，该名称空间中的Pod或容器的requests和limits的各项属性值必须在对应的可用资源范围内，否则将会被拒绝，这是验证型准入控制器的功能。以Pod级别的CPU资源为例，若某个LimitRange资源为其设定了[0.5,4]的区间，则相应名称空间下任何Pod资源的requests.cpu的属性值必须要大于等于500m，同时，limits.cpu的属性值也必须要小于等于4。而未显式指定request和limit属性的容器，将会从LimitRange资源上分别自动继承相应的默认设置，这是变异型准入控制器的功能，如图9-17所示。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220221121230803.png" alt="image-20220221121230803">另外，LimitRange也支持在PersistentVolumeClaim资源级别设定存储空间的范围限制，它用于限制相应名称空间中创建的PVC对象请求使用的存储空间不能逾越指定的范围。未指定requests和limits属性的PVC规范，将在创建时自动继承LimitRange上配置的默认值。<br>下面的资源清单（limitrange-demo.yaml)分别为dev名称空间中的Pod、Container和PersistentVolumeClaim资源定义了各自的资源范围，并为后两者指定了相应可用资源规范的limits和requests属性上的默认值。其中用到的各配置属性中，default用于定义limits的默认值，defaultRequest定义requests的默认值，min定义最小资源用量，而最大资源用量可以使用max给出固定值，也可以使用maxLimitRequestRatio设定最小用量的指定倍数，同时定义二者时，其意义要相符。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">resource-limits</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">max:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span> </span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;4Gi&quot;</span> </span><br><span class="line">      <span class="attr">min:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span> </span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;16Mi&quot;</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Container</span></span><br><span class="line">      <span class="attr">max:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span> </span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span> </span><br><span class="line">      <span class="attr">min:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;100m&quot;</span> </span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;4Mi&quot;</span> </span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> </span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span> </span><br><span class="line">      <span class="attr">defaultRequest:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span> </span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span> </span><br><span class="line">      <span class="attr">maxLimitRequestRatio:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">      <span class="attr">max:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">      <span class="attr">min:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">&quot;5Gi&quot;</span></span><br><span class="line">      <span class="attr">defaultRequest:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">      <span class="attr">maxLimitRequestRatio:</span></span><br><span class="line">        <span class="attr">storage:</span> <span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<p><font color="red">LimitRange仅在Container资源类型上可为CPU与内存设置default（limits属性的默认值）和defaultrequest（requests属性的默认值），Pod资源类型不支持。</font><br>LimitRange资源的详细描述会以非常直观、清晰的方式输出相关的资源限制及默认值的定义，将如上配置清单中的LimitRange资源resource-limits创建到集群上，而后便可使用describe命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f limitrange-demo.yaml</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe limitranges/resource-limits -m dev</span></span><br></pre></td></tr></table></figure>

<p>输出结果类似图9-18。<br><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218192802902.png" alt="image-20220218192802902">我们可以通过在dev名称空间中创建Pod对象与PVC对象对各限制的边界和默认值的效果进行多维度测试。先创建一个仅包含一个容器且没有默认系统资源需求和限制的Pod对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run testpod-1 --image=<span class="string">&quot;ikubernetes/demoapp:v1.0&quot;</span> -n dev</span></span><br></pre></td></tr></table></figure>

<p>Pod对象testpod-1资源规范中被自动添加了CPU和内存资源的requests和limits属性，它的值来自limitranges/resource-limits中的定义，如下面的命令及截取的结果片段所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pod/testpod-1 -n dev -o yaml</span></span><br><span class="line">……</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: ikubernetes/demoapp:v1.0</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: testpod-1</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        cpu: &quot;2&quot;</span><br><span class="line">        memory: 512Mi</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 500m</span><br><span class="line">        memory: 64Mi</span><br><span class="line">  ……</span><br></pre></td></tr></table></figure>

<p>若Pod对象设定的CPU或内存的requests属性值小于LimitRange中相应资源的下限，或limits属性值大于设定的相应资源的上限，就会触发LimitRanger准入控制器拒绝相关的请求。例如下面创建Pod的命令中，仅requests.memory一个属性值违反了limitrange/resource-limits中的定义，但请求同样会被拒绝。</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run testpod-2 --image=<span class="string">&quot;ikubernetes/demoapp:v1.0&quot;</span> -n dev \</span></span><br><span class="line"><span class="language-bash">      --limits=<span class="string">&#x27;cpu=2,memory=1Gi&#x27;</span> --requests=<span class="string">&#x27;cpu=1,memory=8Mi&#x27;</span></span> </span><br><span class="line">Error from server (Forbidden): pods &quot;testpod-2&quot; is forbidden: minimum memory usage per Pod is 16Mi, but request is 8388608</span><br></pre></td></tr></table></figure>

<p>类似地，在dev名称空间中创建的PVC对象的可用存储空间也将受到LimitRange资源中定义的限制，鉴于篇幅有限，这里不再给出具体的过程，感兴趣的读者朋友可自行完成测试。<br>需要注意的是，LimitRange生效于名称空间级别，它需要定义在每个名称空间之上；另外，定义的限制仅对该资源创建后的Pod和PVC资源创建请求有效，对之前已然存在的资源无效；再者，不建议在生效于同一名称空间的多个LimitRange资源上，对同一个计算资源限制进行分别定义，以免产生歧义或导致冲突。</p>
<h3 id="ResourceQuota"><a href="#ResourceQuota" class="headerlink" title="ResourceQuota"></a>ResourceQuota</h3><p>。ResourceQuota资源能够定义名称空间级别的资源配额，从而在名称空间上限制聚合资源消耗的边界，它支持以资源类型来限制用户可在本地名称空间中创建的相关资源的对象数量，以及这些对象可消耗的计算资源总量等。</p>
<p>  而同名的ResourceQuota准入控制器负责观察传入的请求，并确保它没有违反相应名称空间中ResourceQuota资源定义的任何约束。ResourceQuota准入控制器属于“验证”类型的控制器，用户创建或更新资源的操作违反配额约束时将会被拒绝，API Server会响应以HTTP状态代码403 FORBIDDEN，并显示一条消息以提示违反的约束条件。<br><font color="red">    ResourceQuota资源可限制名称空间中处于非终止状态的所有Pod对象的计算资源需求及计算资源限制总量。 </font></p>
<ul>
<li>cpu或requests.cpu：CPU资源相关请求的总量限额。</li>
<li>memory或requests.cpu：内存资源相关请求的总量限额。</li>
<li>limits.cpu：CPU资源相关限制的总量限额。</li>
<li>limits.memory：内存资源相关限制的总量限额。</li>
</ul>
<p>ResourceQuota资源还支持为本地名称空间中的PVC存储资源的需求总量和限制总量设置限额，它能够分别从名称空间中的全部PVC、隶属于特定存储类的PVC以及基于本地临时存储的PVC分别进行定义。</p>
<ul>
<li><p>requests.storage：所有PVC存储需求的总量限额。</p>
</li>
<li><p>persistentvolumeclaims：可以创建的PVC总数限额。</p>
</li>
<li><p>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/requests.storage：特定存储类上可使用的所有PVC存储需求的总量限额。</p>
</li>
<li><p>&lt;storage-class-name&gt;.storageclass.storage.k8s.io/persistentvolumeclaims：特定存储类上可使用的PVC总数限额。</p>
</li>
<li><p>requests.ephemeral-storage：所有Pod可以使用的本地临时存储资源的requets总量。</p>
</li>
<li><p>limits.ephemeral-storage：所有Pod可用的本地临时存储资源的limits总量。</p>
</li>
</ul>
<p>自v1.9版本起开始支持以count/&lt;resource&gt;.&lt;group&gt;的格式对所有资源类型对象的计数配额，例如count/deployments.apps、count/deployments.extensions和count/services等。<br>下面的资源清单（resourcequota-demo.yaml）在dev名称空间中定义了一个ResourceQuota资源对象，它定义了计算资源与存储资源分别在requests和limits维度的限额，也定义了部署资源类型中的可用对象数量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ResourceQuota</span><br><span class="line">metadata:</span><br><span class="line">  name: resourcequota-demo</span><br><span class="line">  namespace: dev</span><br><span class="line">spec:</span><br><span class="line">  hard:</span><br><span class="line">    pods: &quot;5&quot;</span><br><span class="line">    count/services: &quot;5&quot;</span><br><span class="line">    count/configmaps: &quot;5&quot;</span><br><span class="line">    count/secrets: &quot;5&quot;</span><br><span class="line">    count/cronjobs.batch: &quot;2&quot;</span><br><span class="line">    requests.cpu: &quot;2&quot;</span><br><span class="line">    requests.memory: &quot;4Gi&quot;</span><br><span class="line">    limits.cpu: &quot;4&quot;</span><br><span class="line">    limits.memory: &quot;8Gi&quot;</span><br><span class="line">    count/deployments.apps: &quot;2&quot;</span><br><span class="line">    count/statefulsets.apps: &quot;2&quot;</span><br><span class="line">    persistentvolumeclaims: &quot;6&quot;</span><br><span class="line">    requests.storage: &quot;20Gi&quot;</span><br><span class="line">    fast-rbd.storageclass.storage.k8s.io/requests.storage: &quot;20Gi&quot;</span><br><span class="line">    fast-rbd.storageclass.storage.k8s.io/persistentvolumeclaims: &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p>与LimitRange不同的是，ResourceQuota会计入指定范围内，先前的资源对象对系统资源和资源对象的限额占用情况，因此将resourceqouta-demo创建到集群上之后，dev名称空间中现有的资源会立即分去限额内的一部分可用空间，这在ResourceQuota资源的详细描述中会有直观展示，如图9-19所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f resourcequota-demo.yaml</span>             </span><br><span class="line">resourcequota/resourcequota-demo created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe resourcequotas/resourcequota-demo -n dev</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/2022/02/21/%E8%AE%A4%E8%AF%81%E3%80%81%E6%8E%88%E6%9D%83%E4%B8%8E%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6/image-20220218193332606.png" alt="image-20220218193332606"></p>
<p>上面第二条命令结果显示，dev名称空间下的Pod资源限额已被先前的自主式Pod对象消耗了1/5，与此同时，计算资源请求和限制也各占用了一部分配额。随后，在dev名称空间中创建Pod资源时，requests.cpu、requests.memroy、limits.cpu、limits.memory和pods等任何一个限额的超出都将致使创建操作失败，如下面的命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run testpod-2 --image=<span class="string">&quot;ikubernetes/demoapp:v1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      --requests=<span class="string">&quot;cpu=2,memory=1Gi&quot;</span> --limits=<span class="string">&quot;cpu=2,memory=1Gi&quot;</span> -n dev</span> </span><br><span class="line">Error from server (Forbidden): pods &quot;testpod-2&quot; is forbidden: exceeded quota: resourcequota-demo, requested: requests.cpu=2, used: requests.cpu=500m, limited: requests.cpu=2</span><br></pre></td></tr></table></figure>

<p>每个ResourceQuota资源对象上还支持定义一组作用域，用于定义资源上的配额仅生效于这组作用域交集范围内的对象，目前适用范围包括Terminating、NotTerminating、BestEffort和NotBestEffort。</p>
<ul>
<li><p>Terminating：匹配.spec.activeDeadlineSeconds的属性值大于等于0的所有Pod对象。</p>
</li>
<li><p>NotTerminating：匹配.spec.activeDeadlineSeconds的属性值为空的所有Pod对象。</p>
</li>
<li><p>BestEffort：匹配所有位于BestEffort QoS类别的Pod对象。</p>
</li>
<li><p>NotBestEffort：匹配所有非BestEffort QoS类别的Pod对象。</p>
</li>
</ul>
<p>另外，Kubernetes自v1.8版本起支持管理员设置不同的优先级类别（PriorityClass）创建Pod对象，而且自v1.11版本起还支持对每个PriorityClass对象分别设定资源限额。于是，管理员还可以在ResourceQuota资源上使用scopeSelector字段定义其生效的作用域，它支持基于Pod对象的优先级来控制Pod对系统资源的消耗。</p>
<h3 id="PodSecurityPolicy"><a href="#PodSecurityPolicy" class="headerlink" title="PodSecurityPolicy"></a>PodSecurityPolicy</h3><p>PSP资源就是集群全局范围内定义的Pod资源可用的安全上下文策略。同名的PodSecurityPolicy准入控制器负责观察集群范围内的Pod资源的运行属性，并确保它没有违反PodSecurityPolicy资源定义的约束条件。<br>PSP准入控制器会根据显式定义的PSP资源中的安全策略判定允许何种Pod资源的创建操作，若无任何可用的安全策略，它将阻止创建任何Pod资源。Kubernetes集群默认并不会自动生成任何PSP资源，因而该准入控制器默认处于禁用状态。PSP资源的API接口（policy/v1beta1/podsecuritypolicy）独立于PSP准入控制器，因此管理员可以先定义好必要的Pod安全策略，再设置kube-apiserver启用PSP准入控制器。不当的Pod安全策略可能会产生难以预料的副作用，因此请确保添加的任何PSP对象都经过了充分测试。<br>PodSecurityPolicy是标准的API资源类型，它隶属于policy群组，在spec字段中嵌套多种安全规则来定义期望的目标，资源规范及简要的使用说明如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span>   <span class="comment"># PSP资源所属的API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span>   <span class="comment"># 资源类型标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 资源名称</span></span><br><span class="line"><span class="attr">spec:</span>  </span><br><span class="line">  <span class="string">allowPrivilegeEscalation</span>  <span class="string">&lt;boolean&gt;</span> <span class="comment"># 是否允许权限升级</span></span><br><span class="line">  <span class="string">allowedCSIDrivers</span> <span class="string">&lt;[]Object&gt;</span>        <span class="comment">#内联CSI驱动程序列表，必须在Pod规范中显式定义</span></span><br><span class="line">  <span class="string">allowedCapabilities</span> <span class="string">&lt;[]string&gt;</span>      <span class="comment"># 允许使用的内核能力列表，“*”表示all</span></span><br><span class="line">  <span class="string">allowedFlexVolumes</span> <span class="string">&lt;[]Object&gt;</span>       <span class="comment"># 允许使用的Flexvolume列表，空值表示all</span></span><br><span class="line">  <span class="string">allowedHostPaths</span> <span class="string">&lt;[]Object&gt;</span>         <span class="comment"># 允许使用的主机路径列表，空值表示all</span></span><br><span class="line">  <span class="string">allowedProcMountTypes</span> <span class="string">&lt;[]string&gt;</span>    <span class="comment"># 允许使用的ProcMountType列表，空值表示默认</span></span><br><span class="line">  <span class="string">allowedUnsafeSysctls</span> <span class="string">&lt;[]string&gt;</span>     <span class="comment"># 允许使用的非安全sysctl参数，空值表示不允许</span></span><br><span class="line">  <span class="string">defaultAddCapabilities</span>  <span class="string">&lt;[]string&gt;</span>  <span class="comment"># 默认添加到Pod对象的内核能力，可被drop</span></span><br><span class="line">  <span class="string">defaultAllowPrivilegeEscalation</span> <span class="string">&lt;boolean&gt;</span> <span class="comment"># 是否默认允许内核权限升级</span></span><br><span class="line">  <span class="string">forbiddenSysctls</span>  <span class="string">&lt;[]string&gt;</span>        <span class="comment"># 禁止使用的sysctl参数，空表示不禁用</span></span><br><span class="line">  <span class="string">fsGroup</span> <span class="string">&lt;Object&gt;</span>    <span class="comment"># 允许在SecurityContext中使用的fsgroup，必选字段</span></span><br><span class="line">    <span class="string">rule</span> <span class="string">&lt;string&gt;</span>     <span class="comment"># 允许使用的FSGroup规则，支持RunAsAny和MustRunAs</span></span><br><span class="line">    <span class="string">ranges</span> <span class="string">&lt;[]Object&gt;</span> <span class="comment"># 允许使用的组ID范围，需要与MustRunAs规则一同使用</span></span><br><span class="line">      <span class="string">max</span>  <span class="string">&lt;integer&gt;</span>                  <span class="comment"># 最大组ID号</span></span><br><span class="line">      <span class="string">min</span>  <span class="string">&lt;integer&gt;</span>                  <span class="comment"># 最小组ID号</span></span><br><span class="line">  <span class="string">hostIPC</span> <span class="string">&lt;boolean&gt;</span>                   <span class="comment"># 是否允许Pod使用hostIPC</span></span><br><span class="line">  <span class="string">hostNetwork</span> <span class="string">&lt;boolean&gt;</span>               <span class="comment"># 是否允许Pod使用hostNetwork</span></span><br><span class="line">  <span class="string">hostPID</span> <span class="string">&lt;boolean&gt;</span>                   <span class="comment"># 是否允许Pod使用hostPID</span></span><br><span class="line">  <span class="string">hostPorts</span> <span class="string">&lt;[]Object&gt;</span>                <span class="comment"># 允许Pod使用的主机端口暴露其服务的范围</span></span><br><span class="line">    <span class="string">max</span>  <span class="string">&lt;integer&gt;</span>                    <span class="comment"># 最大端口号，必选字段</span></span><br><span class="line">    <span class="string">min</span>  <span class="string">&lt;integer&gt;</span>                    <span class="comment"># 最小端口号，必选字段</span></span><br><span class="line">  <span class="string">privileged</span>  <span class="string">&lt;boolean&gt;</span>               <span class="comment"># 是否允许运行特权Pod</span></span><br><span class="line">  <span class="string">readOnlyRootFilesystem</span>  <span class="string">&lt;boolean&gt;</span>   <span class="comment"># 是否设定容器的根文件系统为“只读”</span></span><br><span class="line">  <span class="string">requiredDropCapabilities</span> <span class="string">&lt;[]string&gt;</span> <span class="comment"># 必须要禁用的内核能力列表</span></span><br><span class="line">  <span class="string">runAsGroup</span>  <span class="string">&lt;Object&gt;</span> <span class="comment"># 允许Pod在runAsGroup中使用的值列表，未定义表示不限制</span></span><br><span class="line">  <span class="string">runAsUser</span> <span class="string">&lt;Object&gt;</span>   <span class="comment"># 允许Pod在runAsUser中使用的值列表，必选字段</span></span><br><span class="line">    <span class="string">rule</span> <span class="string">&lt;string&gt;</span>      <span class="comment"># 支持RunAsAny、MustRunAs和MustRunAsNonRoot</span></span><br><span class="line">    <span class="string">ranges</span> <span class="string">&lt;[]Object&gt;</span>  <span class="comment"># 允许使用的组ID范围，需要跟MustRunAs规则一同使用</span></span><br><span class="line">      <span class="string">max</span>  <span class="string">&lt;integer&gt;</span>                  <span class="comment"># 最大组ID号</span></span><br><span class="line">      <span class="string">min</span>  <span class="string">&lt;integer&gt;</span>                  <span class="comment"># 最小组ID号</span></span><br><span class="line">  <span class="string">runtimeClass</span> <span class="string">&lt;Object&gt;</span>               <span class="comment"># 允许Pod使用的运行类，未定义表示不限制</span></span><br><span class="line">    <span class="string">allowedRuntimeClassNames</span> <span class="string">&lt;[]string&gt;</span> <span class="comment"># 可使用的runtimeClass列表，“*”表示all</span></span><br><span class="line">    <span class="string">defaultRuntimeClassName</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 默认使用的runtimeClass</span></span><br><span class="line">  <span class="string">seLinux</span> <span class="string">&lt;Object&gt;</span>                    <span class="comment"># 允许Pod使用的selinux标签，必选字段</span></span><br><span class="line">    <span class="string">rule</span> <span class="string">&lt;string&gt;</span> <span class="comment"># MustRunAs表示使用seLinuxOptions定义的值；RunAsAny表示可使用任意值</span></span><br><span class="line">    <span class="string">seLinuxOptions</span>  <span class="string">&lt;Object&gt;</span>   <span class="comment"># 自定义seLinux选项对象，与MustRunAs协作生效</span></span><br><span class="line">  <span class="string">supplementalGroups</span>  <span class="string">&lt;Object&gt;</span> <span class="comment"># 允许Pod在SecurityContext中使用附加组，必选字段  </span></span><br><span class="line"><span class="string">volumes</span> <span class="string">&lt;[]string&gt;</span>            <span class="comment"># 允许Pod使用的存储卷插件列表，空表示禁用，“*”表示all</span></span><br></pre></td></tr></table></figure>

<p>启用PSP准入控制器后要部署任何Pod对象，相关的User Account及Service Account必须全部获得了恰当的Pod安全策略授权。以常规用户的身份直接创建Pod对象时，PSP准入控制器将根据该账户被授权使用的Pod安全策略验证其凭据，若无任何安全策略约束该Pod对象的安全性，则创建操作将会被拒绝。基于控制器（例如Deployment）创建Pod对象时，PSP准入控制器会根据Pod对象的Service Account被授权使用的Pod安全策略验证其凭据，若不存在支持该Pod对象的安全性要求的安全策略，则Pod控制器资源自身能成功创建，但Pod对象不能。<br>然而，即便在启用了PSP准入控制器的情况下，PSP对象依然不会生效，管理员还需要借助授权插件（例如RBAC）将use权限授权给特定的Role或ClusterRole，再为相关的User Account或Service Account分配这些角色才能让PSP策略真正生效。下面简单说明为Kubernetes集群设定的能支撑集群自身运行的框架性的Pod安全策略，以及允许非管理员使用的Pod安全策略，而后启用PSP准入控制器中使这些策略生效的方法。</p>
<h4 id="设置特权及受限的PSP对象"><a href="#设置特权及受限的PSP对象" class="headerlink" title="设置特权及受限的PSP对象"></a>设置特权及受限的PSP对象</h4><p>通常，system:masters组内的管理员账户、system:node组内的kubelet账户，以及kube-system名称空间中的所有服务账户需要拥有创建各类Pod对象的权限，包括创建特权Pod对象。因此，启用PSP准入控制器之前需要先创建一个特权PSP资源，并将该资源的使用权赋予各类管理员账户以确保Kubernetes集群的基础服务可以正常运行。一个示例性的特权PSP资源清单（psp-privileged.yaml）如下，它启用了几乎所有的安全配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">privileged</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">seccomp.security.alpha.kubernetes.io/allowedProfileNames:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">allowedCapabilities:</span> [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">  <span class="attr">allowedUnsafeSysctls:</span> [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">  <span class="attr">volumes:</span> [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostPorts:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">runAsUser:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;RunAsAny&#x27;</span></span><br><span class="line">  <span class="attr">runAsGroup:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;RunAsAny&#x27;</span></span><br><span class="line">  <span class="attr">seLinux:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;RunAsAny&#x27;</span></span><br><span class="line">  <span class="attr">supplementalGroups:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;RunAsAny&#x27;</span></span><br><span class="line">  <span class="attr">fsGroup:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;RunAsAny&#x27;</span></span><br></pre></td></tr></table></figure>

<p>出于安全加强的需要，除了有特权需求的系统级应用程序及集群管理员账户之外，其他应用或普通账户默认不应该允许使用与安全上下文相关的任何配置。因而，系统内置的特殊组之外的其他普通账户或服务账户，绝大多数都不必使用安全配置，它们仅可使用受限的安全策略。下面的资源清单（psp-restrict.yaml）定义了一个完全受限的安全策略，它禁止了几乎所有的特权操作。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">restricted</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">seccomp.security.alpha.kubernetes.io/allowedProfileNames:</span> <span class="string">&#x27;docker/default&#x27;</span></span><br><span class="line">    <span class="attr">apparmor.security.beta.kubernetes.io/allowedProfileNames:</span> <span class="string">&#x27;runtime/default&#x27;</span></span><br><span class="line">    <span class="attr">seccomp.security.alpha.kubernetes.io/defaultProfileName:</span>  <span class="string">&#x27;docker/default&#x27;</span></span><br><span class="line">    <span class="attr">apparmor.security.beta.kubernetes.io/defaultProfileName:</span>  <span class="string">&#x27;runtime/default&#x27;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">allowedUnsafeSysctls:</span> []</span><br><span class="line">  <span class="attr">requiredDropCapabilities:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">  <span class="comment"># 允许使用的核心存储卷类型</span></span><br><span class="line">  <span class="attr">volumes:</span> [<span class="string">&#x27;configMap&#x27;</span>, <span class="string">&#x27;emptyDir&#x27;</span>, <span class="string">&#x27;projected&#x27;</span>, <span class="string">&#x27;secret&#x27;</span>, <span class="string">&#x27;secret&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;persistentVolumeClaim&#x27;</span>]</span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">runAsUser:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;MustRunAsNonRoot&#x27;</span></span><br><span class="line">  <span class="attr">seLinux:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;RunAsAny&#x27;</span></span><br><span class="line">  <span class="attr">supplementalGroups:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;MustRunAs&#x27;</span></span><br><span class="line">    <span class="attr">ranges:</span></span><br><span class="line">      <span class="comment"># Forbid adding the root group.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">max:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">fsGroup:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">&#x27;MustRunAs&#x27;</span></span><br><span class="line">    <span class="attr">ranges:</span></span><br><span class="line">      <span class="comment"># Forbid adding the root group.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">max:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>将上面两个资源清单中定义的PSP资源提交并创建到集群之上，随后便可授权特定的Role或ClusterRole资源通过use调用它们。PSP资源创建完成后才能授权特定的Role或ClusterRole资源通过use进行调用。我们这里首先使用如下命令将上面配置清单中定义的资源创建到集群之上，调用的方式将在后面一小节中进行说明。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f psp-privileged  -f psp-restricted.yaml</span></span><br><span class="line">podsecuritypolicy.policy/privileged created</span><br><span class="line">podsecuritypolicy.policy/restricted created</span><br></pre></td></tr></table></figure>

<h4 id="创建ClusterRole并完成账户绑定"><a href="#创建ClusterRole并完成账户绑定" class="headerlink" title="创建ClusterRole并完成账户绑定"></a>创建ClusterRole并完成账户绑定</h4><p>启用PodSecurityPolicy准入控制器后，仅被授权使用PSP资源的账户才能够在该资源中定义的策略框架下行使账户权限范围内的资源管理操作。因此，这里还需要显式授予system:masters、system:nodes和system:serviceaccounts:kube-system组内的用户可以使用podsecuritypolicy/privileged资源，其他成功认证后的用户能够使用podsecuritypolicy/restricted资源。RBAC权限模型中，任何Subject都不能直接获得权限，它们需要借助分配到的角色获得权限。因此，下面先创建两个分别能使用podsecuritypolicy/privileged和podsecuritypolicy/restricted资源的ClusterRole。<br>下面的资源清单（clusterrole-with-psp.yaml）中创建了两个ClusterRole资源，授权psp-privileged可以使用名为privileged的安全策略，psp-restricted可以使用名为restricted的安全策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp-restricted</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&#x27;policy&#x27;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&#x27;podsecuritypolicies&#x27;</span>]</span><br><span class="line">  <span class="attr">verbs:</span>  [<span class="string">&#x27;use&#x27;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">restricted</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp-privileged</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&#x27;policy&#x27;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&#x27;podsecuritypolicies&#x27;</span>]</span><br><span class="line">  <span class="attr">verbs:</span>  [<span class="string">&#x27;use&#x27;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">privileged</span></span><br></pre></td></tr></table></figure>

<p>下面的资源清单（clusterrolebinding-with-psp.yaml）定义了两个ClusterRoleBinding对象：前一个为system:masters、system:node和system:serviceaccounts:kube-system组的账户分配集群角色psp-privileged，从而能够使用任何安全配置；后一个为system: authenticated组内的账户分配集群角色psp-restricted，以禁止它们在Pod和容器上使用任何安全配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">privileged-psp-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp-privileged</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:masters</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:node</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:serviceaccounts:kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">restricted-psp-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">psp-restricted</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:authenticated</span></span><br></pre></td></tr></table></figure>

<p>将上面两个资源清单中定义的ClusterRole和ClusterRoleBinding资源创建到集群上，即可为API Server启用PodSecurityPolicy准入控制器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f clusterrole-with-psp.yaml -f clusterrolebinding-with-psp.yaml</span> </span><br><span class="line">clusterrole.rbac.authorization.k8s.io/psp-restricted created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/psp-privileged created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/privileged-psp-user created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/restricted-psp-user created</span><br></pre></td></tr></table></figure>

<h4 id="启用PSP准入控制器"><a href="#启用PSP准入控制器" class="headerlink" title="启用PSP准入控制器"></a>启用PSP准入控制器</h4><p>API Server的应用程kube-apiserver使用–enable-admission-plugins选项显式指定要加载的准入控制器列表，因此在该选项的列表中添加PodSecurityPolicy条目，并重启kube-apiserver程序便能启用PSP准入控制器。对于使用kubeadm部署的Kubernetes集群来说，编辑Master节点上的/etc/kubernetes/manifests/kube-apiserver.yaml配置清单，直接修改–enable-admission-plugins选项的值，并添加PodSecurityPolicy列表项即可，各列表项以逗号分隔。kubelet监控到/etc/kubernetes/manifests目录下的任何资源清单的改变时都会自动重建相关的Pod对象，因此编辑并保存kube-apiserver.yaml资源清单后，kubelet会通过重建相关的静态Pod而自动生效。<br>待kube-apiserver重启完成后，可通过监测API Server程序的运行状态及相关日志来判定PodSecurityPolicy准入控制器是否成功启用。以静态Pod运行kube-apiserver的日志同样可使用kubectl logs命令获取。如下面的命令及截取的结果所示，PodSecurityPolicy准入控制器已然成功加载。若Kubernetes的各系统类Pod资源运行状态正常，即表示安全策略已然成功启用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl logs kube-apiserver-k8s-master01.ilinux.io -n kube-system</span></span><br><span class="line">……</span><br><span class="line">plugins.go:158] Loaded 13 mutating admission controller(s) successfully in the following order: NamespaceLifecycle,LimitRanger,…,PodSecurityPolicy,…</span><br><span class="line">plugins.go:161] Loaded 11 validating admission controller(s) successfully in the following order: LimitRanger,ServiceAccount,PodSecurityPolicy,…</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><font color="red">尽管PSP对已处于运行状态的Pod或容器没有影响，但对于正常运行中的Kubernetes集群来说，中途启用PodSecurityPolicy仍然可能会导致诸多难以预料的错误，尤其是没有事先为用到安全配置的Pod资源准备好可用的PSP资源时，这些Pod资源一旦重启便会因触发PSP策略而被阻止。</font><br>接下来，我们可通过能成功认证的普通账户测试其创建Pod资源时是否受限于restricted安全策略，以验证PodSecurityPolicy资源的生效状态。下面的命令尝试以dev名称空间的管理员mason用户创建一个使用了主机端口（hostPort）的Pod资源，但该操作被PodSecurityPolicy拒绝。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run pod-with-hostport --image=<span class="string">&quot;ikubernetes/demoapp:v1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      --port=80 --hostport=32080 -n dev --context=<span class="string">&#x27;mason@kubernetes&#x27;</span></span></span><br><span class="line">Error from server (Forbidden): pods &quot;pod-with-hostport&quot; is forbidden: unable to validate against any pod security policy: [spec.containers[0].hostPort: Invalid value: 32080: Host port 32080 is not allowed to be used. Allowed ports: []]</span><br></pre></td></tr></table></figure>

<p>因为mason用户由API Server成功认证后，将被自动归类到system:authenticated组和它所属的developers组中，但仅前一个组有权使用restricted安全策略。移除命令中的–hostport选项再次执行创建操作即可成功完成，感兴趣的读者可自行测试。另外，我们也可按此方式授权特定的用户拥有特定类型的Pod对象创建权限，但策略冲突时可能会导致意料不到的结果，因此将任何Pod安全策略应用到生产环境之前请务必做到充分测试。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Kubernetes/" rel="tag"># Kubernetes</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/" rel="prev" title="应用编排与管理(控制器)">
      <i class="fa fa-chevron-left"></i> 应用编排与管理(控制器)
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/02/23/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%AD%96%E7%95%A5/" rel="next" title="网络模型与网络策略">
      网络模型与网络策略 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">1.</span> <span class="nav-text">Kubernetes访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%B4%A6%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">用户账户与用户组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8API-Server%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">测试使用API Server的访问控制机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceAccount%E5%8F%8A%E8%AE%A4%E8%AF%81"><span class="nav-number">2.</span> <span class="nav-text">ServiceAccount及认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceAccount%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">ServiceAccount自动化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServiceAccount%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">ServiceAccount基础应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E5%BC%8FServiceAccount%E8%B5%84%E6%BA%90%E5%88%9B%E5%BB%BA"><span class="nav-number">2.2.1.</span> <span class="nav-text">命令式ServiceAccount资源创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServiceAccount%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">ServiceAccount资源清单</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pod%E8%B5%84%E6%BA%90%E4%B8%8A%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%B4%A6%E6%88%B7"><span class="nav-number">2.3.</span> <span class="nav-text">Pod资源上的服务账户</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#X509%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81"><span class="nav-number">3.</span> <span class="nav-text">X509数字证书认证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes%E7%9A%84X509%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB"><span class="nav-number">3.1.</span> <span class="nav-text">Kubernetes的X509数字证书认证体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLS-Bootstrapping%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.</span> <span class="nav-text">TLS Bootstrapping机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kubeconfig%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">kubeconfig配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kubeconfig%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">kubeconfig文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89kubeconfig%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.</span> <span class="nav-text">自定义kubeconfig文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X509%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E8%BA%AB%E4%BB%BD%E5%87%AD%E6%8D%AE"><span class="nav-number">4.3.</span> <span class="nav-text">X509数字证书身份凭据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9Akubeconfig%E6%96%87%E4%BB%B6%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="nav-number">4.4.</span> <span class="nav-text">多kubeconfig文件与合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%EF%BC%9ARBAC"><span class="nav-number">5.</span> <span class="nav-text">基于角色的访问控制：RBAC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RBAC%E6%8E%88%E6%9D%83%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">RBAC授权模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Role%E4%B8%8EClusterRole"><span class="nav-number">5.2.</span> <span class="nav-text">Role与ClusterRole</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RoleBinding%E4%B8%8EClusterRoleBinding"><span class="nav-number">5.3.</span> <span class="nav-text">RoleBinding与ClusterRoleBinding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%9E%8BClusterRole"><span class="nav-number">5.4.</span> <span class="nav-text">聚合型ClusterRole</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E7%94%A8%E6%88%B7%E7%9A%84%E5%86%85%E7%BD%AEClusterRole"><span class="nav-number">5.5.</span> <span class="nav-text">面向用户的内置ClusterRole</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%9D%83%E9%99%90%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9ADashboard"><span class="nav-number">6.</span> <span class="nav-text">认证与权限应用案例：Dashboard</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2Dashboard"><span class="nav-number">6.1.</span> <span class="nav-text">部署Dashboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83"><span class="nav-number">6.2.</span> <span class="nav-text">认证与授权</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">准入控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">准入控制器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LimitRange"><span class="nav-number">7.2.</span> <span class="nav-text">LimitRange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceQuota"><span class="nav-number">7.3.</span> <span class="nav-text">ResourceQuota</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PodSecurityPolicy"><span class="nav-number">7.4.</span> <span class="nav-text">PodSecurityPolicy</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%89%B9%E6%9D%83%E5%8F%8A%E5%8F%97%E9%99%90%E7%9A%84PSP%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.4.1.</span> <span class="nav-text">设置特权及受限的PSP对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAClusterRole%E5%B9%B6%E5%AE%8C%E6%88%90%E8%B4%A6%E6%88%B7%E7%BB%91%E5%AE%9A"><span class="nav-number">7.4.2.</span> <span class="nav-text">创建ClusterRole并完成账户绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8PSP%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">7.4.3.</span> <span class="nav-text">启用PSP准入控制器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description">myBlog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
