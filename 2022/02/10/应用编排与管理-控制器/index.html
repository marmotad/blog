<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marmotad.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="应用编排与管理应用程序版本升级时的在线应用更新操作也在实践中形成了灰度更新、蓝绿部署和金丝雀部署等解决方案。但这类的编排任务由传统的人工或工具化编排进化到了由ReplicaSet、Deployment或ReplicaSet控制器实现的半自动化编排机制，而HPA（Horizontal Pod Autoscaler）和VPA（Vertical Pod Autoscaler）控制器更是让这类任务彻底走向">
<meta property="og:type" content="article">
<meta property="og:title" content="应用编排与管理(控制器)">
<meta property="og:url" content="https://marmotad.github.io/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/index.html">
<meta property="og:site_name" content="marmotad">
<meta property="og:description" content="应用编排与管理应用程序版本升级时的在线应用更新操作也在实践中形成了灰度更新、蓝绿部署和金丝雀部署等解决方案。但这类的编排任务由传统的人工或工具化编排进化到了由ReplicaSet、Deployment或ReplicaSet控制器实现的半自动化编排机制，而HPA（Horizontal Pod Autoscaler）和VPA（Vertical Pod Autoscaler）控制器更是让这类任务彻底走向">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210103349273.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210112506987.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210112550902.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210112622509.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210125851052.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210130435715.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210130506818.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132418459.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132457826.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132515650.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132948513.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133309242.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133334240.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133752402.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133829935.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210134157079.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210134256636.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210135151879.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210135515103.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210135537338.png">
<meta property="article:published_time" content="2022-02-10T02:31:33.000Z">
<meta property="article:modified_time" content="2022-02-18T05:43:33.371Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marmotad.github.io/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210103349273.png">

<link rel="canonical" href="https://marmotad.github.io/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>应用编排与管理(控制器) | marmotad</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="marmotad" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">marmotad</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://marmotad.github.io/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="myBlog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="marmotad">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          应用编排与管理(控制器)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-10 10:31:33" itemprop="dateCreated datePublished" datetime="2022-02-10T10:31:33+08:00">2022-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-18 13:43:33" itemprop="dateModified" datetime="2022-02-18T13:43:33+08:00">2022-02-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="应用编排与管理"><a href="#应用编排与管理" class="headerlink" title="应用编排与管理"></a>应用编排与管理</h1><p>应用程序版本升级时的在线应用更新操作也在实践中形成了灰度更新、蓝绿部署和金丝雀部署等解决方案。但这类的编排任务由传统的人工或工具化编排进化到了由ReplicaSet、Deployment或ReplicaSet控制器实现的半自动化编排机制，而HPA（Horizontal Pod Autoscaler）和VPA（Vertical Pod Autoscaler）控制器更是让这类任务彻底走向完全自动化。本章着重于介绍无状态应用控制器ReplicaSet和Deployment、系统应用控制器DaemonSet、单次任务控制器Job和定时作业控制器CronJob等。</p>
<h2 id="Kubernetes控制器基础"><a href="#Kubernetes控制器基础" class="headerlink" title="Kubernetes控制器基础"></a>Kubernetes控制器基础</h2><p>我们可以把API Server想象成存储Kubernetes资源对象的数据库系统，它仅支持预置的数据存储方案，每个方案对应于一种资源类型，客户端将API创建的、符合数据存储方案的数据项称为资源对象。但这些基于数据方案创建并存储于API Server中的仅是对象的定义。例如，一个Pod对象的定义并不代表某个以容器形式运行的应用，它仅停留在“纸面上”，我们还需要某个程序以特定的步骤调用容器运行时接口，按照Pod对象的定义创建出具体的应用容器来。这一类负责把API Server上存储的对象定义实例化到集群上的程序就是控制器。控制器需要运行为守护进程：一方面，注册监视API Server上隶属该控制器类型的对象定义（spec）的变动，及时将变动反映到集群中的对象实例之上；另一方面，通过控制循环（control loop，也可称为控制回路）持续监视集群上由其负责管控的对象实例的实际状态，在因故障、更新或其他原因导致当前状态（Status）发生变化而与期望状态（spec）时，通过实时运行相应的程序代码尝试让对象的真实状态向期望状态迁移和逼近。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210103349273.png" alt="image-20220210103349273"></p>
<h3 id="控制器与Pod资源"><a href="#控制器与Pod资源" class="headerlink" title="控制器与Pod资源"></a>控制器与Pod资源</h3><p>本质上讲，Kubernetes的核心就是控制理论，控制器中实现的控制回路是一种闭环（反馈）控制系统，该类型的控制系统基于反馈回路将目标系统的当前状态与预定义的期望状态相比较，二者之间的差异作为误差信号产生一个控制输出作为控制器的输入，以减少或消除目标系统当前状态与期望状态的误差，如图。这种控制循环在Kubernetes上也称为调谐循环（reconciliation loop）。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210112506987.png" alt="image-20220210112506987"></p>
<p>对Kubernetes来说，无论控制器的具体实现有多么简单或多么复杂，它基本都是通过定期重复执行如下3个步骤来完成控制任务。</p>
<blockquote>
<p>1）从API Server读取资源对象的期望状态和当前状态。<br>2）比较二者的差异，而后运行控制器中的必要代码操作现实中的资源对象，将资源对象的真实状态修正为Spec中定义的期望状态，例如创建或删除Pod对象，以及发起一个云服务API请求等。<br>3）变动操作执行成功后，将结果状态存储在API Server上的目标资源对象的status字段中。<br>图8-3给出了Kubernetes控制循环工作示意图。</p>
</blockquote>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210112550902.png" alt="image-20220210112550902"></p>
<p>任务繁重的Kubernetes集群上同时运行着数量巨大的控制循环，每个循环都有一组特定的任务要处理，为了避免API Server被请求淹没，需设定控制回路以较低的频率运行，默认每5分钟一次。同时，为了能及时触发由客户端提交的期望状态的更改，控制器向API Server注册监视受控资源对象，这些资源对象期望状态的任何变动都会由Informer组件通知给控制器立即执行而无须等到下一轮的控制循环。控制器使用工作队列将需要运行的控制循环进行排队，从而确保在受控对象众多或资源对象变动频繁的场景中尽量少地错过控制任务。<br>出于简化管理的目的，Kubernetes将数十种内置的控制器程序整合成了名为kube-controller-manager的单个应用程序，并运行为独立的单体守护进程，它是控制平面的重要组件，也整个Kubernetes集群的控制中心。提示<br>Kubernetes可用的控制器有attachdetach、bootstrapsigner、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpoint、garbagecollector、horizontalpodautoscaling、job、namespace、node、persistentvolume-binder、persistentvolume-expander、podgc、pvc-protection、replicaset、replicationcontroller、resourcequota、route、service、serviceaccount、serviceaccount-token、statefulset、tokencleaner和ttl等数十种。<br>工作负载范畴的控制器资源类型包括ReplicationController、ReplicaSet、Deployment、DaemonSet、StatefulSet、Job和CronJob等，它们各自代表一种类型的Pod控制器资源，分别实现不同的应用编排机制。<br>通常，一个工作负载控制器资源通常应该包含3个基本的组成部分。</p>
<ul>
<li>标签选择器：匹配并关联Pod对象，并据此完成受其管控的Pod对象的计数。</li>
<li>期望的副本数：期望在集群中精确运行受控的Pod对象数量。</li>
<li>Pod模板：用于新建Pod对象使用的模板资源。注意</li>
</ul>
<p>DaemonSet控制器用于确保集群中每个工作节点或符合条件的每个节点上都运行着一个Pod副本，而非某个预设的精确数量值，因而不具有上面组成部分中的第二项。<br>例如，如图8-4所示的Deployment控制器eshop-deploy对象使用app=eshop为标签选择器，以过滤当前名称空间中的Pod对象，它期望能够匹配到的Pod对象副本数量精确为4个。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210112622509.png" alt="image-20220210112622509"></p>
<p>将eshop-deploy对象创建到集群上之后，Deployment控制器将根据该对象的定义标签选择器过滤符合条件的Pod对象并对其进行计数，少于指定数量的缺失部分将由控制器通过Pod模板予以创建，而多出的副本也将由控制器请求终止及删除。<br>通常，对于那些以Deployment、DaemonSet或StatefulSet控制器编排的且需要长期运行的容器应用，其应用更新、回滚和扩缩容也是编排操作的核心任务。但这类任务所导致的Pod对象的变动势必会影响透过Service来访问应用服务的客户端，如图8-5所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210125851052.png" alt="image-20220210125851052"></p>
<p>显然，生产环境中的应用编排过程通常不能影响或过度影响当前正在获取服务的用户体验，达成该类目标也是应用程序控制器的核心功能之一，事实上，Deployment等甚至允许用户自定义更新策略来自定义应用升级过程。</p>
<h3 id="Pod模板资源"><a href="#Pod模板资源" class="headerlink" title="Pod模板资源"></a>Pod模板资源</h3><p>Pod模板资源是Kubernetes API的常用资源类型，常用于为控制器指定自动创建Pod资源对象时所需的配置信息。内嵌于控制器的Pod模板的配置信息中不需要apiVersion和kind字段，除此之外的其他内容跟定义自主式Pod对象所支持的字段几乎完全相同，这包括metadata和spec及其内嵌的其他各字段。<br>工作负载控制器类的资源的spec字段通常都要内嵌replicas、selector和template字段，其中template便是用于定义Pod模板。下面是一个定义在ReplicaSet资源中的模板资源示例，它基于ikubernetes/demoapp:v1.0镜像简单定义了一个应用，并同时配置了存活探针和就绪探针。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">replicaset-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ikubernetes/demoapp:v1.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&#x27;/livez&#x27;</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&#x27;/readyz&#x27;</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>如上示例中，spec.template字段在定义时仅给出了metadata和spec两个字段，它的使用方法与自主式Pod资源几乎完全相同。一个特别的建议是，生产环境中运行的Pod对象务必要添加存活探针和就绪探针，否则Kubernetes无法准确判定应用的存活状态和就绪状态，而只能把处于运行中的容器进程一律视为在健康运行，而健康运行的容器进程则一律视为就绪。显然，定义在Pod模板中的存储卷资源将由当前模板创建出的所有Pod实例共享使用，因此定义时务必要确保该存储卷允许多路客户端同时访问，以及多路写操作时的数据安全性。<br>应用编排是Kubernetes的核心功能，因而控制器资源及其使用的Pod模板也随之成为最常用的两种资源类型。</p>
<h2 id="ReplicaSet控制器"><a href="#ReplicaSet控制器" class="headerlink" title="ReplicaSet控制器"></a>ReplicaSet控制器</h2><p>Kubernetes较早期的版本中仅有ReplicationController一种类型的Pod控制器，后来又陆续引入了更多的控制器实现，这其中就包括用来取代ReplicationController的新一代实现ReplicaSet。事实上，ReplicaSet除了支持基于集合的标签选择器，以及它的滚动更新（RollingUpdate）机制要基于更高级的Deployment控制器实现之外，目前ReplicaSet的其余功能基本与ReplicationController相同。考虑到Kubernetes强烈推荐使用ReplicaSet控制器，且表示ReplicationController不久后即将废弃，因而本节重点介绍ReplicaSet控制器。</p>
<h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p>ReplicaSet（简称RS）是工作负载控制器类型的一种实现，隶属于名称空间级别，主要用于编排无状态应用，核心目标在于确保集群上运行有指定数量的、符合其标签选择器的Pod副本。ReplicaSet规范由标签选择器、期望的副本数和Pod模板3个主要因素所定义，它在控制循环中持续监视同一名称空间中运行的Pod对象，并在每个循环中将标签选择器筛选出的Pod数量与期望的数量相比较，通过删除多余的Pod副本或借助于模板创建出新的Pod来确保该类Pod对象数量能始终吻合所期望的数量。<br>标签选择器是ReplicaSet判断一个Pod对象是否处于其作用域的唯一标准，Pod模板仅在补足缺失数量的Pod对象时使用，这意味着由其他Pod规范所创建的Pod对象也存在进入某个ReplicaSet作用域的可能性。因而，我们要精心设计同一名称空间中使用的标签选择器，以竭力避免它们以相同的条件出现在不同的控制器对象之上，这种原则同样交叉适用于其他类型的控制器对象。<br>ReplicaSet规范中的副本数量、标签选择器，甚至是Pod模板都可以在对象创建后随时按需进行修改。降低期望的Pod副本数量会导致删除现有的Pod对象，而增加该数量值会促使ReplicaSet控制器根据模板创建出新的Pod对象。修改标签选择器会导致ReplicaSet在当前名称空间中匹配Pod标签，这可能会让它无法再匹配到现有Pod副本的标签，进而触发必要的删除或创建操作。另外，ReplicaSet不会关注筛选到的现存Pod对象或者由其自身创建的Pod对象中的实际内容，因此Pod模板的改动也仅会对后来新建的Pod副本有影响。事实上，ReplicaSet所支持的更新机制也正是建立在Pod模板更新后以“删除后的自动重建”机制之上。<br>相较于手动创建和管理Pod对象来说，ReplicaSet控制器能够实现以下功能。</p>
<ul>
<li>确保Pod对象的数量精确反映期望期：ReplicaSet对象需要确保由其控制运行的Pod副本数量精确吻合配置中定义的期望值，否则会自动补足所缺或终止所余。</li>
<li>确保Pod健康运行：探测到由其管控的Pod对象健康状态检查失败或因其所在的工作节点故障而不可用时，自动请求控制平面在其他工作节点创建缺失的Pod副本。</li>
<li>弹性伸缩：应用程序业务规模因各种原因时常存在明显波动，如波峰或波谷期间，可以通过改动ReplicaSet控制器规范中的副本数量动态调整相关Pod资源对象的数量，甚至是借助HPA控制器实现Pod资源规模的自动伸缩。</li>
</ul>
<p>但ReplicaSet并非是用户使用无状态应用控制器的最终形态，Deployment控制器基于ReplicaSet实现了滚动更新、自动回滚、金丝雀部署甚至是蓝绿部署等更为高级和自动化的任务编排功能，因而成为用户在编排无状态应用时更高级的选择。</p>
<h3 id="ReplicaSet基础应用"><a href="#ReplicaSet基础应用" class="headerlink" title="ReplicaSet基础应用"></a>ReplicaSet基础应用</h3><p>ReplicaSet由kind、apiVersion、metadata、spec和status这5个一级字段组成，它的基本配置框架如下面的配置规范所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">…</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">…</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">minReadySeconds</span> <span class="string">&lt;integer&gt;</span>  <span class="comment"># Pod就绪后多少秒内，任一容器无崩溃方可视为“就绪”</span></span><br><span class="line">  <span class="string">replicas</span> <span class="string">&lt;integer&gt;</span> <span class="comment"># 期望的Pod副本数，默认为1</span></span><br><span class="line">  <span class="attr">selector:</span>    <span class="comment"># 标签选择器，必须匹配template字段中Pod模板中的标签</span></span><br><span class="line">    <span class="string">matchExpressions</span> <span class="string">&lt;[]Object&gt;</span>     <span class="comment"># 标签选择器表达式列表，多个列表项之间为“与”关系</span></span><br><span class="line">    <span class="string">matchLabels</span> <span class="string">&lt;map[string]string&gt;</span> <span class="comment"># map格式的标签选择器</span></span><br><span class="line">  <span class="attr">template:</span>    <span class="comment"># Pod模板对象</span></span><br><span class="line">    <span class="attr">metadata:</span>  <span class="comment"># Pod对象元数据</span></span><br><span class="line">      <span class="attr">labels:</span>  <span class="comment"># 由模板创建出的Pod对象所拥有的标签，必须要能够匹配前面定义的标签选择器</span></span><br><span class="line">    <span class="attr">spec:</span>      <span class="comment"># Pod规范，格式同自主式Pod</span></span><br><span class="line">      <span class="string">……</span></span><br></pre></td></tr></table></figure>

<p>ReplicaSet规范中用于定义标签选择器的selector字段为必先字段，它支持matchLabels和matchExpressions两种表示格式。前者使用字符串映射格式，以key: value形式表达要匹配的标签；后者支持复杂的表达式格式，支持基于“等值（运算符=和!=）”和基于“集合”（运算符为in和notin等）的表示方法，同时定义二者时的内生逻辑为“与”关系。Pod模板中定义的标签必须要能匹配到其所属ReplicaSet对象的标签选择器，否则，ReplicaSet将因始终不具有足额的Pod副本数而无限创建下去，这相当于程序代码中无终止条件的死循环。另外，minReadySeconds字段用于指定在Pod对象启动后的多长时间内其容器未发生崩溃等异常情况即被视为“就绪”，默认为值0秒，表示一旦就绪性探测成功，即被视作可用。<br>将“Pod模板资源”一节中的示例保存于资源清单文件中，例如replicaset-demo.yaml，而后即可使用类似如下命令将其创建到集群上来观察其运行特性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f replicaset-demo.yaml</span> </span><br><span class="line">replicaset.apps/replicaset-demo created</span><br></pre></td></tr></table></figure>

<p>ReplicaSet对象的详细描述信息会输出对象的重点信息，例如标签选择器、Pod状态、Pod模板和相关的事件等。ReplicaSet控制器会追踪作用域的各Pod的运行状态，并把它们归类到Running、Waiting、Succeeded和Failed这4种状态之中。default名称空间中并未存在使用app: replicaset-demo这一标签的Pod对象，因此replicaset-demo需要根据指定的Pod模板创建出replicas字段指定数量的Pod实例，它们的名称以其所属的ReplicaSet对象的名称为前缀。如下的命令输出中可知，replicaset-demo成功创建出的两个Pod实例均处于健康运行状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe replicasets/replicaset-demo</span></span><br><span class="line">Name:         replicaset-demo</span><br><span class="line">Namespace:    default</span><br><span class="line">Selector:     app=demoapp,release=stable</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  Replicas:  2 current / 2 desired</span><br><span class="line">Pods Status:  2 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  app=replicaset-demo</span><br><span class="line">  Containers:</span><br><span class="line">   demoapp:</span><br><span class="line">    Image:        ikubernetes/demoapp:v1.0</span><br><span class="line">    Port:         80/TCP</span><br><span class="line">    Host Port:    0/TCP</span><br><span class="line">    Liveness:   http-get http://:80/livez delay=5s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">    Readiness:  http-get http://:80/readyz delay=15s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">    Environment:  &lt;none&gt;</span><br><span class="line">    Mounts:       &lt;none&gt;</span><br><span class="line">  Volumes:        &lt;none&gt;</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age   From                   Message</span><br><span class="line">  ----    ------            ----  ----                   -------</span><br><span class="line">  Normal  SuccessfulCreate  36s   replicaset-controller  Created pod: replicaset-demo-z6bqt</span><br><span class="line">  Normal  SuccessfulCreate  36s   replicaset-controller  Created pod: replicaset-demo-vwb5g</span><br></pre></td></tr></table></figure>

<p>我们也可以单独打印ReplicaSet对象的简要及扩展信息来了解其运行状态，例如期望的Pod副本数（DESIRED）、当前副本数（CURRENT）和就绪的副本数（READY），以及使用的镜像和标签选择器等，如下面的命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets/replicaset-demo -o wide</span></span><br><span class="line">NAME  DESIRED  CURRENT  READY  AGE  CONTAINERS  IMAGES  SELECTOR</span><br><span class="line">replicaset-demo   2      2         2      77s   demoapp     ……   app=demoapp,…</span><br></pre></td></tr></table></figure>

<p>通常，就绪的副本数量与期望的副本数量相同便意味着该ReplicaSet控制器以符合期望的状态运行于集群之上，由其编排的容器应用可正常借助专用的Service对象向客户端提供服务。<br>长期运行中的Kubernetes系统环境存在着不少导致Pod对象数目与期望值不符合的可能因素，例如作用域内Pod对象的意外删除、Pod对象标签的变动、ReplicaSet控制器的标签选择器变动，甚至是作用域内Pod对象所在的工作节点故障等。ReplicaSet控制器的调谐循环能实时监控到这类异常，并及时启动调谐操作。<br>任何原因导致的标签选择器匹配Pod对象缺失，都会由ReplicaSet控制器自动补足，我们可通过手动修改replicaset-demo标签选择器作用域内任一现有Pod对象标签，使得匹配失败，则该控制器的标签选择器会触发控制器的Pod对象副本缺失补足机制，其操作步骤如下。</p>
<ul>
<li>步骤1：获取replicaset-demo标签选择器作用域内的一个Pod对象：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">pod=$(kubectl get pods -l app=demoapp,release=stable -o jsonpath=&#123;.items[1].metadata.name&#125;)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$pod</span></span></span><br><span class="line">replicaset-demo-z6bqt</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：删除该Pod对象的任意一个标签，例如app，使其无法再匹配到replicaset-demo的标签选择器：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl label pod <span class="variable">$pod</span> app-</span></span><br><span class="line">pod/replicaset-demo-z6bqt labeled</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤3：验证replicaset-demo是否将此前的Pod对象替换为了新建的Pod对象：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable</span></span><br><span class="line">NAME            READY   STATUS   RESTARTS   AGE</span><br><span class="line">replicaset-demo-fcrkl      0/1     Running   0          4s</span><br><span class="line">replicaset-demo-vwb5g      1/1     Running   0          5m49s</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤4：可以看到此前的Pod对象依然存在，但它成为自主式Pod对象，而代表上级引用关系的metadata.ownerReferences字段变成空值，于是下面的命令便不再有返回值。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods <span class="variable">$pod</span> -o jsonpath=&#123;.metadata.ownerReferences&#125;</span></span><br></pre></td></tr></table></figure>

<p>由此可见，通过修改Pod资源的标签即可将其从控制器的管控之下移出，若修改后的标签又能被其他控制器资源的标签选择器命中，则该Pod对象又成为隶属另一控制器的副本。若修改其标签后的Pod对象不再隶属于任何控制器，它就成了自主式Pod。<br>另一方面，一旦被标签选择器匹配到的Pod对象数量因任何原因超出期望值，多余的部分也将被控制器自动删除。例如，我们可以为此前移出作用域的Pod对象重新添加app标签，让其能够再次匹配到replicaset-demo的标签选择器，这将触发控制器删除多余的Pod对象，如下面的命令结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl label pods <span class="variable">$pod</span> app=demoapp</span></span><br><span class="line">pod/replicaset-demo-z6bqt labeled</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable</span></span><br><span class="line">NAME                    READY    STATUS        RESTARTS   AGE</span><br><span class="line">replicaset-demo-fcrkl    1/1     Terminating   0          2m17s</span><br><span class="line">replicaset-demo-vwb5g    1/1     Running       0          8m2s</span><br><span class="line">replicaset-demo-z6bqt    1/1     Running       0          8m2s</span><br></pre></td></tr></table></figure>

<h3 id="应用更新与回滚"><a href="#应用更新与回滚" class="headerlink" title="应用更新与回滚"></a>应用更新与回滚</h3><p>ReplicaSet不会校验作用域内处于活动状态的Pod对象的内容，改动Pod模板的定义对已经创建完成的活动对象无效，但在用户手动删除其旧版本的Pod对象后能够自动以新代旧，实现控制器下的应用更新。通过修改Pod中某容器的镜像文件版本进行应用程序的版本升级是最常见的应用更新场景。<br><font color="red">尽管ReplicaSet资源的Pod模板可随时按需修改，但它仅影响其后新建的Pod对象，对已有的Pod副本不产生作用，因此，ReplicaSet自身并不会自动触发更新机制，它依赖于用户的手动触发机制。Deployment控制器是建立在ReplicaSet之上的，专用于支持声明式更新功能的更高级实现。</font><br>在配置清单replicaset-demo.yaml中定义的replicaset-demo资源中，修改Pod模板中的容器使用的镜像文件为更高的版本，例如下面示例性配置片段中的ikubernetes/demoapp: v1.1，而后将变动的配置清单重新应用到集群上便可完成ReplicaSet控制器资源的更新。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">ikubernetes/demoapp:v1.1</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>将更新后的配置清单应用到集群之中，可以发现，现有各Pod对象中demoapp容器的镜像版本与replicaset-demo的Pod模板中的镜像版本存在差异。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f replicaset-demo.yaml</span></span><br><span class="line">replicaset.apps/replicaset-demo configured</span><br></pre></td></tr></table></figure>

<p>首先，我们可以使用如下命令获取活动对象replicaset-demo的Pod模板中定义的镜像文件及版本信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets/replicaset-demo -o jsonpath=&#123;.spec.template.spec.containers[0].image&#125;</span></span><br><span class="line">ikubernetes/demoapp:v1.1</span><br></pre></td></tr></table></figure>

<p>接着，通过如下命令获取replicaset-demo控制下的所有Pod对象中的demoapp容器的镜像文件及版本信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable \</span></span><br><span class="line"><span class="language-bash">-o jsonpath=<span class="string">&#x27;&#123;range .items[*]&#125;[&#123;.metadata.name&#125;, &#123;.spec.containers[0].image&#125;]&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span></span></span><br><span class="line">[replicaset-demo-vwb5g, ikubernetes/demoapp:v1.0]</span><br><span class="line">[replicaset-demo-z6bqt, ikubernetes/demoapp:v1.0]</span><br></pre></td></tr></table></figure>

<p>上面两个命令及返回结果证实了“更新Pod模板不会对现在的Pod对象产生实质影响”的结论。另一方面，Pod中定义的容器及镜像的字段是不可变字段，我们无法在Pod创建完成后动态更新其容器镜像，因而接下来只有手动将replicaset-demo的现有Pod对象移出其标签选择器作用域（修改标签或删除Pod对象）来触发基于新的Pod模板新建Pod对象，以完成应用的版本更新。</p>
<h4 id="常见更新机制"><a href="#常见更新机制" class="headerlink" title="常见更新机制"></a>常见更新机制</h4><p>常见的更新机制有如下两种。</p>
<h5 id="1）单批次替换"><a href="#1）单批次替换" class="headerlink" title="1）单批次替换"></a>1）单批次替换</h5><p>一次性替换所有Pod对象（见图8-6）：也称为重建式更新（recreate），是最为简单、高效的更新方式，但会导致相应的服务在一段时间内（至少一个Pod对象更新完成并就绪）完全不可用，因而一般不会用在对服务可用性有较高要求的生产环境中。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210130435715.png" alt="image-20220210130435715"></p>
<h5 id="2）多批次替换"><a href="#2）多批次替换" class="headerlink" title="2）多批次替换"></a>2）多批次替换</h5><p>一次仅替换一批Pod对象（见图8-7）：也称为滚动更新，是一种略复杂的更新方式，需要根据实时业务量和Pod对象的总体承载力做好批次规划，而后待一批Pod对象就绪后再更新另一批，直到全部完成为止；该策略实现了不间断服务的目标，但更新过程中会出现不同的应用版本并存且同时提供服务的状况。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210130506818.png" alt="image-20220210130506818"></p>
<p>接下来，我们在replicaset-demo之上分别进行更新测试来验证这两种方式的更新效果。我们先为replicaset-demo作用域内的各Pod对象创建一个ClusterIP类型的Service对象，以方便客户端在更新过程中进行请求测试，以下配置保存于service-for-replicaset-demo.yaml清单文件中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>接下来，将上面配置清单中的Service对象demoapp通过如下命令创建到集群之上，随后的应用测试将以之作为访问入口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f service-for-replicaset-demo.yaml</span> </span><br><span class="line">service/demoapp created</span><br></pre></td></tr></table></figure>

<h4 id="重建式更新测试"><a href="#重建式更新测试" class="headerlink" title="重建式更新测试"></a>重建式更新测试</h4><ul>
<li>步骤1：在管理节点上打开一个新的终端，创建一个临时的客户端Pod并发起持续性的请求测试，以验证单批次更新过程中是否会发生服务中断。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run pod-<span class="variable">$RANDOM</span> --image=ikubernetes/admin-toolbox:v1.0 -it \</span></span><br><span class="line"><span class="language-bash">          --<span class="built_in">rm</span> --<span class="built_in">command</span> -- /bin/sh</span></span><br><span class="line">[root@pod-28426 /]#</span><br></pre></td></tr></table></figure>

<p>此时，在临时Pod的交互式接口中运行如下循环进行请求测试，立即可以看到v1.0版本的demoapp的响应结果；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@pod-28426 /]# while true; do curl --connect-timeout 1 \</span><br><span class="line">         demoapp.default.svc; sleep 1; done</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：删除replicaset-demo作用域内的所有Pod对象，而后观察其更新结果。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete pods -l app=demoapp,release=stable</span></span><br><span class="line">pod &quot;replicaset-demo-vwb5g&quot; deleted</span><br><span class="line">pod &quot;replicaset-demo-z6bqt&quot; deleted</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤3：使用如下命令查看是否生成具有同样标签的新Pod对象。在如下命令结果中的任何一个新Pod对象就绪之前，curl命令返回结果会出现一定数量的请求超时，这是单批次更新的必然结果；验证完成后，应该停止测试循环。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable</span>      </span><br><span class="line">NAME                   READY    STATUS    RESTARTS   AGE</span><br><span class="line">replicaset-demo-mjc5x   0/1     Running   0          10s</span><br><span class="line">replicaset-demo-w5lxw   0/1     Running   0          10s</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤4：验证这些新的Pod对象中demoapp容器是否更新为指定的新镜像文件及版本。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable \</span></span><br><span class="line"><span class="language-bash">    -o jsonpath=<span class="string">&#x27;&#123;range .items[*]&#125;[&#123;.metadata.name&#125;, &#123;.spec.containers[0].</span></span></span><br><span class="line">    image&#125;]&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span><br><span class="line">[replicaset-demo-mjc5x, ikubernetes/demoapp:v1.1]</span><br><span class="line">[replicaset-demo-w5lxw, ikubernetes/demoapp:v1.1]</span><br></pre></td></tr></table></figure>

<p>事实上，修改Pod模板时，不仅能替换镜像文件的版本，甚至可以将其替换为其他应用程序的镜像，只不过此类需求并不多见。若同时改动的还有Pod模板中的其他字段，在新旧更替的过程中，它们也将随之被应用。</p>
<h4 id="滚动式更新测试"><a href="#滚动式更新测试" class="headerlink" title="滚动式更新测试"></a>滚动式更新测试</h4><ul>
<li>步骤1：同前一节中的测试方式相似，我们需要在管理节点上打开一个新的终端，创建一个临时的客户端Pod以发起持续性的请求测试，以验证滚动更新过程中是否会发生服务中断。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run pod-<span class="variable">$RANDOM</span> --image=ikubernetes/admin-toolbox:v1.0 -it \</span></span><br><span class="line"><span class="language-bash">          --<span class="built_in">rm</span> --<span class="built_in">command</span> -- /bin/sh</span></span><br><span class="line">[root@pod-10196 /]#</span><br></pre></td></tr></table></figure>

<p>此时，在临时Pod的交互式接口中运行如下循环进行请求测试，立即可以看到v1.0版本的demoapp的响应结果；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@pod-10196 /]# while true; do curl --connect-timeout 1 \</span><br><span class="line">         demoapp.default.svc; sleep 1; done</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤2：更新replicaset-demo的Pod模板中demoapp容器使用ikubernetes/demoapp:v1.2镜像。本次，我们使用更便捷的kubectl set image命令。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image replicasets/replicaset-demo demoapp=<span class="string">&quot;ikubernetes/demoapp:v1.2&quot;</span></span></span><br><span class="line">replicaset.apps/replicaset-demo image updated</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤3：将replicaset-demo作用域的仅有的两个Pod对象分成两个批次进行更新。为了便于识别待删除对象，下面的命令获取现有的相关两个Pod对象的名称保存在数组中，并打印出相关的Pod对象名称。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">pods=($(kubectl get pods -l app=demoapp,release=stable  \</span></span><br><span class="line"><span class="language-bash">    -o jsonpath=<span class="string">&quot;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&#x27;\t&#x27;&#125;&#123;end&#125;&quot;</span>))</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$&#123;pods[@]&#125;</span></span></span><br><span class="line">replicaset-demo-l857r replicaset-demo-r9t8f</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤4：尝试删除一个Pod对象，以触发启动更新操作。随后，立即运行一个交互式的监视命令持续监视replicaset-demo作用域内各Pod对象的状态变动，可以看到旧版本Pod对象的删除及新Pod创建过程中的事件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete pods <span class="variable">$&#123;pods[1]&#125;</span></span></span><br><span class="line">pod &quot;replicaset-demo-r9t8f&quot; deleted</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable -w</span></span><br><span class="line">NAME                    READY   STATUS         RESTARTS   AGE</span><br><span class="line">replicaset-demo-l857r   1/1     Running        0          143m</span><br><span class="line">replicaset-demo-r9t8f   1/1     Terminating    0          143m</span><br><span class="line">replicaset-demo-zxsh7   0/1     Running        0          8s</span><br><span class="line">replicaset-demo-zxsh7   1/1     Running        0          20s</span><br></pre></td></tr></table></figure>

<p>在删除命令执行后的新建Pod对象replicaset-demo-zxsh7就绪之前，客户端持续发出访问请求的所有响应均应该来自未删除的旧版本Pod对象。新Pod就绪后才能由相应的Service对象demoapp识别为Ready状态的后端端点，并路由请求报文至该端点，此时响应报文来自一新一旧两个版本的Pod对象，下面的内容就截取自相关测试命令的返回结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iKubernetes demoapp v1.2 !!……, ServerName: replicaset-demo-zxsh7, ServerIP: 10.244.3.16!</span><br><span class="line">iKubernetes demoapp v1.1 !!……, ServerName: replicaset-demo-l857r, ServerIP: 10.244.1.41!</span><br></pre></td></tr></table></figure>

<ul>
<li>步骤5：再删除另一个旧版本的Pod对象，待替换的新Pod就绪后，测试命令的响应内容均来自于新版本的Pod对象，滚动更新也就全部完成了。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl delete pods <span class="variable">$&#123;pods[0]&#125;</span></span></span><br><span class="line">pod &quot;replicaset-demo-l857r&quot; deleted</span><br></pre></td></tr></table></figure>

<p>由以上测试过程可知，滚动更新过程不会导致服务中断，唯一的问题在于两个版本有短暂的共存期，若两个版本使用了不同的数据库格式，则需要禁 止新版本执行写操作，以免数据异常。必要时，用户还可以将Pod模板改回旧的版本进行应用的“降级”或“回滚”，它的操作过程与上述过程类似，不同之处仅是将镜像文件改为过去曾使用过的历史版本。</p>
<h3 id="应用扩容与缩容"><a href="#应用扩容与缩容" class="headerlink" title="应用扩容与缩容"></a>应用扩容与缩容</h3><p>改动ReplicaSet控制器对象配置中期望的Pod副本数量（replicas字段）会由控制器实时做出响应，从而实现应用规模的水平伸缩。replicas的修改及应用方式同Pod模板，不过，kubectl提供了一个专用的子命令scale用于实现应用规模的伸缩，它支持从资源清单文件中获取新的目标副本数量，也可以直接在命令行通过–replicas选项读取，例如将replicaset-demo控制器的Pod副本数量提升至4个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl scale replicasets/replicaset-demo --replicas=4</span></span><br><span class="line">replicaset.apps/replicaset-demo scaled</span><br></pre></td></tr></table></figure>

<p>由下面显示的rs-example资源的状态可以看出，将其Pod资源副本扩展至5个的操作已经成功完成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets/replicaset-demo</span></span><br><span class="line">NAME              DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset-demo   4         4         4       3h</span><br></pre></td></tr></table></figure>

<p>ReplicaSet缩容的方式与扩容方式相同，我们只需要明确指定目标副本数量即可。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl scale replicasets/replicaset-demo --replicas=1</span></span><br><span class="line">replicaset.apps/replicaset-demo scaled</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets/replicaset-demo</span>               </span><br><span class="line">NAME              DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset-demo   1         1         1       3h</span><br></pre></td></tr></table></figure>

<p>另外，kubectl scale命令还支持在现有Pod副本数量符合指定值时才执行扩展操作，这仅需要为命令使用–current-replicas选项即可。例如，下面的命令表示如果replicaset-demo目前的Pod副本数量为2，就将其扩展至3个：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl scale replicasets/replicaset-demo --current-replicas=2 --replicas=3</span></span><br><span class="line">error: Expected replicas to be 2, was 1</span><br></pre></td></tr></table></figure>

<p>但由于replicaset-demo控制器现存的副本数量是1个，上面的扩容操作不会真正执行，而是仅返回了错误提示。</p>
<h3 id="高级更新策略"><a href="#高级更新策略" class="headerlink" title="高级更新策略"></a>高级更新策略</h3><p>除联合使用多个ReplicaSet外，我们还能为应用更新功能模拟实现更加灵活和更易于维护的滚动更新、金丝雀部署和蓝绿部署等。1. 滚动更新<br>ReplicaSet上的应用更新也能够不改变现有资源（简称为rs-old）的定义，而是借助创建一个有着新版本Pod模板的新ReplicaSet资源（简称为rs-new）实现。新旧版本的ReplicaSet使用了不同的标签选择器，它们筛选相同的Pod标签，但至少会有一个标签匹配到不同的值，余下的标签各自匹配相同值，相关的Service对象的标签选择器会匹配这些拥有相同值的标签。<br>我们可以设计用rs-old和rs-new共同筛选app、release和version标签，其中app和release分别匹配相同值，例如app=demoapp、release=stable，而version则匹配不同值，如rs-old匹配version=v1.0，而rs-new匹配version=v1.1。同时，Service的标签选择器则筛选app=demoapp和release=stable，以便能匹配到更新期间两个不同ReplicaSet作用域内不同版本的Pod对象。具体如图8-8所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132418459.png" alt="image-20220210132418459"></p>
<p>rs-new的初始副本数为0，在更新过程中，我们以特定的分批（每个批次简称1个单位或步长）策略逐步增加rs-new的replicas字段值，并同步降低rs-old的replicas字段值，直到rs-new副本数为期望的数量，而rs-old的副本数为0时更新过程结束，如图8-9所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132457826.png" alt="image-20220210132457826"></p>
<p>具体操作时，我们可以采取如下3种不同的策略进行整个滚动更新过程：</p>
<ul>
<li>先于rs-new上增加1个单位的Pod副本，待全部就绪后再于rs-old上降低1个单位的副本数，待所有旧Pod成功终止后进行下一批次；</li>
<li>先于rs-old上降低1个单位的Pod副本，待所有旧Pod成功终止后再于rs-new上增加1个单位的副本数，再待所有新Pod对象就绪后进行下一批次；</li>
<li>以同步的方式进行，rs-new上新增1个单位的Pod对象，与此同时，rs-old上降低1个单位的副本数，等新Pod全部就绪且旧Pod全部成功终止后进行下一批次。</li>
</ul>
<p>由此可见，第一和第三种策略会导致更新过程中，新旧两个ReplicaSet资源作用域内的Pod对象总和超出用户期望的副本数，而第二种和第三种策略会使得更新过程中Service的可用后端端点数缺少1个单位，但第三种策略能够更快地完成更新过程。因而，选择更新策略就存在两种重要的判断标准：一是Kubernetes集群资源是否可承载短时间内Pod数量的增加；另一个是支撑相应服务请求总量所依赖的Pod实例数。<br>无论采取哪种滚动策略，我们都可以让更新过程在完成第一批次后暂停一段时长，根据新版本发现的问题以及路由到新版本应用上的用户体验和反馈，来判断是继续完成余下批次的更新操作，还是撤回此前一个批次的更新操作。显然，这种方式能够降低更新过程中的风险，它通过放出的一只“金丝雀”（canary）避免了更大范围的更新故障。<br>另外，我们可保留最近一个范围内的副本数为0的旧版本的ReplicaSet资源于更新历史中，以便按需对比历史更新中所做出的改动，随时按需以类似于“回滚”的更新策略应用至历史中的任一版本。但显然上述的这些操作步骤过于烦琐，以手动方式操作极易出错，幸运的是，更高级别的Pod控制器Deployment能自动实现滚动更新和回滚，并为用户提供了自定义更新策略的接口，这些内容我们将在8.3节中展开说明。2. 蓝绿部署<br>滚动更新过程中，会存在两个不同版本的应用同时向客户端提供服务，且更新和回滚过程耗时较长。另一种更为妥帖的更新方式是，在旧版本ReplicaSet资源运行的同时直接创建一个全Pod副本的新版本ReplicaSet，待所有的新Pod就绪后一次性地将客户端流量全部迁至新版本之上，这种更新策略也称为蓝绿部署（Blue-Green Deployment）。<br>显然，为了避免更新过程中新旧版本ReplicaSet资源的Pod完全并存时Service将流量发往不同版本的Pod对象，我们需要设定Service使用的标签选择器仅能匹配到其中一个版本的Pod对象。最简单的实现方式是让Service与ReplicaSet使用完全相同的标签选择器，但每次更新过程中，在新版本所有Pod就绪之后，修改其标签选择器与新版本的ReplicaSet的标签选择器相同，如图8-10所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132515650.png" alt="image-20220210132515650"></p>
<p>Service将所有客户端流量代理至新版本的Pod上运行一段时长之后，若确定运行正常，即可将旧版本ReplicaSet的副本数置零后保存到历史版本序列中。相较于滚动更新来说，蓝绿部署实现步骤要简单很多，用户完全能够以手动方式完成。<br>例如，下面的配置清单通过环境变量的方式定义了一个可复用的ReplicaSet资源规范，其中的DEPLOY代表部署类型blue或green，而VERSION则用于表示demoapp的程序版本号，它保存在replicaset-blue-green.yaml文件中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">rs-$&#123;DEPLOY&#125;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReadySeconds:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">ctr:</span> <span class="string">rs-$&#123;DEPLOY&#125;</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">$&#123;VERSION&#125;</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">ctr:</span> <span class="string">rs-$&#123;DEPLOY&#125;</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">$&#123;VERSION&#125;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ikubernetes/demoapp:$&#123;VERSION&#125;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>而下面的这个配置清单以类似的方式定义了一个方便复用的Service资源规范，其中的环境变量的作用与前一个配置清单中的环境变量相同，该配置保存在service-blue-green.yaml文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: demoapp-svc</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  selector:</span><br><span class="line">    app: demoapp</span><br><span class="line">    ctr: rs-$&#123;DEPLOY&#125;</span><br><span class="line">    version: $&#123;VERSION&#125;</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br></pre></td></tr></table></figure>

<p>为了测试蓝绿部署的效果，我们先将replicaset-blue-green.yaml配置清单中的ReplicaSet资源以rs-blue的名称部署为待更新的老版本，它使用1.0的demoapp镜像，创建的Pod对象名称均以rs-blue为前缀。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">DEPLOY=<span class="string">&#x27;blue&#x27;</span> VERSION=<span class="string">&#x27;v1.0&#x27;</span> envsubst &lt; replicaset-blue-green.yaml | kubectl apply -f -</span></span><br><span class="line">replicaset.apps/rs-blue created</span><br></pre></td></tr></table></figure>

<p>提示<br>envsubst是一个shell命令，能够从标准输入接收文本，完成环境变量替换。<br>接下来，将service-blue-green.yaml配置清单中的Service资源demoapp-svc部署到集群上，它使用同rs-blue对象相同的标签选择器，等rs-blue作用域内的至少一个Pod就绪后即可接受客户端请求。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">DEPLOY=<span class="string">&#x27;blue&#x27;</span> VERSION=<span class="string">&#x27;v1.0&#x27;</span> envsubst &lt; service-blue-green.yaml | kubectl apply -f -</span></span><br><span class="line">service/demoapp-svc created</span><br></pre></td></tr></table></figure>

<p>随后，在新终端中启动一个用于测试的临时Pod对象，在其接口使用curl命令发起持续性访问请求。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run pod-<span class="variable">$RANDOM</span> --image=ikubernetes/admin-toolbox:v1.0 -it \</span></span><br><span class="line"><span class="language-bash">    --<span class="built_in">rm</span> --<span class="built_in">command</span> -- /bin/sh</span></span><br><span class="line">[root@pod-30411 /]#</span><br><span class="line">[root@pod-30411 /]# while true; do curl --connect-timeout 1 demoapp-svc; sleep 1; done</span><br></pre></td></tr></table></figure>

<p>待rs-blue期望的两个Pod对象均能正常提供服务后，即可假设需要更新到新的demoapp版本。此时，我们需要先基于replicaset-blue-green.yaml配置清单创建名为rs-green的新版本ReplicaSet。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">DEPLOY=<span class="string">&#x27;green&#x27;</span> VERSION=<span class="string">&#x27;v1.1&#x27;</span> envsubst &lt; replicaset-blue-green.yaml | kubectl apply -f -</span>                        </span><br><span class="line">replicaset.apps/rs-green created</span><br></pre></td></tr></table></figure>

<p>随后，等到rs-green的两个Pod均就绪后，将Service对象demoapp-svc的标签选择器修改为匹配新版本ReplicaSet对象rs-green作用域内的所有Pod，可通过如下命令完成。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">DEPLOY=<span class="string">&#x27;green&#x27;</span> VERSION=<span class="string">&#x27;v1.1&#x27;</span> envsubst &lt; service-blue-green.yaml | kubectl apply -f -</span>      </span><br><span class="line">service/demoapp-svc configured</span><br></pre></td></tr></table></figure>

<p>这时，我们可以在专用于发起请求测试的终端上看到所有的响应报文均来自新版本的Pod中的容器应用demoapp。最后，将rs-blue的Pod副本数设置为0即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl scale replicasets/rs-blue --replicas=0</span></span><br><span class="line">replicaset.apps/rs-blue scaled</span><br></pre></td></tr></table></figure>

<p>显然，由于蓝绿部署要求两个及以上版本应用的Pod同时在线，对于应用规模较大而集群资源较为紧张的场景就成为“不可能”任务，而滚动更新则不具有这方面的问题。下面我们将着力介绍可用于声明式更新功能的Deployment控制器。</p>
<h2 id="Deployment控制器"><a href="#Deployment控制器" class="headerlink" title="Deployment控制器"></a>Deployment控制器</h2><p>Deployment（简写为deploy）是Kubernetes控制器的一种高级别实现，它构建于ReplicaSet控制器之上，如图8-11所示。它可用于为Pod和ReplicaSet资源提供声明式更新，并能够以自动方式实现8.2节中介绍的跨多个ReplicaSet对象的滚动更新功能。相比较来说，Pod和ReplicaSet是较低级别的资源，以至于很少被直接使用。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210132948513.png" alt="image-20220210132948513"></p>
<p>Deployment控制器资源的主要职责同样是为了保证Pod资源健康运行，其大部分功能通过调用ReplicaSet控制器实现，并增添了部分特性。</p>
<ul>
<li>事件和状态查看：必要时可以查看Deployment对象的更新进度和状态。</li>
<li>版本记录：将Deployment对象的更新操作予以保存，以便后续可能执行的回滚操作使用。</li>
<li>回滚：更新操作启动后的任一时刻（包括完成后）发现问题，都可以通过回滚机制将应用返回到前一个或由用户指定的历史记录中的版本。</li>
<li>暂停和启动：更新过程中能够随时暂停和继续完成后面的步骤。</li>
<li>多种更新方案：一是Recreate，即重建更新机制，单批次更新所有Pod对象；另一个是RollingUpdate，即滚动更新机制，多批次逐步替换旧有的Pod至新的版本。</li>
</ul>
<p>Deployment资源的扩缩容机制与ReplicaSet相同，修改.spec.replicas即能实时触发其规模变动操作。另外，kubectl scale是专用于扩展特定控制器类型的应用规模的命令，包括Deployment、ReplicaSet和StatefulSet等。</p>
<h3 id="Deployment基础应用"><a href="#Deployment基础应用" class="headerlink" title="Deployment基础应用"></a>Deployment基础应用</h3><p>Deployment是标准的API资源类型，它以ReplicaSet资源为基础资源进行应用编排，并能够自动实现策略式滚动更新或单批次重建式更新，因而它的spec字段中嵌套使用的字段包含了ReplicaSet控制器支持的所有字段，而Deployment也正是利用这些信息完成其二级资源ReplicaSet对象的创建。另外，Deployment还支持几个专用于定义部署及相关策略的字段，具体使用说明如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>           <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>              <span class="comment"># 资源类型特有标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>               <span class="comment"># 资源名称，在作用域中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>          <span class="comment"># 名称空间；Deployment隶属名称空间级别</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">minReadySeconds</span> <span class="string">&lt;integer&gt;</span>   <span class="comment"># Pod就绪后多少秒内任一容器无崩溃方可视为“就绪”</span></span><br><span class="line">  <span class="string">replicas</span> <span class="string">&lt;integer&gt;</span>          <span class="comment"># 期望的Pod副本数，默认为1</span></span><br><span class="line">  <span class="string">selector</span> <span class="string">&lt;object&gt;</span>           <span class="comment"># 标签选择器，必须匹配template字段中Pod模板的标签</span></span><br><span class="line">  <span class="string">template</span> <span class="string">&lt;object&gt;</span>           <span class="comment"># Pod模板对象</span></span><br><span class="line">  <span class="string">revisionHistoryLimit</span> <span class="string">&lt;integer&gt;</span> <span class="comment"># 滚动更新历史记录数量，默认为10</span></span><br><span class="line">  <span class="string">strategy</span> <span class="string">&lt;Object&gt;</span>           <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="string">type</span> <span class="string">&lt;string&gt;</span>             <span class="comment"># 滚动更新类型，可用值有Recreate和Rollingupdate</span></span><br><span class="line">    <span class="string">rollingUpdate</span> <span class="string">&lt;Object&gt;</span>    <span class="comment"># 滚动更新参数，专用于RollingUpdate类型</span></span><br><span class="line">      <span class="string">maxSurge</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 更新期间可比期望的Pod数量多出的数量或比例</span></span><br><span class="line">      <span class="string">maxUnavailable</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 更新期间可比期望的Pod数量缺少的数量或比例</span></span><br><span class="line">  <span class="string">progressDeadlineSeconds</span> <span class="string">&lt;integer&gt;</span> <span class="comment"># 滚动更新故障超时时长，默认为600秒</span></span><br><span class="line">  <span class="string">paused</span> <span class="string">&lt;boolean&gt;</span>            <span class="comment"># 是否暂停部署过程</span></span><br></pre></td></tr></table></figure>

<p>若无须自定义更新策略等相关配置，除了资源类型之外，Deployment资源的基础配置格式几乎与ReplicaSet完全相同。下面是一个配置清单示例，它定了一个名为deployment-demo的Deployment资源，为了便于复用，我们把镜像标签以环境变量VERSION进行标识。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">deployment-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">release:</span> <span class="string">stable</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ikubernetes/demoapp:$&#123;VERSION&#125;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&#x27;/livez&#x27;</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&#x27;/readyz&#x27;</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>同其他类型资源的创建方式类似，Deployment资源规范同样使用kubectl apply或kubectl create命令进行创建，但为了真正、全面地体现Deployment的声明式配置功能，建议统一使用声明式的管理机制创建和更新Deployment资源。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">VERSION=<span class="string">&#x27;v1.0&#x27;</span> envsubst &lt; deployment-demo.yaml | kubectl apply --record -f -</span></span><br><span class="line">deployment.apps/deployment-demo created</span><br></pre></td></tr></table></figure>

<p>kubectl get deployments命令可以列出创建的Deployment对象的简要状态信息，下面命令结果显示出的字段中，UP-TO-DATE表示已经满足期望状态的Pod副本数量，而AVAILABLE则表示当前处于就绪状态并已然可向客户端提供服务的副本数量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get deployments/deployment-demo</span></span><br><span class="line">NAME             READY   UP-TO-DATE     AVAILABLE       AGE</span><br><span class="line">deployment-demo   4/4        4              4           36s</span><br></pre></td></tr></table></figure>

<p>Deployment资源会由控制器自动创建下级ReplicaSet资源，并自动为其生成一个遵循[DEPLOYMENT-NAME]-[POD-TEMPLATE-HASH-VALUE]格式的名称，其中的hash值由Deployment控制器根据Pod模板计算生成。另外，Deployment还会将用户定义在Pod模板上的标签应用到下级ReplicaSet资源之上，并附加一个pod-template-hash的标签，标签值即Pod模板的hash值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets -l app=demoapp,release=stable --show-labels</span></span><br><span class="line">NAME            DESIRED   CURRENT   READY   AGE     LABELS</span><br><span class="line">deployment-demo-b479b6f9f   ……  app=demoapp,pod-template-hash=b479b6f9f, release=stable</span><br></pre></td></tr></table></figure>

<p>Pod对象则使用同上级ReplicaSet资源一样的标签，包括pod-template-hash，而各Pod对象的名称同样遵循ReplicaSet对象对Pod命名的格式，它以ReplicaSet对象的名称为前缀，后跟5位随机字符。下面使用awk过滤出了get pods命令结果中的以deployment-demo开头的所有Pod资源，并显示了它们的标签。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods --show-labels | awk <span class="string">&#x27;/^deployment-demo-/&#123;print $1,$NF&#125;&#x27;</span></span></span><br><span class="line">deployment-demo-b479b6f9f-5phpr app=demoapp,pod-template-hash=b479b6f9f, release=stable</span><br><span class="line">deployment-demo-b479b6f9f-kqk2r app=demoapp,pod-template-hash=b479b6f9f, release=stable</span><br><span class="line">deployment-demo-b479b6f9f-lbsp4 app=demoapp,pod-template-hash=b479b6f9f, release=stable</span><br><span class="line">deployment-demo-b479b6f9f-sbnbj app=demoapp,pod-template-hash=b479b6f9f, release=stable</span><br></pre></td></tr></table></figure>

<p>事实上，Deployment及下级ReplicaSet真正使用的标签选择器也包含pod-template-hash标签，这正是确保Deployment通过多ReplicaSet资源进行滚动更新时，确保各ReplicaSet不会交叉引用同一组Pod对象的一种途径。</p>
<h3 id="Deployment更新策略"><a href="#Deployment更新策略" class="headerlink" title="Deployment更新策略"></a>Deployment更新策略</h3><p><font color="red">Deployment只需要由用户指定在Pod模板中要改动的内容，例如容器镜像文件的版本，余下的步骤可交由Deployment控制器自动完成。</font>未定义更新策略的Deployment资源，将以默认方式配置更新策略，资源详细描述能够输出更新策略的相关配置信息，下面以deployment-demo资源为例来了解默认的更新策略。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe deployments/deployment-demo</span></span><br><span class="line">Name:                   deployment-demo</span><br><span class="line">……</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               app=demoapp,release=stable</span><br><span class="line">Replicas:               4 desired | 4 updated | 4 total | 4 available | 0 unavailableStrategyType:           RollingUpdate</span><br><span class="line">MinReadySeconds:        0RollingUpdateStrategy:  25% max unavailable, 25% max surge</span><br><span class="line">……</span><br><span class="line">OldReplicaSets:  &lt;none&gt;</span><br><span class="line">NewReplicaSet:   deployment-demo-b479b6f9f (4/4 replicas created)</span><br><span class="line">Events:</span><br><span class="line">  ……</span><br></pre></td></tr></table></figure>

<p>Deployment控制器支持滚动更新（rolling updates）和重新创建（recreate）两种更新策略，默认使用滚动更新策略。重建式更新类同前文中ReplicaSet的第一种更新方式，即先删除现存的Pod对象，而后由控制器基于新模板重新创建出新版本资源对象。通常，只有当应用的新旧版本不兼容（例如依赖的后端数据库的格式不同且无法兼容）时才会使用recreate策略。但重建策略会导致应用在更新期间不可用，因而建议用户使用蓝绿部署的方式进行，除非系统资源不足以支撑蓝绿部署的实现。<br>Deployment控制器的滚动更新操作并非在同一个ReplicaSet控制器对象下删除并创建Pod资源，而是将它们分置于两个不同的控制器之下，当前ReplicaSet对象的Pod副本数量不断减少的同时，新ReplicaSet对象的Pod对象数量不断增加，直到现有ReplicaSet对象的Pod副本数为0，而新控制器的副本数量变得完全符合期望值，如图8-9所示。新旧版本之间区别彼此Pod对象的关键标签为pod-template-hash。<br>多批次更新模式的默认间隔标准是前一批次的所有Pod对象均已就绪，方可启动后一批次的更新。而Deployment还提供了两个配置滚动更新批次的字段，以允许用户自定义更新过程的滚动速率，这两个字段分别用于定义滚动更新期间的Pod总数可向上或向下偏离期望值的幅度。</p>
<ul>
<li>spec.strategy.rollingUpdate.maxSurge：指定升级期间存在的总Pod对象数量最多可超出期望值的个数，其值可以是0或正整数，也可以是相对于期望值的一个百分比；例如，如果期望值为10，maxSurge属性值为2，则表示Pod对象总数至多不能超过12个。</li>
<li>spec.strategy.rollingUpdate.maxUnavailable：升级期间正常可用的Pod副本数（包括新旧版本）最多不能低于期望值的个数，其值可以是0或正整数，也可以是相对于期望值的一个百分比；默认值为1，这意味着如果期望值是10，则升级期间至少要有9个Pod对象处于正常提供服务的状态。<br>如8.2.5节中的描述，我们通过组织maxSurge和maxUnavailable两个属性协同工作，可组合定义出3种不同的策略完成多批次的应用更新。</li>
<li>先增新，后减旧：将maxSurge设定为小于等于期望值的正整数或相对于期望值的一个百分比，而maxUnavailable的值为0。</li>
<li>先减旧，后增新：将maxUnavailable设定为小于等于期望值的正整数或相对于期望值的一个百分比，而maxSurge的值为0。</li>
<li>同时增减（少减多增）：将maxSurge和maxUnavailabe字段的值同时设定为小于等于期望值的正整数或相对于期望值的一个百分比，二者可以使用不同值。注意<br>maxSurge和maxUnavailable属性的值不可同时为0，否则Pod对象的副本数量在符合用户期望的数量后无法做出合理变动以进行滚动更新操作。<br>显然，deployment-demo的详细描述显示出，Deployment默认为滚动更新设置了同时增减的策略，增减的幅度为期望值的25%，它通过两个批次的创建和3个批次的删除即能完成整个应用的更新，具体过程如图8-12所示。不过，若Pod对象的整体副本数小于4的话，就只能按一次1个Pod对象的方式进行。</li>
</ul>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133309242.png" alt="image-20220210133309242"></p>
<p>Deployment还支持使用spec.minReadySeconds字段来控制滚动更新的速度，其默认值为0，表示新建的Pod对象一旦“就绪”将立即被视作可用，随后即可开始下一轮更新过程。而为该字段指定一个正整数值能够定义新建的Pod对象至少要成功运行多久才会被视作可用，即就绪之后还要等待minReadySeconds指定的时长才能开始下一批次的更新。在一个批次内新建的所有Pod就绪后但转为可用状态前，更新操作会被阻塞，并且任何一个Pod就绪探测失败，都会导致滚动更新被终止。因此，为minReadySeconds赋予一个合理的正整数值，不仅能够减缓滚动更新的速度，还能够让Deployment提前发现一部分程序Bug导致的升级故障。<br>Deployment可保留一部分滚动更新历史（修订记录）中旧版本的ReplicaSet对象，如图8-13所示。Deployment资源可保存的历史版本数量由spec.revisionHistoryLimit属性进行定义。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133334240.png" alt="image-20220210133334240"></p>
<p><font color="red">为了保存升级历史，需要在创建Deployment对象时为命令使用–record选项。</font><br>尽管滚动更新以节约系统资源著称，但它也存在着一些劣势。直接改动现有环境，会为系统引入不确定性风险，而且一旦在更新过程中遇到问题，回滚操作的过程会较为缓慢。有鉴于此，金丝雀部署可能是较为理想的实现方式。当然，如果不考虑系统资源的可用性，那么传统的蓝绿部署将是更好的选择。</p>
<h3 id="应用更新与回滚-1"><a href="#应用更新与回滚-1" class="headerlink" title="应用更新与回滚"></a>应用更新与回滚</h3><p>Pod模板内容的变动是触发Deployment执行更新操作的必要条件。对于声明式配置的Deployment来说，Pod模板的修改尤其适合使用apply和patch命令进行，不过，若仅是修改容器镜像，set image命令则更为易用。<br>接下来通过更新此前创建的deployment-demo资源来了解Deployment更新操作过程的执行细节。为了使得升级过程更易于观测，这里先使用kubectl patch命令为Deployment的spec.minReadySeconds字段定义一个等待时长，例如30秒：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl patch deployments/deployment-demo -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;minReadySeconds&quot;:30&#125;&#125;&#x27;</span></span></span><br><span class="line">deployment.apps/deployment-demo patched</span><br></pre></td></tr></table></figure>

<p>修改Deployment控制器的minReadySeconds、replicas和strategy等字段的值并不会触发Pod资源的更新操作，因为它们不属于template的内嵌字段，对现存的Pod对象不产生任何影响。<br>接下来，我们让Pod模板中的demoapp容器使用ikubernetes/demoapp:v1.1镜像文件，以触发deployment-demo启动滚动更新，下面先尝试使用kubectl apply命令完成更新操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ VERSION=&#x27;v1.1&#x27; envsubst &lt; deployment-demo.yaml | kubectl apply --record -f - </span><br><span class="line">deployment.apps/deployment-demo configured</span><br></pre></td></tr></table></figure>

<p>kubectl rollout status命令可用于打印滚动更新过程中的状态信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl rollout status deployments/deployment-demo</span></span><br></pre></td></tr></table></figure>

<p>另外，我们还可以使用kubectl get deployments -w命令监控其更新过程中Pod对象的变动过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get deployments/deployment-demo -w</span></span><br></pre></td></tr></table></figure>

<p><font color="red">滚动更新时，deployment-demo会创建一个新的ReplicaSet控制器对象来管控新版本的Pod对象，升级完成后，旧版本的ReplicaSet会保留在历史记录中，但它的Pod副本数被降为0。</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets -l app=demoapp,release=stable</span></span><br><span class="line">NAME                      DESIRED   CURRENT    READY     AGE</span><br><span class="line">deployment-demo-59d9f4475b   4         4         4       1m32s</span><br><span class="line">deployment-demo-b479b6f9f    0         0         0       12m</span><br></pre></td></tr></table></figure>

<p>deployment-demo标签选择器作用域内的Pod资源对象也随之更新为以新版本ReplicaSet名称deployment-demo-59d9f4475b为前缀的Pod副本。<br>另一方面，因各种原因导致滚动更新无法正常进行，例如镜像文件获取失败等，或者更新后遇到的应用程序级故障，例如新版本Pod中的应用触发了未知Bug等，都应该将应用回滚至之前版本用户指定的历史记录中的版本。我们此前曾分别执行了deployment-demo资源的一次部署和一次更新操作，因此修订记录（revision history）分别记录有这两次操作，它们各有一个修订标识符，最大标识符为当前使用的版本。kubectl rollout history命令能够打印Deployment资源的修订历史：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl rollout <span class="built_in">history</span> deployments/deployment-demo</span></span><br><span class="line">deployment.apps/deployment-demo </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl apply --record=true --filename=-</span><br><span class="line">2         kubectl apply --record=true --filename=-</span><br></pre></td></tr></table></figure>

<p>从某种意义上说，回滚亦是更新操作。因而，在deployment-demo之上执行回滚操作意味着将当前版本切换回前一个版本，但历史记录中，其REVISION记录也将随之变动，回滚操作会被当作一次滚动更新追加到历史记录中，而被回滚的条目则会被删除。因而，deployment-demo回滚后修订标识符将从1变为3。回滚操作可使用kubectl rollout undo命令完成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl rollout undo deployments/deployment-demo</span> </span><br><span class="line">deployment.apps/deployment-demo rolled back</span><br></pre></td></tr></table></figure>

<p>回滚完成后，我们可根据客户端的访问结果来验证deployment-demo是否回滚完成，或者根据当前ReplicaSet对象是否恢复到指定的历史版本进行验证。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get replicasets | grep <span class="string">&quot;^deployment-demo&quot;</span></span></span><br><span class="line">deployment-demo-59d9f4475b   0         0         0       11m</span><br><span class="line">deployment-demo-b479b6f9f    4         4         4       13m</span><br></pre></td></tr></table></figure>

<p>另外，在kubectl rollout undo命令上使用–to-revision选项指定revision号码还可回滚到历史记录中的特定版本。需要注意的是，如果此前的滚动更新过程处于“暂停”状态，回滚操作就需要先将Pod模板的版本改回之前，然后“继续”更新，否则，其将一直处于暂停状态而无法回滚。</p>
<h3 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h3><p>Deployment资源允许用户控制更新过程中的滚动节奏，例如“暂停”或“继续”更新操作，尤其是借助于前文讲到的maxSurge和maxUnavailable属性还能实现更为精巧的过程控制。例如，在第一批新的Pod资源创建完成后立即暂停更新过程，此时，仅有一小部分新版本的应用存在，主体部分还是旧的版本。然后，通过应用层路由机制根据请求特征精心筛选出小部分用户的请求路由至新版本的Pod应用，并持续观察其是否能稳定地按期望方式运行。默认，Service只会随机或轮询地将用户请求分发给所有的Pod对象。确定没有问题后再继续进行完余下的所有Pod资源的滚动更新，否则便立即回滚至第一步更新操作。这便是所谓的金丝雀部署，如图8-14所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133752402.png" alt="image-20220210133752402"><br>为了尽可能降低对现有系统及其容量的影响，基于Deployment的金丝雀发布过程通常建议采用“先增后减且可用Pod对象总数不低于期望值”的方式进行。首次添加的Pod对象数量取决于其接入的第一批请求的规则及单个Pod的承载能力，视具体需求而定，为了能更简单地说明问题，接下来采用首批添加1个Pod资源的方式。我们将Deployment控制器的maxSurge属性的值设置为1，并将maxUnavailable属性的值设置为0就能完成设定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~]$ </span><span class="language-bash">kubectl patch deployments/deployment-demo  \</span></span><br><span class="line"><span class="language-bash">    -p <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;strategy&quot;:&#123;&quot;rollingUpdate&quot;: &#123;&quot;maxSurge&quot;: 1, &quot;maxUnavailable&quot;:</span></span> </span><br><span class="line">    0&#125;&#125;&#125;&#125;&#x27;</span><br><span class="line">deployment.apps/deployment-demo patched</span><br></pre></td></tr></table></figure>

<p>随后，修改Pod模板触发deployment-demo资源的更新过程，进行第一批次更新后立即暂停该部署操作，则新生成的第一批Pod对象便是“金丝雀”，如图8-15所示。暂停Deployment资源的更新过程，需要将其spec.pause字段的值从false修改为true，这可通过修改资源规范后再次应用（apply）完成，也可通过kubectl rollout pause命令进行。例如，下面将deployment-demo资源的Pod模板中的容器镜像进行了修改以触发其更新，但同时使用shell操作符&amp;&amp;随后立即执行了暂停命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">VERSION=<span class="string">&#x27;v1.2&#x27;</span> envsubst &lt; deployment-demo.yaml | kubectl apply --record -f - &amp;&amp; \ </span></span><br><span class="line">     kubectl rollout pause deployments/deployment-demo</span><br><span class="line">deployment.apps/deployment-demo configured</span><br><span class="line">deployment.apps/deployment-demo paused</span><br></pre></td></tr></table></figure>

<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210133829935.png" alt="image-20220210133829935"></p>
<p>处于“暂停”状态中的Deployment资源的滚动状态也会暂停于某一批更新操作中，我们可以通过状态查看命令打印相关的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ kubectl rollout status deployments/deployment-demo</span><br><span class="line">Waiting for deployment &quot;deployment-demo&quot; rollout to finish: 1 out of 4 new replicas have been updated...</span><br></pre></td></tr></table></figure>

<p>相关的Pod列表也能够显示出旧版本ReplicaSet的所有Pod副本仍在正常运行，而同时新版本ReplicaSet对象也有了一个Pod实例，相关Service对象能够在其就绪后将一定比例的客户端流量引入到该Pod之上。运行足够长的一段时间后，若确认新版本应用没有必须通过回滚才能解决的问题，随后即可使用kubectl rollout resume命令继续后续更新步骤，以完成滚动更新过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ kubectl rollout resume deployments/deployment-demo</span><br><span class="line">deployment.apps/deployment-demo resumed</span><br></pre></td></tr></table></figure>

<p>kubectl rollout status命令监控到滚动更新过程完成后，即可通过deployment-demo资源及其作用域内的ReplicaSet和Pod对象的相关信息来了解其结果状态。然而，如果“金丝雀”遇险，回滚操作便成了接下来的紧要任务。</p>
<h2 id="StatefulSet控制器"><a href="#StatefulSet控制器" class="headerlink" title="StatefulSet控制器"></a>StatefulSet控制器</h2><p>无状态应用进程客户端的每次连接均可独立地处理，一次请求和响应即构成一个完整的事务，它们不受已完成的连接或现有其他连接的影响，且意外中断或关闭时仅需要重新建立连接即可，因而，无状态应用的Pod对象可随时由其他由同一模板创建的Pod平滑替代，这也正是Deployment控制器编排应用的方式。</p>
<h3 id="功能分析-1"><a href="#功能分析-1" class="headerlink" title="功能分析"></a>功能分析</h3><p>Kubernetes系统使用专用的StatefulSet控制器编排有状态应用。StatefulSet表示一组具有唯一持久身份和稳定主机名的Pod对象，任何指定该类型Pod的状态信息和其他弹性数据都存放在与该StatefulSet相关联的永久性磁盘存储空间中。<font color="red">StatefulSet旨在部署有状态应用和集群化应用，这些应用会将数据保存到永久性存储空间，它适合部署Kafka、MySQL、Redis、ZooKeeper以及其他需要唯一持久身份和稳定主机名的应用。</font><br><font color="red">一个典型的、完整可用的StatefulSet资源通常由两个组件构成：Headless Service和StatefulSet资源。</font><strong>Headless Service用于为各Pod资源固定、唯一的标识符生成可解析的DNS资源记录，StatefulSet用于编排Pod对象，并借助volumeClaimTemplate以静态或动态的PV供给方式为各Pod资源提供专有且固定的存储资源。</strong><br>对于拥有N个副本的StatefulSet资源来说，它会以{0…N–1}依次对各Pod对象进行编号及顺序创建，当前Pod对象就绪后才会创建下一个，删除则以相反的顺序进行，每个Pod删除完成后才会继续删除前一个。Pod资源的名称格式为$(statefulset name)-$(ordinal)，例如名称为web的StatefulSet资源生成的Pod对象的名称依次为web-0、web-1、web-2等，其域名后缀则由相关的Headless Service资源给出，格式为$(service name).$(namespace).svc.cluster.local。<font color="red">Kubernetes 1.7及其之后的版本也支持StatefulSet并行管理Pod对象。</font><br>配置了volumeClaimTemplate的StatefulSet资源会为每个Pod对象基于存储卷申请配置一个专用的PV，动静供给机制都支持，只是静态供给依赖于管理员的事前配置，如图8-16所示。而删除Pod对象甚至是StatefulSet控制器，并不会删除其相关的PV资源以确保数据可用性，因而Pod对象由节点故障或被驱逐等原因被重新调度至其他节点时，先前同名Pod实例专用的PV及其数据可安全复用。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210134157079.png" alt="image-20220210134157079">与Deployment略有不同的是，StatefulSet对应用规模的扩容意味着按索引顺序增加更多的Pod资源，而缩容则表示按逆序依次删除索引号最大的Pod资源，直到规模数量满足目标设定值为止。<font color="red">多数有状态应用都不支持规模性安全、快速的缩减操作，因此StatefulSet控制器不支持并行缩容机制，而是要严格遵守一次仅能终止一个Pod资源的法则，以免导致数据讹误。通常也意味着，存在错误且未恢复的Pod资源时，StatefulSet资源会拒绝启动缩容操作。此外，缩容操作导致的Pod资源终止同样不会删除其相关的PV，以确保数据可用。</font><br>StatefulSet也支持用户自定义的更新策略，它兼容支持之前版本中的OnDelete策略，以及新的RollingUpdate策略。RollingUpdate是默认的更新策略，更新过程中，更新顺序与终止Pod资源的顺序相同，由索引号最大的开始，终止一个Pod对象并完成其更新后继续进行前一个。此外，StatefulSet资源的滚动更新还支持分区（partition)机制，用户可基于某个用于分区的索引号对Pod资源进行分区，所有大于等于此索引号的Pod对象会被滚动更新，如图8-17所示，而小于此索引号的则不会被更新，而且，即便在此期间该范围内的某Pod对象被删除，它也一样会被基于旧版本的Pod模板重建。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210134256636.png" alt="image-20220210134256636"></p>
<p>若给定的分区号大于副本数量，意味着不存在大于此分区号的Pod资源索引号，因此，所有的Pod对象均不会被更新，这对于期望暂存发布、金丝雀发布或分段发布来说是有用的设定。</p>
<h3 id="StatefulSet基础应用"><a href="#StatefulSet基础应用" class="headerlink" title="StatefulSet基础应用"></a>StatefulSet基础应用</h3><p><font color="red">完整的StatefulSet资源需要由Headless Service和StatefulSet共同构成，StatefulSet资源规范中通过必选字段spec.serviceName指定关联的Headless类型的Service对象名称，但管理该Service是用户的责任，StatefulSet仅是强依赖于它，而不会自动管理它。</font>下面是StatefulSet资源的规范格式及简要说明。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>               <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span>                 <span class="comment"># 资源类型的特有标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>                   <span class="comment"># 资源名称，在作用域中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>              <span class="comment"># 名称空间；StatefulSet隶属名称空间级别</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">replicas</span> <span class="string">&lt;integer&gt;</span>              <span class="comment"># 期望的Pod副本数，默认为1</span></span><br><span class="line">  <span class="string">selector</span> <span class="string">&lt;object&gt;</span>               <span class="comment"># 标签选择器，需匹配Pod模板中的标签，必选字段</span></span><br><span class="line">  <span class="string">template</span> <span class="string">&lt;object&gt;</span>               <span class="comment"># Pod模板对象，必选字段</span></span><br><span class="line">  <span class="string">revisionHistoryLimit</span> <span class="string">&lt;integer&gt;</span>  <span class="comment"># 滚动更新历史记录数量，默认为10</span></span><br><span class="line">  <span class="string">updateStrategy</span> <span class="string">&lt;Object&gt;</span>         <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="string">type</span> <span class="string">&lt;string&gt;</span>                 <span class="comment"># 滚动更新类型，可用值有OnDelete和Rollingupdate</span></span><br><span class="line">    <span class="string">rollingUpdate</span> <span class="string">&lt;Object&gt;</span>        <span class="comment"># 滚动更新参数，专用于RollingUpdate类型</span></span><br><span class="line">      <span class="string">partition</span> <span class="string">&lt;integer&gt;</span>         <span class="comment"># 分区指示索引值，默认为0</span></span><br><span class="line">  <span class="string">serviceName</span>  <span class="string">&lt;string&gt;</span>           <span class="comment"># 相关的Headless Service的名称，必选字段</span></span><br><span class="line">  <span class="string">volumeClaimTemplates</span> <span class="string">&lt;[]Object&gt;</span> <span class="comment"># 存储卷申请模板</span></span><br><span class="line">    <span class="string">apiVersion</span> <span class="string">&lt;string&gt;</span>           <span class="comment"># PVC资源所属的API群组及版本，可省略</span></span><br><span class="line">    <span class="string">kind</span> <span class="string">&lt;string&gt;</span>                 <span class="comment"># PVC资源类型标识，可省略</span></span><br><span class="line">    <span class="string">metadata</span> <span class="string">&lt;Object&gt;</span>             <span class="comment"># 卷申请模板元数据</span></span><br><span class="line">    <span class="string">spec</span> <span class="string">&lt;Object&gt;</span>                 <span class="comment"># 期望的状态，可用字段同PVC</span></span><br><span class="line">  <span class="string">podManagementPolicy</span>  <span class="string">&lt;string&gt;</span>   <span class="comment"># Pod管理策略，默认的OrderedReady表示顺序创</span></span><br><span class="line">                                  <span class="comment">#建并逆序删除，另一可用值Parallel表示并行模式</span></span><br></pre></td></tr></table></figure>

<p>下面的配置清单示例中定义了一个名为demodb的Headless Service，以及一个同样名为demodb的StatefulSet资源，后者使用了存储卷申请模板，为Pod对象从fast-rbd存储类中请求动态供给并绑定PV。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demodb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9907</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demodb</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demodb</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demodb</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;demodb&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demodb</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demodb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ikubernetes/demodb:v0.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9907</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DEMODB_DATADIR</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;/demodb/data&quot;</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/status</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">db</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/status?level=full</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">db</span> </span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/demodb/data</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">storageClassName:</span> <span class="string">&quot;rbd&quot;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<p>示例中用到的demodb是一个仅用于测试的分布式键值存储系统，支持持久化数据存储，它由一个Leader和一到多个Followers组成，Followers定期从Leader查询并请求同步数据。Leader支持读写请求，而各Followers节点仅支持只读操作，它们会把接收到的写请求通过307响应码重定向给Leader节点。用于读写请求的URI分别为/get/KEY和/set/KEY，/status则用于输出状态，/status?level=full能够以200响应码返回持有的键数量，否则响应以500状态码返回。demodb仅可由StatefulSet控制器编排运行，并且在程序中将Leader的名称固定为demodb-0，依赖的Headless Service的名称也固定为demodb，因此StatefulSet和Headless Service资源的名称必须要使用demodb。<br>默认情况下，StatefulSet资源使用OrderedReady这一Pod管理策略，它以串行的方式逐一创建各Pod实例及相关的PV，下面在创建后打印的statefulsets/demodb资源详细描述中的各事件的时间点也反映了这种事实。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f demodb.yaml</span></span><br><span class="line">service/demodb created</span><br><span class="line">statefulset.apps/demodb created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe statefulsets/demodb</span>    </span><br><span class="line">Name:               demodb</span><br><span class="line">Namespace:          default</span><br><span class="line">Selector:           app=demodb</span><br><span class="line">Labels:             &lt;none&gt;</span><br><span class="line">Annotations:        Replicas:  2 desired | 2 total</span><br><span class="line">Update Strategy:    RollingUpdate</span><br><span class="line">  Partition:        0</span><br><span class="line">Pods Status:        2 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br><span class="line">……</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                    Message</span><br><span class="line">  ----    ------            ----   ----                    -------</span><br><span class="line">  Normal  SuccessfulCreate  2m22s  statefulset-controller  create Claim data-demodb-0 Pod demodb-0 in StatefulSet demodb success</span><br><span class="line">  Normal  SuccessfulCreate  2m22s  statefulset-controller  create Pod demodb-0 in StatefulSet demodb successful</span><br><span class="line">  Normal  SuccessfulCreate  97s    statefulset-controller  create Claim data-demodb-1 Pod demodb-1 in StatefulSet demodb success</span><br><span class="line">  Normal  SuccessfulCreate  97s    statefulset-controller  create Pod demodb-1 in StatefulSet demodb successful</span><br></pre></td></tr></table></figure>

<p>如前所述，由StatefulSet资源创建的Pod对象拥有固定且唯一的标识符，它们基于唯一的索引序号及相关的StatefulSet对象的名称生成，格式为&lt;statefulset name&gt;-&lt;ordinal index&gt;，例如上面事件信息中显示出由statefuls/demodb所创建的demodb-0和demodb-1两个Pod对象的名称即遵循该格式。事实上，这类Pod对象的主机名也与其资源名称相同，以demodb-0为例，下面的命令打出的主机名称正是Pod资源的名称标识。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> demodb-0 -- hostname</span></span><br><span class="line">demodb-0</span><br></pre></td></tr></table></figure>

<p>Headless Service的DNS名称解析会由ClusterDNS以该Service对象关联各Pod对象的IP地址加以响应。而StatefulSet创建的各Pod对象的名称则以相关Headless Service资源的DNS名称为后缀，具体格式为$(pod_name).$(svc_name).$(namespace).svc.cluster.local，例如demodb-0和demodb-1的资源名称分别为demodb-0.demodb.default.svc.cluster.local和demodb-1.demodb.default.svc.cluster.local。下面在一个新的专用终端创建一个临时的、基于Pod对象的交互客户端进行测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl run client --image=ikubernetes/admin-toolbox:v1.0 -it --<span class="built_in">rm</span> --<span class="built_in">command</span> -- /bin/sh</span></span><br></pre></td></tr></table></figure>

<p>首先，请求解析Pod的FQDN格式主机名称，它会返回相应Pod对象的IP地址；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@client /]# nslookup -query=A demodb-0.demodb</span><br><span class="line">Server:         10.96.0.10</span><br><span class="line">Address:        10.96.0.10#53</span><br><span class="line"></span><br><span class="line">Name:   demodb-0.demodb.default.svc.cluster.local</span><br><span class="line">Address: 10.244.1.208</span><br></pre></td></tr></table></figure>

<p>接着，创建一个测试文件，将之存储到demodb存储服务以发起数据存储测试。我们知道，CoreDNS默认以roundrobin的方式响应对同一个名称的解析请求，因而以名称方式发往demodb这一Headless Service的请求会轮询到demodb-0和demodb-1之上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@client /]# echo &quot;Advanced Kubernetes Practices&quot; &gt; /tmp/mydata</span><br><span class="line">[root@client /]# curl -L -XPUT -T /tmp/mydata http://demodb:9907/set/mydata</span><br><span class="line">WRITE completed</span><br></pre></td></tr></table></figure>

<p>调度至从节点（demodb-1）的写请求会自动重定向给主节点（demodb-0），且主节点数据存储完成后将自动同步至各个从节点；我们可从服务请求读取数据，或者直接从demodb-1读取数据，以进行测试。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@client /]# curl http://demodb:9907/get/mydata</span><br><span class="line">Advanced Kubernetes Practices</span><br><span class="line">[root@client /]# curl http://demodb-1.demodb:9907/get/mydata</span><br><span class="line">Advanced Kubernetes Practices</span><br></pre></td></tr></table></figure>

<p>demodb的所有节点会将数据存储在/demodb/data目录下，每个键被映射为一个子目录，数据存储在该子目录下的content文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> demodb-0 -- <span class="built_in">cat</span> /demodb/data/mydata/content</span></span><br><span class="line">Advanced Kubernetes Practices</span><br></pre></td></tr></table></figure>

<p>而各Pod对象的/demodb/data目录挂载到一个由statefulset/demodb存储卷申请模板创建的PVC之上，每个PVC又绑定在由存储类fast-rbd动态供给的PV之上。各PVC的名称由volumeClaimTemplate对象的名称与Pod对象的名称组合而成，格式为$(volume-ClaimTemplate_name).(Pod_name)，如下面的命令结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pvc -l app=demodb</span></span><br><span class="line">NAME   STATUS  VOLUME   CAPACITY   ACCESS MODES  STORAGECLASS  AGE</span><br><span class="line">data-demodb-0  Bound   pvc-de6e81c1-…   2Gi      RWO     fast-rbd       4m50s</span><br><span class="line">data-demodb-1  Bound   pvc-e95d67ca-…   2Gi     RWO      fast-rbd       4m5s</span><br></pre></td></tr></table></figure>

<p>StatefulSet资源作用域内的Pod资源因被节点驱逐，或因节点故障、应用规模缩容被删除，甚至是手动误删除时，它挂载的由存储卷申请模板创建的PVC卷并不会被删除。因而，经StatefulSet资源重建或规模扩容回原来的规模后，每个Pod对象依然有固定的标识符并可关联到此前的PVC存储卷上。</p>
<h3 id="扩缩容与滚动更新"><a href="#扩缩容与滚动更新" class="headerlink" title="扩缩容与滚动更新"></a>扩缩容与滚动更新</h3><p>StatefulSet资源也支持类似于Deployment资源的应用规模的扩容、缩容以及更新机制。扩缩容通过简单地修改StatefulSet资源的副本数来改动期望的Pod资源数量就能完成，例如，下面的命令能将statefulsets/demodb中的Pod副本数量扩展至4个。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl scale statefulsets/demodb --replicas=4</span></span><br><span class="line">statefulset.apps/demodb scaled</span><br></pre></td></tr></table></figure>

<p>StatefulSet资源的扩容过程与创建过程管理Pod对象的策略相同，默认为顺次进行，而且其名称中的序号也将以现有Pod资源的最后一个序号为基准向后进行。若定义了存储卷申请模板，扩容操作所创建的每个Pod对象也会各自关联所需要的PVC存储卷。与扩容操作相对，将其副本数量调低即能完成缩容操作，例如，下面的命令能够将StatefulSet资源demodb的副本数量缩减至3个。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl patch statefulsets/demodb -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;replicas&quot;:3&#125;&#125;&#x27;</span></span>      </span><br><span class="line">statefulset.apps/demodb patched</span><br></pre></td></tr></table></figure>

<p>缩容过程中终止Pod资源的默认策略与删除机制相似，它会根据Pod对象的可用索引号逆序逐一进行，直到余下的数量满足期望的值为止。因缩容而终止的Pod资源的存储卷并不会被删除，因此，如果缩减规模后再将其扩展回来，此前的数据依然可用，且Pod资源名称不变。<br>如前所述，在应用更新方面，StatefulSet资源自Kubernetes 1.7版本开始支持自动更新机制，其更新策略则由spec.updateStrategy字段定义，默认为RollingUpdate，即滚动更新。kubectl set image命令也支持修改StatefulSet资源上Pod模板中的容器镜像，因而，触发statefulsets/demodb上的应用升级可使用类似如下一条命令完成。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image statefulsets/demodb demodb-shard=<span class="string">&quot;ikubernetes/demodb:v0.2&quot;</span></span></span><br><span class="line">statefulset.apps/demodb image updated</span><br></pre></td></tr></table></figure>

<p>滚动更新StatefulSet资源的Pod对象以逆序的方式从其最大索引编号逐一进行，滚动条件为当前更新循环中的各个新Pod资源已然就绪。通常，对于主从复制类的集群应用来说，这种方式能保证担当主节点的Pod资源在最后进行更新，以确保其兼容性。例如，触发statefulsets/demodb更新后，可以看到类似如下命令中首先更新索引编号最大的Pod对象demodb-1的操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demodb</span></span><br><span class="line">NAME       READY   STATUS           RESTARTS      AGE</span><br><span class="line">demodb-0   1/1     Running             0          5m42s</span><br><span class="line">demodb-1   1/1     Running             0          4m42s</span><br><span class="line">demodb-2   0/1     ContainerCreating   0          5s</span><br></pre></td></tr></table></figure>

<p>StatefulSet资源滚动更新过程中的状态同样可以使用kubectl rollout history命令获取。更新完成后，我们可使用如下命令，确认相关Pod对象使用的容器镜像都已经变更为指定的新版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demodb -o \</span></span><br><span class="line"><span class="language-bash">    jsonpath=<span class="string">&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;: &#123;.spec.containers[0].image&#125;&#123;&quot;\n&quot;&#125;</span></span></span><br><span class="line">    &#123;end&#125;&#x27;</span><br><span class="line">demodb-0: ikubernetes/demodb:v0.2</span><br><span class="line">demodb-1: ikubernetes/demodb:v0.2</span><br><span class="line">demodb-2: ikubernetes/demodb:v0.2</span><br></pre></td></tr></table></figure>

<p>滚动更新过程不会影响相应的数据服务，此前的生成的数据键mydata及其数据在更新过程中同样可以正常访问，这在8.4.2节的交互式客户端测试结果中能够得到验证。但是，更新demodb-0期间写操作会有短暂的不可用区间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@client /]# curl http://demodb:9907/get/mydata</span><br><span class="line">Advanced Kubernetes Practices</span><br></pre></td></tr></table></figure>

<p>进一步地，StatefulSet资源支持使用分区编号（.spec.updateStrategy.rollingUpdate.partition字段值）将其Pod对象分为两个部分，仅那些索引号大于等于分区编号的Pod对象会被更新，默认的分区编号为0，因而滚动更新时，所有的Pod对象都是待更新目标。于是，在更新操作之前，将partition字段的值置为Pod资源的副本数量N（或大于该值）会使得所有的Pod资源（索引号区间为0到N–1）都不再处于可直接更新的分区之内，那么这之后设定的更新操作不会真正执行而是被“暂存”起来，直到降低分区编号至现有Pod资源索引号范围内，才开始触发真正的滚动更新操作。来看下面的例子。<br>首先，将statefulsets/demodb的分区别编号设置为现有的Pod数量值3：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl patch statefulsets/demodb -p \</span></span><br><span class="line"><span class="language-bash">       <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;rollingUpdate&quot;:&#123;&quot;partition&quot;:3&#125;&#125;&#125;&#125;&#x27;</span></span></span><br><span class="line">statefulset.apps/demodb patched</span><br></pre></td></tr></table></figure>

<p>而后，更新statefulsets/demodb的Pod模板中的容器镜像为ikubernetes/demodb:v0.3。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image statefulsets/demodb demodb-shard=<span class="string">&#x27;ikubernetes/demodb:v0.3&#x27;</span></span></span><br><span class="line">statefulset.apps/demodb image updated</span><br></pre></td></tr></table></figure>

<p>接下来，我们验证出最大编号的Pod对象demodb-2的容器镜像并未因执行更新而发生变化，根据更新策略来说，这意味着其他更小索引号的Pod对象更不会发生任何变动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods/demodb-2 -o jsonpath=<span class="string">&#x27;&#123;.spec.containers[0].image&#125;&#x27;</span></span>                                                  </span><br><span class="line">ikubernetes/demodb:v0.2</span><br></pre></td></tr></table></figure>

<p>再接着，将分区编号降为statefulsets/demodb上的最大索引编号2之后可以验证，仅demodb-2执行了更新操作；如下第二条命令可于分区编号更改后，略等一段时间后再执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl patch statefulsets/demodb -p \</span></span><br><span class="line"><span class="language-bash">      <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;updateStrategy&quot;:&#123;&quot;rollingUpdate&quot;:&#123;&quot;partition&quot;:2&#125;&#125;&#125;&#125;&#x27;</span></span></span><br><span class="line">statefulset.apps/demodb patched</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demodb -o \</span></span><br><span class="line"><span class="language-bash">      jsonpath=<span class="string">&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;: &#123;.spec.containers[0].image&#125;</span></span></span><br><span class="line">      &#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span><br><span class="line">demodb-0: ikubernetes/demodb:v0.2</span><br><span class="line">demodb-1: ikubernetes/demodb:v0.2</span><br><span class="line">demodb-2: ikubernetes/demodb:v0.3</span><br></pre></td></tr></table></figure>

<p>demodb-2就像是一只“金丝雀”，安然渡过一定时长的测试期间后，我们便可继续其他Pod资源的更新操作。若后续待更新的Pod资源数量较少，我们可直接将partition字段的值设置为0，从而让StatefulSet逆序完成后续所有Pod资源的更新。而待更新的Pod资源较多时，也可以将Pod资源以线性或指数级增长的方式来分阶段完成更新操作，操作过程仅仅是分多次更改partition字段值，例如将statefulsets/demodb控制器的分区号以较慢的节奏依次设置为1和0来完成剩余Pod资源的线性分步更新，如图8-18所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210135151879.png" alt="image-20220210135151879"></p>
<p><font color="red">StatefulSet支持的另一更新策略是OnDelete，这类似于手动更新机制，它以用户的手动删除操作为触发时间点完成应用更新。</font></p>
<h3 id="StatefulSet的局限性"><a href="#StatefulSet的局限性" class="headerlink" title="StatefulSet的局限性"></a>StatefulSet的局限性</h3><p>应用于生产环境的分布式有状态应用的各实例间的关系并非像本节示例中的demodb那样简单，它们在拓扑上通常是基于复杂分布式协议的成员关系，例如ZooKeeper集群成员基于ZAB协议的Leader/Follower关系以及etcd集群成员基于Raft协议的对等（peer）关系等。这些分布式有状态应用的内生拓扑结构存在区别，对持久存储的依赖需求也有所不同，并且集群成员的增加、减少以及在故障后的恢复操作通常都会依赖一系列复杂且精细的步骤才能完成，于是StatefulSet控制器无法为其封装统一、标准的管理操作。于是，用户就不得不配置某个特定的有状态应用，在其YAML配置清单中通过“复杂的运维代码”手动编写相关的运维逻辑，例如下面的这段代码便是以StatefuSet资源来编排etcd应用时，在其Pod模板中编写的仅实现了简单功能的运维代码。这看上去既奇怪又低效——每个用户不得不学习相关应用的运维知识并重复“造轮子”，而StatefulSet对此却也爱莫能助。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;-ecx&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">   IP=$(hostname -i)</span></span><br><span class="line"><span class="string">   PEERS=&quot;&quot;</span></span><br><span class="line"><span class="string">   for i in $(seq 0 $(($&#123;CLUSTER_SIZE&#125; - 1))); do</span></span><br><span class="line"><span class="string"></span><span class="string">PEERS=&quot;$&#123;PEERS&#125;$&#123;PEERS:+,&#125;$&#123;SET_NAME&#125;-$&#123;i&#125;=http://$&#123;SET_NAME&#125;-$&#123;i&#125;.$&#123;SET_</span></span><br><span class="line"><span class="string">NAME&#125;:2380&quot;</span></span><br><span class="line">   <span class="string">done</span></span><br><span class="line">   <span class="comment"># start etcd. If cluster is already initialized the `--initial-*` options </span></span><br><span class="line">   <span class="string">will</span> <span class="string">be</span> <span class="string">ignored.</span></span><br><span class="line">   <span class="string">exec</span> <span class="string">etcd</span> <span class="string">--name</span> <span class="string">$&#123;HOSTNAME&#125;</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--listen-peer-urls</span> <span class="string">http://$&#123;IP&#125;:2380</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--listen-client-urls</span> <span class="string">http://$&#123;IP&#125;:2379,http://127.0.0.1:2379</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--advertise-client-urls</span> <span class="string">http://$&#123;HOSTNAME&#125;.$&#123;SET_NAME&#125;:2379</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--initial-advertise-peer-urls</span> <span class="string">http://$&#123;HOSTNAME&#125;.$&#123;SET_NAME&#125;:2380</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--initial-cluster-token</span> <span class="string">etcd-cluster-1</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--initial-cluster</span> <span class="string">$&#123;PEERS&#125;</span> <span class="string">\</span></span><br><span class="line">     <span class="string">--initial-cluster-state</span> <span class="string">new</span> <span class="string">\</span></span><br><span class="line">      <span class="string">--data-dir</span> <span class="string">/var/run/etcd/default.etcd</span></span><br></pre></td></tr></table></figure>

<p>面对这种境况，CoreOS为Kubernetes引入了一个称为Operator的新概念和新组件，它借助CRD（Customed Resource Definition）创建自定义资源类型来完整描述某个有状态应用集群，并相应创建自定义的控制器来编排这些自定义资源类型所创建的各个资源对象。简单来讲，Operator就是一个开发规范和SDK，它合理地利用Kubernetes API的CRD功能扩展出二级抽象，又巧妙地回归到Kubernetes的“控制器”逻辑，从而提供了一个有状态应用的实现接口，用户可利用它开发专用于管理某个特定有状态应用的运维控制器，并按需回馈给社区。<br>目前，Operator社区中涌现了大量的特定实现，例如coreos/etcd-operator、oracle/mysql-operator和jenkinsci/jenkins-operator等，有些分布式应用的可用Operator实现甚至不止一种。Operator官方维护着etcd、Rook、Prometheus和Vault几个Operator，并通过<a target="_blank" rel="noopener" href="https://github.com/operator-framework/awesome-operators%E7%BB%B4%E6%8A%A4%E7%9D%80%E4%B8%BB%E6%B5%81%E7%9A%84Operator%E9%A1%B9%E7%9B%AE%E5%88%97%E8%A1%A8%E3%80%82%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%EF%BC%8C%E5%9C%A8Kubernetes%E7%B3%BB%E7%BB%9F%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F%E6%98%AF%E4%BD%BF%E7%94%A8Operator%EF%BC%8C%E8%80%8C%E9%9D%9E%E8%87%AA%E5%AE%9A%E4%B9%89StatefulSet%E8%B5%84%E6%BA%90%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%86%E5%9C%A8%E7%AC%AC12%E7%AB%A0%E4%B8%AD%E5%86%8D%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8EOperator%E7%9A%84%E7%94%A8%E6%B3%95%E3%80%82">https://github.com/operator-framework/awesome-operators维护着主流的Operator项目列表。这意味着，在Kubernetes系统上部署分布式有状态应用的常用方式是使用Operator，而非自定义StatefulSet资源，我们将在第12章中再举例说明Operator的用法。</a></p>
<h2 id="DaemonSet控制器"><a href="#DaemonSet控制器" class="headerlink" title="DaemonSet控制器"></a>DaemonSet控制器</h2><p>Deployment仅用于保证在集群上精确运行多少个工作负载的实例，但有些系统级应用却需要在集群中的每个节点上精确运行单个实例，这就是DaemonSet控制器的核心功用所在。系统级工作负载的副本数量取决于集群中的节点数，而非由用户通过replicas进行定义，更重要的是，后续新加入集群的工作节点也会由DaemonSet对象自动创建并运行为一个相关Pod，而从集群移除节点时，该类Pod对象也将被自动回收且无须重建。此外，管理员也可以使用节点选择器或节点标签指定仅在部分具有特定特征的节点上运行指定的Pod对象。<br>简单来说，DaemonSet就是一种特殊的控制器，它有着特定的应用场景，通常用于运行那些执行系统级操作任务的应用，例如：<br>▪运行集群存储的守护进程，例如在每个节点上运行的glusterd可用于接入Gluster集群；<br>▪在每个节点上运行日志收集守护进程，例如fluentd、filebeat和logstash等；<br>▪在每个节点上运行监控系统的代理守护进程，例如Prometheus Node Exporter、collectd、Datadog agent、New Relic agent，或Ganglia gmond等。提示<br>以kubeadm部署的Kubernetes集群上，kube-proxy便是由DaemonSet控制器所编排；另外，Flannel网络插件运行在各节点之上的代理程序也使用了该类型的控制器。<br>既然是需要在集群内的每个节点或部分节点运行工作负载的单个实例，那么，也就可以把应用直接运行为工作节点上的系统级守护进程，只是这么一来也就失去了托管给Kubernetes所带来的便捷性。另外，当必须把Pod对象以单实例运行在固定的几个节点并且需要先于其他Pod启动时，才有必要使用DaemonSet控制器，否则就应该使用Deployment控制器。</p>
<h3 id="DaemonSet资源基础应用"><a href="#DaemonSet资源基础应用" class="headerlink" title="DaemonSet资源基础应用"></a>DaemonSet资源基础应用</h3><p>DaemonSet是标准的API资源类型，它的spec字段中嵌套使用的字段也需要使用selector、template和minReadySeconds，并且它们各自的功能和用法基本相同，但DaemonSet不支持使用replicas，毕竟DaemonSet不是基于期望的副本数，而是基于节点数量来控制Pod资源数量，但template是必选字段。另外，DaemonSet也支持策略式更新，它支持OnDelete和RollingUpdate两种策略，也能够为滚动更新保存修订记录。DaemonSet资源的简要配置规范如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>              <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>                  <span class="comment"># 资源类型特有标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>                  <span class="comment"># 资源名称，在作用域中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>             <span class="comment"># 名称空间；DaemonSet资源隶属名称空间级别</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">minReadySeconds</span> <span class="string">&lt;integer&gt;</span>      <span class="comment"># Pod就绪后多少秒内任一容器无崩溃方可视为“就绪”</span></span><br><span class="line">  <span class="string">selector</span> <span class="string">&lt;object&gt;</span>              <span class="comment"># 标签选择器，必须匹配template字段中Pod模板的标签</span></span><br><span class="line">  <span class="string">template</span> <span class="string">&lt;object&gt;</span>              <span class="comment"># Pod模板对象</span></span><br><span class="line">  <span class="string">revisionHistoryLimit</span> <span class="string">&lt;integer&gt;</span> <span class="comment"># 滚动更新历史记录数量，默认为10</span></span><br><span class="line">  <span class="string">updateStrategy</span> <span class="string">&lt;Object&gt;</span>        <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="string">type</span> <span class="string">&lt;string&gt;</span>                <span class="comment"># 滚动更新类型，可用值有OnDelete和Rollingupdate</span></span><br><span class="line">    <span class="string">rollingUpdate</span> <span class="string">&lt;Object&gt;</span>       <span class="comment"># 滚动更新参数，专用于RollingUpdate类型</span></span><br><span class="line">      <span class="string">maxUnavailable</span> <span class="string">&lt;string&gt;</span>    <span class="comment"># 更新期间可比期望的Pod数量缺少的数量或比例</span></span><br></pre></td></tr></table></figure>

<p>下面的资源清单（daemonset-demo.yaml）示例中定义了一个DaemonSet资源，用于在每个节点运行一个Prometheus node_exporter进程以收集节点级别的监控数据，该进程共享节点的Network和PID名称空间。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">daemonset-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">node-exporter</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">      <span class="attr">component:</span> <span class="string">node-exporter</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">prometheus-node-exporter</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">prometheus</span></span><br><span class="line">        <span class="attr">component:</span> <span class="string">node-exporter</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">prom/node-exporter:v0.18.0</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">prometheus-node-exporter</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">prom-node-exp</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">9100</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">9100</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">prom-node-exp</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">&#x27;/metrics&#x27;</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">prom-node-exp</span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">hostPID:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>Prometheus node_exporter默认监听TCP协议的9100端口，基于HTTP协议及/metrics输出指标数据，我们可以将daemonset-demo创建到集群之上后，向任一节点IP发起访问，进行测试来验证。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">~$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">daemonset-demo.yaml</span> </span><br><span class="line"><span class="string">daemonset.apps/daemonset-demo</span> <span class="string">created</span></span><br><span class="line"><span class="string">~$</span> <span class="string">curl</span> <span class="string">-s</span> <span class="number">172.29</span><span class="number">.9</span><span class="number">.11</span><span class="string">:9100/metrics</span> </span><br><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line"><span class="string">go_gc_duration_seconds&#123;quantile=&quot;0&quot;&#125;</span> <span class="number">8.729e-06</span></span><br><span class="line"><span class="string">go_gc_duration_seconds&#123;quantile=&quot;0.25&quot;&#125;</span> <span class="number">3.1308e-05</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>

<p>DaemonSet资源在其详细描述信息输出了相关Pod对象的状态，包括应该在集群上运行的副本数和实际运行的副本数及相关的状态等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Desired Number of Nodes Scheduled: 3</span><br><span class="line">Current Number of Nodes Scheduled: 3</span><br><span class="line">Number of Nodes Scheduled with Up-to-date Pods: 3</span><br><span class="line">Number of Nodes Scheduled with Available Pods: 3</span><br><span class="line">Number of Nodes Misscheduled: 0</span><br><span class="line">Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed</span><br></pre></td></tr></table></figure>

<p>偶尔也存在需要将Pod对象以单一实例形式运行在集群中的部分工作节点，例如有些拥有特殊硬件节点需要运行特定的监控代理程序等。这仅需要在Pod模板的spec字段中嵌套使用nodeSelector字段，并确保其值定义的标签选择器与部分特定工作节点的标签匹配即可。<br>另外，考虑到大多数系统级应用的特殊性，DaemonSet资源的各Pod实例通常需要被单独访问而不能隐藏在某个Service对象之后，例如无论是监控代理程序或日志采集代理程序所在的节点都需要由其服务器端各自识别并单独进行通信。因此，各节点上的Pod应用推送数据至服务端，使用Headless Service或者直接让Pod应用共享节点的网络名称空间，并监听一个端口（例如node_exporter的9100端口）是满足这种需求的常见做法。</p>
<h3 id="DaemonSet更新策略"><a href="#DaemonSet更新策略" class="headerlink" title="DaemonSet更新策略"></a>DaemonSet更新策略</h3><p>DaemonSet自Kubernetes 1.6版本起也开始支持更新机制，相关配置定义在spec.update-Strategy嵌套字段中。目前，它支持RollingUpdate和OnDelete两种更新策略。<br>▪RollingUpdate为默认的策略，工作逻辑类似于Deployment控制器上的同名策略，不过节点难以临时弹性增设，因而DaemonSet仅能支持使用maxUnavailabe属性定义最大不可用Pod资源副本数（默认值为1）。<br>▪Ondelete是在相应节点的Pod资源被删除后重建为新版本，从而允许用户手动编排更新过程。<br>将此前创建的daemonset-demo中Pod模板的容器镜像修改为prom/node-exporter:v0.18.1便能测试其更新过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image daemonsets/daemonset-demo \</span></span><br><span class="line"><span class="language-bash">          prometheus-node-exporter=<span class="string">&quot;prom/node-exporter:v0.18.1&quot;</span></span></span><br><span class="line">daemonset.apps/daemonset-demo image updated</span><br></pre></td></tr></table></figure>

<p>按照默认的RollingUpdate策略，daemonset-demo资源将采用一次更新一个Pod对象，待新建Pod对象就绪后再更新下一个Pod对象的方式进行，资源相关的事件中会详细展示出其更新过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe daemonsets daemonsets/daemonset-demo</span></span><br><span class="line">……</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From                  Message</span><br><span class="line">  ----    ------            ----   ----                  -------</span><br><span class="line">  Normal  SuccessfulDelete  7m44s  daemonset-controller  Deleted pod: daemonset-demo-btl8x</span><br><span class="line">  Normal  SuccessfulCreate  7m39s  daemonset-controller  Created pod: daemonset-demo-5z8q8</span><br><span class="line">  Normal  SuccessfulDelete  6m6s   daemonset-controller  Deleted pod: daemonset-demo-hf9lv</span><br><span class="line">  Normal  SuccessfulCreate  6m3s   daemonset-controller  Created pod: daemonset-demo-bw5qp</span><br><span class="line">  Normal  SuccessfulDelete  4m34s  daemonset-controller  Deleted pod: daemonset-demo-gzxd2</span><br><span class="line">  Normal  SuccessfulCreate  4m27s  daemonset-controller  Created pod: daemonset-demo-l9qgg</span><br></pre></td></tr></table></figure>

<p>规模较大的集群中，我们也可以增大RollingUpdate策略中maxUnavailable属性的值来加快其滚动过程，例如设置为20%、25%甚至是50%等。DaemonSet控制器的滚动更新机制同样支持借助minReadySeconds来自定义Pod对象必须处于“就绪”状态多少时长才能视作“可用”。另外，DaemonSet资源的更新操作也支持回滚，包括回滚至REVISION历史记录中的任何一个指定的版本等。<br>而对于需要精心组织每个实例更新过程才能确保其升级过程可靠进行的应用来说，我们就不得不使用OnDelete策略来替换默认的RollingUpdate策略。OnDelete策略的实施逻辑较为简单，这里就不再给出具体操作过程。</p>
<h2 id="Job控制器"><a href="#Job控制器" class="headerlink" title="Job控制器"></a>Job控制器</h2><p>与Deployment及DaemonSet控制器管理的守护进程类的服务应用所不同的是，Job控制器常用于管理那些运行一段时间就能够“完成”的任务，例如计算或备份操作。容器中的进程正常运行完成而结束后不需要再重启，而是由控制器把该Pod对象置于Completed（完成）状态，并能够在超过用户指定的生存周期后由系统自行删除。但是，若容器中的进程因“错误”（而非完成）而终止，则需要依据配置来确定其重启与否，通常，未运行完成的Pod对象因其所在的节点故障而意外终止后会被重新创建。Job控制器的Pod对象的状态转换如图8-19所示。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210135515103.png" alt="image-20220210135515103"></p>
<p>实践中，有的作业任务可能需要运行不止一次，用户可以配置它们以串行或并行方式运行。总结起来，这种类型的Job资源对象主要有两种。<br>▪单工作队列的串行式Job：将一个作业串行执行多次直到满足期望的次数，如图8-20所示；这种Job也可理解为并行度为1的作业执行方式，在某个时刻仅有一个Pod资源对象存在。</p>
<p><img src="/blog/2022/02/10/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%8E%A7%E5%88%B6%E5%99%A8/image-20220210135537338.png" alt="image-20220210135537338"></p>
<p>▪多工作队列的并行Job：这种方式中，可以设置工作队列数（即作业数），每个队列仅负责运行一个作业，如图8-21中的左图所示；也可以用有限的工作队列运行较多的作业，即工作队列数少于总作业数，它相当于运行着多个串行作业队列。如图8-21中的右图所示，工作队列数即同时可运行的Pod资源数。</p>
<p>具体运行中，我们需要根据作业的特性来选择合适的并行度及编排策略，对于有严格次序要求或者拥有“层进”特性的作业，单工作队列串行执行是其唯一可行的选择，反之，适度的并行能够提升作业运行速度。</p>
<h3 id="Job资源基础应用"><a href="#Job资源基础应用" class="headerlink" title="Job资源基础应用"></a>Job资源基础应用</h3><p>作为标准的API资源类型之一，Job规范同样由apiVersion、kind、metadata和spec等字段组成，由系统自行维护的status字段用于保存资源的当前状态，该资源的基本定义格式如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span>      <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>                  <span class="comment"># 资源类型特有标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>            <span class="comment"># 资源名称，在作用域中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>       <span class="comment"># 名称空间；Job资源隶属名称空间级别</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">selector</span> <span class="string">&lt;object&gt;</span>        <span class="comment"># 标签选择器，必须匹配template字段中Pod模板的标签</span></span><br><span class="line">  <span class="string">template</span> <span class="string">&lt;object&gt;</span>        <span class="comment"># Pod模板对象</span></span><br><span class="line">  <span class="string">completions</span> <span class="string">&lt;integer&gt;</span>    <span class="comment"># 期望的成功完成的作业次数，成功运行结束的Pod数量</span></span><br><span class="line">  <span class="string">ttlSecondsAfterFinished</span>  <span class="string">&lt;integer&gt;</span>  <span class="comment"># 终止状态作业的生存时长，超期将被删除</span></span><br><span class="line">  <span class="string">parallelism</span>  <span class="string">&lt;integer&gt;</span>   <span class="comment"># 作业的最大并行度，默认为1</span></span><br><span class="line">  <span class="string">backoffLimit</span> <span class="string">&lt;integer&gt;</span>   <span class="comment"># 将作业标记为Failed之前的重试次数，默认为6</span></span><br><span class="line">  <span class="string">activeDeadlineSeconds</span>  <span class="string">&lt;integer&gt;</span>    <span class="comment"># 作业启动后可处于活动状态的时长</span></span><br></pre></td></tr></table></figure>

<p>定义Job资源时，spec字段内嵌的必要字段仅有template一个，Job会为其Pod对象自动添加job-name=JOB_NAME和controller-uid=UID标签，并使用标签选择器完成对controller-uid标签的关联。例如，下面的资源清单（job-example.yaml）中定义了一个名为job-demo的Job资源：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">job-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myjob</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">alpine:3.11</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 60&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">3600</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>注意<br>Pod模板中的spec.restartPolicy默认为Always，这对Job控制器来说并不适用，因此必须在Pod模板中显式设定restartPolicy属性的值为Never或OnFailure。<br>出于运行一段时长后可终止的目的，该示例中的Pod模板通过借助alpine镜像运行一个睡眠60秒（sleep 60）的应用来模拟该功能。将job-demo资源创建到集群之上便可查看相关的任务状态，如下第二条命令显示的简要状态信息中，COMPLETIONS字段（m/n）表示期望完成的作业数（n）和已经完成的作业数（m），DURATION为作业完成所运行的时长。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f job-demo.yaml</span> </span><br><span class="line">job.batch/job-demo created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get <span class="built_in">jobs</span>/job-demo</span></span><br><span class="line">NAME     COMPLETIONS      DURATION     AGE</span><br><span class="line">job-demo    1/2             66s        66s</span><br></pre></td></tr></table></figure>

<p>相关的Pod资源能够以Job资源的名称为标签进行筛选，对于串行运行的作业来说，不同时刻能筛选出的Pod数量可能存在差异。下面的显示命令运行于第一次作业完成后，而第二次作业刚启动之时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l job-name=job-demo</span></span><br><span class="line">NAME            READY    STATUS        RESTARTS   AGE</span><br><span class="line">job-demo-lb4vw   0/1     Completed     0          68s</span><br><span class="line">job-demo-xn7zq   1/1     Running       0          6s</span><br></pre></td></tr></table></figure>

<p>Job资源的详细描述中能够获得进一步的信息，包括为Pod自动添加的标签、使用的标签选择器、作业并行度、各Pod的相关状态及相应事件等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl describe <span class="built_in">jobs</span>/job-demo</span>        </span><br><span class="line">Name:                     job-demo</span><br><span class="line">Namespace:                default</span><br><span class="line">Selector:                 controller-uid=42101d29-8a2b-45bf-b003-13af317c1300</span><br><span class="line">Labels:                   controller-uid=42101d29-8a2b-45bf-b003-13af317c1300</span><br><span class="line">                          job-name=job-demo</span><br><span class="line">Annotations:              Parallelism:  1</span><br><span class="line">Completions:              2</span><br><span class="line">Start Time:               Sun, 20 Sep 2020 12:00:33 +0800</span><br><span class="line">Completed At:             Sun, 20 Sep 2020 12:02:37 +0800</span><br><span class="line">Duration:                 2m4s</span><br><span class="line">Active Deadline Seconds:  300s</span><br><span class="line">Pods Statuses:            0 Running / 2 Succeeded / 0 Failed</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:  controller-uid=42101d29-8a2b-45bf-b003-13af317c1300</span><br><span class="line">           job-name=job-demo</span><br><span class="line">  Containers:</span><br><span class="line">   ……</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason            Age    From            Message</span><br><span class="line">  ----    ------            ----   ----            -------</span><br><span class="line">  Normal  SuccessfulCreate  3m51s  job-controller  Created pod: job-demo-lb4vw</span><br><span class="line">  Normal  SuccessfulCreate  2m49s  job-controller  Created pod: job-demo-xn7zq</span><br><span class="line">  Normal  Completed         107s   job-controller  Job completed</span><br></pre></td></tr></table></figure>

<p>由上面命令结果可知，Job的默认使用的并行度为1，这也是为什么上面示例中的两个作业要先后执行而非同时执行的原因，这意味着多次作业需要以串行方式运行，作业的总时长至少要相当于各任务各自的执行时长之和。<br>Job资源运行完成后便不再占用系统资源，用户可将其按需保留、手动删除或者设置相应属性执行自动删除操作。job-demo资源留给用户检查相关资源信息的时间窗口为3600秒（spec.ttlSecondsAfterFinished），超出该时长后，该作业将由控制器自行删除，而未定义该字段的作业将会一直保留。<br>现实中的作业未必能有精确的运行时长，若某Job资源的Pod程序因存在Bug或其他原因导致的作业无法“完成”并退出，而其restatPolicy又定义为了重启，则该Pod可能会一直处于重启和错误的循环当中。为此，Job控制器提供了两个属性用于抑制这种情况的发生：<br>▪.spec.activeDeadlineSeconds <integer>：用于为Job指定最大活动时间长度，超出此时长的作业将被终止并标记为失败；<br>▪.spec.backoffLimit <integer>：将作业标记为失败状态之前的重试次数，默认值为6。<br>由此可见，任务的总体可运行时长（activeDeadlineSeconds）也必须足够容纳作业的预测的总体运行时长。另外，不存在严格意义上先后次序的多次作业，适度的并行将能够显著提升其运行速度。</integer></integer></p>
<h3 id="并行式Job与扩容机制"><a href="#并行式Job与扩容机制" class="headerlink" title="并行式Job与扩容机制"></a>并行式Job与扩容机制</h3><p>将并行度属性.spec.parallelism设置为大于1的值，并设置总任务数.spec.completion属性大于并行度，便能够让Job资源以并行方式运行多任务。下面示例中定义了一个2路并行且总体运行10次任务的Job资源规范：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">job-para-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myjob</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">alpine:3.11</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;sleep 60&quot;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">3600</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">1200</span></span><br></pre></td></tr></table></figure>

<p>按照并行Job的运行法则，job-para-demo资源将允许最多同时运行两个Pod，这相当于存在两路虚拟作业管道，每个虚拟管道串行运行分配而来的Job。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f job-para-demo.yaml</span>                             </span><br><span class="line">job.batch/job-para-demo created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l job-name=job-para-demo</span></span><br><span class="line">NAME                 READY    STATUS     RESTARTS    AGE</span><br><span class="line">job-para-demo-8fxj2   1/1     Running     0          10s</span><br><span class="line">job-para-demo-mblzj   1/1     Running     0          10s</span><br></pre></td></tr></table></figure>

<p>Job资源的作业并行度支持运行时修改，因而，我们还能够通过修改parallelism属性的值来动态提升作业并行度以实现Job资源扩容之目的。例如，下面的命令将尚未完成的job-para-demo并行度从2提升到了5：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl patch <span class="built_in">jobs</span>/job-para-demo -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;parallelism&quot;:5&#125;&#125;&#x27;</span></span></span><br><span class="line">job.batch/job-para-demo patched</span><br></pre></td></tr></table></figure>

<p>于是，pod-para-demo资源的并行度提升为5，Kubernetes系统为job-para-demo资源同时运行的Pod资源数量也随之提升到了5个，例如，对于刚启动不久的job-para-demo资源执行如下面的命令可生成类似如下运行于5个Pod作业的结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l job-name=job-para-demo -w</span></span><br><span class="line">NAME                  READY   STATUS      RESTARTS   AGE</span><br><span class="line">job-para-demo-8fxj2   0/1     Completed   0          82s</span><br><span class="line">job-para-demo-d6z98   1/1     Running     0          7s</span><br><span class="line">job-para-demo-hbh99   1/1     Running     0          20s</span><br><span class="line">job-para-demo-lfvj5   1/1     Running     0          7s</span><br><span class="line">job-para-demo-mblzj   0/1     Completed   0          82s</span><br><span class="line">job-para-demo-nq8h7   1/1     Running     0          7s</span><br><span class="line">job-para-demo-ss9t4   1/1     Running     0          20s</span><br></pre></td></tr></table></figure>

<p>另外，Job资源详细描述中，相关事件的发生时间点也是辅助了解Pod对象并行运行状态的有效辅助信息。</p>
<h2 id="CronJob控制器"><a href="#CronJob控制器" class="headerlink" title="CronJob控制器"></a>CronJob控制器</h2><p>CronJob资源用于管理Job资源的运行时间，它允许用户在特定的时间或以指定的间隔运行Job，它适合自动执行特定的任务，例如备份、报告、发送电子邮件或清理类的任务等。换句话说，CronJob能够以类似于Linux操作系统的周期性任务作业计划（crontab）的方式控制其运行的时间点及周期性运行的方式：<br>▪仅在未来某时间点将指定的作业运行一次；<br>▪在指定的周期性时间点重复运行指定的作业。<br>CronJob资源使用的时间格式类似于Linux系统上的crontab，稍具不同之处是，CronJob资源在指定时间点时，通配符“?”和“*”的意义相同，它们都表示任何可用的有效值。<br>CronJob资源使用Job对象来完成任务，它每次运行时都会创建一个Job对象，并使用类似于Job资源的创建、管理和扩容方式。Cronjob也是Kubernetes系统标准的API资源，其资源规范的基本格式如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span>                <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span>                            <span class="comment"># 资源类型特有标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>                          <span class="comment"># 资源名称，在作用域中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>                     <span class="comment"># 名称空间；CronJob资源隶属名称空间级别</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">jobTemplate</span>  <span class="string">&lt;Object&gt;</span>                  <span class="comment"># Job作业模板，必选字段</span></span><br><span class="line">    <span class="string">metadata</span> <span class="string">&lt;object&gt;</span>                    <span class="comment"># 模板元数据</span></span><br><span class="line">    <span class="string">spec</span> <span class="string">&lt;object&gt;</span>                        <span class="comment"># 作业的期望状态</span></span><br><span class="line">  <span class="string">schedule</span> <span class="string">&lt;string&gt;</span>                      <span class="comment"># 调度时间设定，必选字段</span></span><br><span class="line">  <span class="string">concurrencyPolicy</span>  <span class="string">&lt;string&gt;</span>     <span class="comment"># 并发策略，可用值有Allow、Forbid和Replace</span></span><br><span class="line">  <span class="string">failedJobsHistoryLimit</span> <span class="string">&lt;integer&gt;</span>       <span class="comment"># 失败作业的历史记录数，默认为1</span></span><br><span class="line">  <span class="string">successfulJobsHistoryLimit</span>  <span class="string">&lt;integer&gt;</span>  <span class="comment"># 成功作业的历史记录数，默认为3</span></span><br><span class="line">  <span class="string">startingDeadlineSeconds</span>  <span class="string">&lt;integer&gt;</span>     <span class="comment"># 因错过时间点而未执行的作业的可超期时长</span></span><br><span class="line">  <span class="string">suspend</span>  <span class="string">&lt;boolean&gt;</span>              <span class="comment"># 是否挂起后续的作业，不影响当前作业，默认为false</span></span><br></pre></td></tr></table></figure>

<p>下面资源清单（cronjob-demo.yaml）定义了一个名为cronjob-demo的CronJob资源示例，它每隔2分钟运行一次由jobTemplate定义的示例任务，每次任务以单路并行的方式执行1次，每个任务的执行不超过60秒，且完成后600秒的Job将会被删除。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cronjob-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/2 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">mycronjob-jobs</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ttlSecondsAfterFinished:</span> <span class="number">3600</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myjob</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">CronJob,</span> <span class="string">sleep</span> <span class="string">a</span> <span class="string">while…;</span> <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>将cronjob-demo资源创建到集群上后便可通过资源对象的相关信息了解运行状态。下面第二条命令结果中的SCHEDULE是指其调度时间点，SUSPEND表示后续任务是否处于挂起状态，即暂停任务的调度及运行，ACTIVE表示活动状态的Job对象的数量，而LAST SCHEDULE则表示前一次调度运行至此刻的时长。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f cronjob-demo.yaml</span></span><br><span class="line">cronjob.batch/cronjob-demo created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get cronjobs/cronjob-demo</span></span><br><span class="line">NAME           SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">cronjob-demo   */2 * * * *    False    1        6s              69s</span><br></pre></td></tr></table></figure>

<p>我们可借助示例中Job模板上定义的标签过滤出名称空间中相关的Job对象。一段时长后，cronjob-demo创建的Job对象可能会存在多个，但示例中Job模板的配置会使得Job控制器自动删除那些完成后超过3600秒的、由cronjob-demo生成的Job对象。另外，CronJob资源默认仅会在历史记录中保留最近运行成功的3个以及运行失败的1个Job，因此，最终保留多少个Job也取决于CronJob中的历史记录定义，而历史记录中保存的Job数也支持由用户自定义其配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get <span class="built_in">jobs</span> -l controller=cronjob-demo</span></span><br><span class="line">NAME                   COMPLETIONS      DURATION   AGE</span><br><span class="line">cronjob-demo-1589970720   1/1           24s        6m28s</span><br><span class="line">cronjob-demo-1589970840   1/1           27s        4m28s</span><br><span class="line">cronjob-demo-1589970960   1/1           20s        2m28s</span><br><span class="line">cronjob-demo-1589971080   0/1           27s        27s</span><br></pre></td></tr></table></figure>

<p>CloJob在Pod中运行，并会保留处于Completed状态的Pod日志。由CronJob资源通过模板创建的Job对象的名称以CronJob自身的名称为前缀，以Job创建时的时间戳为后缀，而各Job对象相关的Pod对象的名称则随机生成。已完成的CronJob资源相关Pod的状态为Completed，而失败的作业状态则存在RunContainerError、CrashLoopBackOff或其他表示失败的状态。<br>可选的spec.startingDeadlineSeconds字段指示当CronJob由于某种原因错过了计划时间的情况下而允许延迟启动的最长时间（以秒为单位），错过的CronJob将被视为处于Failed状态。而未定义该字段值，则意味着CronJob永远不会超时，这将会导致CronJob资源存在同时运行多个实例的可能性。<br>CronJob资源的Job对象可能不支持同时运行多个实例，用户可基于.spec.concurrencyPolicy属性来控制多个CronJob并存的机制，它的默认值为Allow，即允许不同时间点的多个CronJob实例同时运行。其他两个可用值中，Forbid用于禁止前后两个CronJob同时运行，如果前一个尚未结束，则后一个不能启动（跳过），Replace用于让后一个CronJob取代前一个，即终止前一个并启动后一个。</p>
<h2 id="Pod中断预算"><a href="#Pod中断预算" class="headerlink" title="Pod中断预算"></a>Pod中断预算</h2><p>尽管Deployment等一类的控制器能确保相应Pod对象的副本数量不断逼近期望的数量，但它却无法保证在某一时刻一定存在指定数量或一定百分比的Pod对象，然而这种需求在某些强调服务可用性的场景中是必备的。于是，Kubernetes自1.4版本起引入了PDB（PodDisruptionBudget，Pod中断预算）类型的资源，用于为那些自愿的中断做好预算方案，限制可自愿中断的最大Pod副本数或确保最少可用的Pod副本数，以确保服务的高可用性。<br>Pod对象创建后会一直存在，除非用户有意将其销毁，或者出现了不可避免的硬件或系统软件错误。非自愿中断是指那些由不可控的外界因素导致的Pod中止而退出的情形，例如硬件或系统内核故障、网络故障以及节点资源不足导致Pod对象被驱逐等；而那些由用户特地执行的管理操作导致的Pod中断则称为自愿中断，例如排空节点、人为删除Pod对象、由更新操作触发的Pod对象重建等。用户可以为那些部署在Kubernetes的任何应用程序创建一个对应PDB对象以限制自愿中断时最大可以中断的副本数或者最少应该保持可用的副本数，从而保证应用自身的可用性。<br>PDB资源的核心目标在于保护由控制器管理的应用，这必然意味着PDB将使用等同于相关控制器对象的标签选择器以精确关联至目标Pod对象。PDB支持的控制器类型包括Deployment、ReplicaSet和StatefulSet等。同时，PDB对象也可以用来保护那些纯粹是由定制的标签选择器自由选择的Pod对象。<br>并非所有的自愿中断都会受到PDB的约束，例如，删除Deployment或者Pod的操作就会绕过PDB。另外，尽管那些因删除或更新操作导致不可用的Pod也会计入预算，但是控制器（例如Deployment）滚动更新时并不会真的被相关联的PDB资源所限制。因此，用户应当明确遵守PDB的限制法则，而不能直接删除PDB相关的Pod或者控制器资源。但管理员在维护集群时对节点执行的排空操作会受到PDB的限制。<br>PDB也是标准的API资源类型，其资源规范如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># API群组及版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span>             <span class="comment"># 资源类型特有标识</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">name</span> <span class="string">&lt;string&gt;</span>           <span class="comment"># 资源名称，在作用域中要唯一</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>      <span class="comment"># 名称空间；CronJob资源隶属名称空间级别</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">selector</span> <span class="string">&lt;Object&gt;</span>       <span class="comment"># 标签选择器，通常要与目标控制器资源相同</span></span><br><span class="line">  <span class="string">minAvailable</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 至少可用的Pod对象百分比，100%意味着不支持自愿中断</span></span><br><span class="line">  <span class="string">maxUnavailable</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 至多不可用的Pod对象百分比，0意味着不支持自愿中断；</span></span><br><span class="line">                          <span class="comment"># minAvailable和maxUnavailable互斥，不能同时定义</span></span><br></pre></td></tr></table></figure>

<p>下面的配置清单示例定义了名为pdb-demo的PDB资源，它对8.3.1节中由Deployment资源deployment-demo创建的Pod对象设置了PDB限制，要求其最少可用Pod对象数量为3个。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pdb-demo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxUnAvailable:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">      <span class="attr">release:</span> <span class="string">stable</span></span><br></pre></td></tr></table></figure>

<p>pdb-demo资源对象创建完成后，我们能够从其YAML格式的资源规范状态信息中了解到该资源的当前状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -f pdb-demo.yaml</span> </span><br><span class="line">poddisruptionbudget.policy/pdb-demo created</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pdb/pdb-demo -o yaml</span></span><br><span class="line">……</span><br><span class="line">status:</span><br><span class="line">  currentHealthy: 4</span><br><span class="line">  desiredHealthy: 3</span><br><span class="line">  disruptionsAllowed: 1</span><br><span class="line">  expectedPods: 4</span><br><span class="line">  observedGeneration: 1</span><br></pre></td></tr></table></figure>

<p>接下来，我们可通过在1～2个节点上模拟驱逐deployment-demo资源作用域内的两个或以上数量的Pod对象模拟自愿中断过程，并监控各Pod对象被终止的过程来验证PDB资源对象的控制功效。<br>首先，我们先了解deployment-demo作用域内各Pod对象在集群节点上的分布状态，下面的命令结果显示出，它有两个Pod对象同时运行在节点k8s-node02.ilinux.io之上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -l app=demoapp,release=stable -o wide | awk <span class="string">&#x27;&#123;print $1,$7&#125;&#x27;</span></span></span><br><span class="line">NAME                              NODE</span><br><span class="line">deployment-demo-b479b6f9f-dn8cc   k8s-node02.ilinux.io</span><br><span class="line">deployment-demo-b479b6f9f-ndt8t   k8s-node03.ilinux.io</span><br><span class="line">deployment-demo-b479b6f9f-pm994   k8s-node03.ilinux.io</span><br><span class="line">deployment-demo-b479b6f9f-qcwj4   k8s-node02.ilinux.io</span><br></pre></td></tr></table></figure>

<p>接下来，我们使用命令排空该节点以使得该deployment-demo资源作用域内的Pod对象有两个同时被中止，从而查看其触发pdb-demo的状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl drain k8s-node02.ilinux.io --ignore-daemonsets</span></span><br><span class="line">node/k8s-node02.ilinux.io already cordoned</span><br><span class="line">evicting pod default/deployment-demo-b479b6f9f-dn8cc</span><br><span class="line">evicting pod default/deployment-demo-b479b6f9f-qcwj4</span><br><span class="line">error when evicting pod &quot;deployment-demo-b479b6f9f-dn8cc&quot; (will retry after 5s): Cannot evict pod as it would violate the pod&#x27;s disruption budget.</span><br><span class="line">……</span><br><span class="line">error when evicting pod &quot;deployment-demo-b479b6f9f-dn8cc&quot; (will retry after 5s): Cannot evict pod as it would violate the pod&#x27;s disruption budget.</span><br><span class="line">evicting pod default/deployment-demo-b479b6f9f-dn8cc</span><br><span class="line">pod/deployment-demo-b479b6f9f-qcwj4 evicted</span><br><span class="line">pod/deployment-demo-b479b6f9f-dn8cc evicted</span><br><span class="line">node/k8s-node02.ilinux.io evicted</span><br></pre></td></tr></table></figure>

<p>测试完成后，关闭节点k8s-node02.ilinux.io的SchedulingDisabled状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl uncordon k8s-node02.ilinux.io</span></span><br><span class="line">node/k8s-node02.ilinux.io uncordoned</span><br></pre></td></tr></table></figure>

<p>从测试中排空命令的返回结果可以看出，同时执行驱逐deployment-demo作用域内的两个Pod对象的操作时，一个Pod能立即完成驱逐，但另一个Pod的驱逐操作被pdb-demo所阻塞，直到deployment-demo请求补足该Pod副本的请求在其他节点创建完成并就绪后，第二个Pod的驱逐操作才能得以完成。<br>事实上，PDB资源对多实例的有状态应用来说尤为有用，如Consul、ZooKeeper或etcd等，用户可借助PDB资源来防止自愿中断场景中将实例的数量减少到低于法定数量（quorum），以避免错误的写操作。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Kubernetes/" rel="tag"># Kubernetes</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/02/10/ConfigMap/" rel="prev" title="ConfigMap和Secret">
      <i class="fa fa-chevron-left"></i> ConfigMap和Secret
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">应用编排与管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kubernetes%E6%8E%A7%E5%88%B6%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">Kubernetes控制器基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8EPod%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.1.</span> <span class="nav-text">控制器与Pod资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pod%E6%A8%A1%E6%9D%BF%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.2.</span> <span class="nav-text">Pod模板资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReplicaSet%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">ReplicaSet控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">1.2.1.</span> <span class="nav-text">功能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReplicaSet%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">ReplicaSet基础应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%9B%9E%E6%BB%9A"><span class="nav-number">1.2.3.</span> <span class="nav-text">应用更新与回滚</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">常见更新机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%EF%BC%89%E5%8D%95%E6%89%B9%E6%AC%A1%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">1）单批次替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%EF%BC%89%E5%A4%9A%E6%89%B9%E6%AC%A1%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">2）多批次替换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%BB%BA%E5%BC%8F%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">重建式更新测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8%E5%BC%8F%E6%9B%B4%E6%96%B0%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">滚动式更新测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%89%A9%E5%AE%B9%E4%B8%8E%E7%BC%A9%E5%AE%B9"><span class="nav-number">1.2.4.</span> <span class="nav-text">应用扩容与缩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.5.</span> <span class="nav-text">高级更新策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deployment%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.3.</span> <span class="nav-text">Deployment控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Deployment%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">Deployment基础应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deployment%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.3.2.</span> <span class="nav-text">Deployment更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%9B%9E%E6%BB%9A-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">应用更新与回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83"><span class="nav-number">1.3.4.</span> <span class="nav-text">金丝雀发布</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StatefulSet%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">StatefulSet控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">功能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StatefulSet%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">StatefulSet基础应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E7%BC%A9%E5%AE%B9%E4%B8%8E%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">扩缩容与滚动更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StatefulSet%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">1.4.4.</span> <span class="nav-text">StatefulSet的局限性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DaemonSet%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.5.</span> <span class="nav-text">DaemonSet控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DaemonSet%E8%B5%84%E6%BA%90%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">DaemonSet资源基础应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DaemonSet%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">1.5.2.</span> <span class="nav-text">DaemonSet更新策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Job%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.6.</span> <span class="nav-text">Job控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Job%E8%B5%84%E6%BA%90%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">Job资源基础应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%BC%8FJob%E4%B8%8E%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="nav-number">1.6.2.</span> <span class="nav-text">并行式Job与扩容机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CronJob%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.7.</span> <span class="nav-text">CronJob控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pod%E4%B8%AD%E6%96%AD%E9%A2%84%E7%AE%97"><span class="nav-number">1.8.</span> <span class="nav-text">Pod中断预算</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description">myBlog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
