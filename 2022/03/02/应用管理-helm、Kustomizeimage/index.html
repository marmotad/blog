<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"marmotad.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="应用管理巨大的单体应用拆解为巨量的微服务程序，几乎必然导致应用管理复杂度的增加，例如在Kubernetes系统之上，每个应用基本都有不止一个资源，而每个应用在不同的环境（例如staging、test和prod等）可能使用不同配置参数等复杂问题。复用一个资源清单完成不同应用版本、不同环境、不同资源需求的部署很难实现，于是不得不使用系统环境变量及变量替换的方式辅助完成，否则资源清单必然会随着应用数量的">
<meta property="og:type" content="article">
<meta property="og:title" content="应用管理(helm、Kustomize)">
<meta property="og:url" content="https://marmotad.github.io/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/index.html">
<meta property="og:site_name" content="marmotad">
<meta property="og:description" content="应用管理巨大的单体应用拆解为巨量的微服务程序，几乎必然导致应用管理复杂度的增加，例如在Kubernetes系统之上，每个应用基本都有不止一个资源，而每个应用在不同的环境（例如staging、test和prod等）可能使用不同配置参数等复杂问题。复用一个资源清单完成不同应用版本、不同环境、不同资源需求的部署很难实现，于是不得不使用系统环境变量及变量替换的方式辅助完成，否则资源清单必然会随着应用数量的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220225090015819.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224203610780.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224204835418.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224211551538.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224211655608.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224211844299.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224212312835.png">
<meta property="og:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224212326053.png">
<meta property="article:published_time" content="2022-03-02T13:22:06.000Z">
<meta property="article:modified_time" content="2022-03-02T13:27:50.189Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://marmotad.github.io/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220225090015819.png">

<link rel="canonical" href="https://marmotad.github.io/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>应用管理(helm、Kustomize) | marmotad</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/blog/atom.xml" title="marmotad" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">marmotad</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://marmotad.github.io/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="myBlog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="marmotad">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          应用管理(helm、Kustomize)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-02 21:22:06 / 修改时间：21:27:50" itemprop="dateCreated datePublished" datetime="2022-03-02T21:22:06+08:00">2022-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h1><p>巨大的单体应用拆解为巨量的微服务程序，几乎必然导致应用管理复杂度的增加，例如在Kubernetes系统之上，每个应用基本都有不止一个资源，而每个应用在不同的环境（例如staging、test和prod等）可能使用不同配置参数等复杂问题。<br>复用一个资源清单完成不同应用版本、不同环境、不同资源需求的部署很难实现，于是不得不使用系统环境变量及变量替换的方式辅助完成，否则资源清单必然会随着应用数量的增加而成倍增加。</p>
<h2 id="Kustomize声明式应用管理"><a href="#Kustomize声明式应用管理" class="headerlink" title="Kustomize声明式应用管理"></a>Kustomize声明式应用管理</h2><p>Kubernetes v1.14版本以原生方式引入的Kustomize实现了一种非模板式的应用管理能力，它允许用户以一个应用描述文件为基础，而后将保存了具体需求的“补丁”文件以“叠加”的方式在基础文件之上添加、删除或更新应用配置，进而生成最终的应用版本。因而，Kustomize是一种完全基于YAML补丁系统的纯声明式配置管理工具，而非模板引擎，在使用体验上基本与Kubernetes API相契合。<br>Kustomize程序自身既能够集成到kubectl命令之中并以-k选项调用，也能够以独立的二进制文件运行。前者在帮助用户管理、变更和部署海量应用的路径上前进了一大步，而后者则让这个应用管理机制非常适合于扩展和集成到其他服务中，例如CI/CD管道等。</p>
<h3 id="声明式应用管理基本用法"><a href="#声明式应用管理基本用法" class="headerlink" title="声明式应用管理基本用法"></a>声明式应用管理基本用法</h3><p>Kustomize的核心目标在于为管理的应用生成资源配置，而这些资源配置中定义了资源的期望状态，在具体实现上，它通过kustomization.yaml文件组合和（或）叠加多种不同来源的资源配置来生成。<br>Kustomize将一个特定应用的配置保存在专用的目录中，且该目录中必须有一个名为kustomization.yaml的文件作为该应用的核心控制文件。由以下kustomization.yaml文件的格式说明可以大体看出，Kustomize可以直接组合由resources字段指定的资源文件作为最终配置，也可在它们的基础上进行修订，例如添加通用标签和通用注解、为各个资源添加统一的名称前缀或名称后缀、改动Pod模板中的镜像文件及向容器传递变量等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="string">resources</span> <span class="string">&lt;[]string&gt;</span> <span class="comment"># 待定制的原始资源配置文件列表，将由Kustomize按顺序处理</span></span><br><span class="line"><span class="string">namespace</span> <span class="string">&lt;string&gt;</span>   <span class="comment"># 设定所有名称空间级别资源所属的目标名称空间</span></span><br><span class="line"><span class="string">commonLabels</span> <span class="string">&lt;map[string]string&gt;</span>  <span class="comment"># 添加到所有资源的通用标签，包括Pod模板及</span></span><br><span class="line">                                  <span class="comment"># 相关的标签选择器</span></span><br><span class="line"><span class="string">commonAnnotations</span> <span class="string">&lt;map[string]string&gt;</span>   <span class="comment"># 添加到所有资源的通用注解</span></span><br><span class="line"><span class="string">namePrefix</span> <span class="string">&lt;string&gt;</span>    <span class="comment"># 统一给所有资源添加的名称前缀</span></span><br><span class="line"><span class="string">nameSuffix</span> <span class="string">&lt;string&gt;</span>    <span class="comment"># 统一给所有资源添加的名称后缀</span></span><br><span class="line"><span class="string">images</span> <span class="string">&lt;[]Image&gt;</span>       <span class="comment"># 将所有Pod模板中符合name字段条件的镜像文件修改为指定的镜像</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span>        <span class="comment"># 资源清单中原有的镜像名称，即待替换的镜像</span></span><br><span class="line">  <span class="string">nameName</span> <span class="string">&lt;String&gt;</span>    <span class="comment"># 要使用的新镜像名称</span></span><br><span class="line">  <span class="string">newTag</span> <span class="string">&lt;String&gt;</span>      <span class="comment"># 要使用的新镜像的标签</span></span><br><span class="line">  <span class="string">digest</span> <span class="string">&lt;String&gt;</span>      <span class="comment"># 要使用的新镜像的SHA256校验码</span></span><br><span class="line"><span class="string">vars</span> <span class="string">&lt;[]Var&gt;</span>           <span class="comment"># 指定可替换Pod容器参数中变量的值或容器环境变量的值</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span>        <span class="comment"># 变量的名称，支持以$(name)格式进行引用</span></span><br><span class="line">  <span class="string">objref</span> <span class="string">&lt;String&gt;</span>      <span class="comment"># 包含了要引用的目标字段的对象的名称</span></span><br><span class="line">  <span class="string">fieldref</span> <span class="string">&lt;String&gt;</span>    <span class="comment"># 引用的字段名称，默认为metadata.name</span></span><br></pre></td></tr></table></figure>

<p>假设用户要部署demoapp应用，但希望将来版本升级或在其他名称空间中能够复用相关的配置。于是，我们创建一个名为kustomize-demo的目录保存该应用的所有配置文件，而后在其内部准备一个定义了deployment/demoapp资源的配置文件，其内容如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deploy-demoapp.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">ikubernetes/demoapp:v1.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure>

<p>下面的资源清单定义了service/demoapp资源，用于为demoapp应用提供服务发现机制及固定的访问入口。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service-demoapp.yaml</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">demoapp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>若我们期望Kustomize能够根据以上两个资源配置文件依次创建出deployment/demoapp和service/demoapp资源，只需要在kustomize-demo目录中再定义一个如下所示的kustomization.yaml文件即可。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="comment"># 要组合的原始资源配置文件列表，它们将会按次序由kustomize来处理</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">namespace.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deploy-demoapp.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service-demoapp.yaml</span></span><br><span class="line"><span class="comment"># 统一添加资源标签，对于不支持修改资源标签的场景，该变动仅能执行资源的重新创建来完成</span></span><br><span class="line"><span class="attr">commonLabels:</span></span><br><span class="line">  <span class="attr">generated-by:</span> <span class="string">kustomize</span></span><br></pre></td></tr></table></figure>

<p>将定义的应用部署到Kubernetes集群之前，需要先由Kustomize根据目录中的kustomization.yaml配置文件生成最终的配置清单，而后由kubectl apply命令将其应用到集群之上，不过Kubernetes v1.14版本之后，该命令的-k DIR选项即能调用Kustomize直接生成最终配置，我们甚至可以使用–dry-run选项只查看生成的配置而不必真正进行资源的创建，如下面的命令所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -k ./kustomize-demo --dry-run=client -o yaml</span></span><br></pre></td></tr></table></figure>

<p>确认配置无误后，移除上面命令中的–dry-run选项便能完成资源创建。但这种简单的资源标签的添加或变动仅能表现出Kustomize功能之一二，它的核心功能在于对原始资源文件的修改、删除和覆盖能力。借助资源配置分解及导入机制，Kustomize支持以其他现有的资源配置为基础，通过添加、生成新文件，以及为现有资源配置打补丁的机制在更高级别完成资源配置的自定义，而这种机制也是它能够让一组基础配置能够适配到多种不同环境或目标的根本所在。</p>
<h3 id="应用配置分解"><a href="#应用配置分解" class="headerlink" title="应用配置分解"></a>应用配置分解</h3><p>Kustomize建议将公共或共享的资源配置放置在base子目录中，而将适用于特定环境或目的的配置以叠加或自定义的形式放置在各自子目录中，各项目可导入基础配置（base目录），而后进行各自所需的配置定义，这些子目录处于应用程序目录下的同一层级。事实上，若某自定义配置仍可作为公共或共享配置提供给其他更高一级的自定义配置，它能以同样的结构再次分割子目录，从而将应用目录分解为多个维度的多个层级。如图14-1所示的示例中，公共的基础配置放置在base目录，prod、test和staging从base载入配置后添加或修订适应于当前环境的设定，并分别放置在下级的base目录中作为各地域（region）集群上的共享配置。<br><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220225090015819.png" alt="image-20220225090015819">kustomization.yaml支持使用bases字段装载指定路径下Kustomize格式的资源配置并以之为当前配置的基础结构，当前配置将叠加在基础配置之上，以类似Docker镜像分层的方式向上暴露最终数据。下面我们仍然以demoapp为例来说明其构建方式。<br>1）创建demoapp/base目录，而后将前一节中创建的deploy-demoapp.yaml和service-demoapp.yaml资源清单，以及kustomization.yaml文件的副本各一份放置到该目录中作为公共的资源配置。<br>2)以demoapp/base为基础配置，为测试环境添加专用的资源配置并放置在demoapp/test目录下，之后将各个资源对象部署到test名称空间之中。于是，这里需要为基础配置额外添加一个用于定义名称空间资源的配置清单namespace.yaml，其内容如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>3）在demoapp/test目录下创建一个kustomization.yaml配置文件，它使用bases字段从名为base的目录装载基础配置，同时添加namespace.yaml资源文件，并指定了如下面内容所示的其他配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="attr">bases:</span>              <span class="comment"># 从指定的目录或仓库载入基础配置</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../base/</span>          <span class="comment"># 上级目录中的base目录</span></span><br><span class="line">  <span class="attr">resources:</span>          <span class="comment"># 添加其他的资源清单</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">namespace.yaml</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span>     <span class="comment"># 为资源指定目标名称空间</span></span><br><span class="line">  <span class="attr">commonLabels:</span>       <span class="comment"># 统一添加指定的标签</span></span><br><span class="line">  <span class="attr">environment:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">commonAnnotations:</span>  <span class="comment"># 统一添加指定的注解信息</span></span><br><span class="line">  <span class="attr">ilinux.io/app:</span> <span class="string">&quot;demoapp&quot;</span></span><br><span class="line">  <span class="attr">images:</span>             <span class="comment"># 设定镜像信息</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;ikubernetes/demoapp&quot;</span></span><br><span class="line">  <span class="attr">newTag:</span> <span class="string">&quot;v1.1&quot;</span>    <span class="comment"># 指定新的镜像标签</span></span><br></pre></td></tr></table></figure>

<p>4）配置完成后，以类似此前的方式，使用kubectl apply -k命令的–dry-run和-o yaml选项即可确认最终的配置。为了节约篇幅，下面仅列出命令结果中的少部分信息，主要保留了在Deployment资源上添加的标签（包括标签选择器的变动）、注解、指定的名称空间以及镜像文件的版本等信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl apply -k demoapp/test --dry-run=client -o yaml</span></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">- apiVersion: apps/v1</span><br><span class="line">  kind: Deployment</span><br><span class="line">  ……</span><br><span class="line">    name: demoapp</span><br><span class="line">    namespace: test               # 由test添加</span><br><span class="line">  spec:</span><br><span class="line">    replicas: 1</span><br><span class="line">    selector:</span><br><span class="line">      matchLabels:</span><br><span class="line">        app: demoapp</span><br><span class="line">        environment: test         # 由test添加</span><br><span class="line">        generated-by: kustomize   # 由base添加</span><br><span class="line">    template:</span><br><span class="line">      metadata:</span><br><span class="line">        annotations:</span><br><span class="line">          ilinux.io/app: demoapp  # 由test添加</span><br><span class="line">        labels:</span><br><span class="line">          app: demoapp</span><br><span class="line">          environment: test       # 由test添加</span><br><span class="line">          generated-by: kustomize         # 由base添加</span><br><span class="line">      spec:</span><br><span class="line">        containers:</span><br><span class="line">        - image: ikubernetes/demoapp:v1.1 # 由test修改</span><br><span class="line">          name: demoapp</span><br></pre></td></tr></table></figure>

<p>确认无误后，将最终的资源配置仍使用上面命令创建到集群上即可完成资源管理。当需要额外配置prod和staging等其他环境时，配置方式与此类似。进一步地，在为特定环境生成适用于不同集群的配置也可以使用类似上面的配置机制完成。<br><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224203610780.png" alt="image-20220224203610780">在Kustomize的语境中，能够生成完整资源配置的指令都称为配置生成器（generator)，例如14.1.2节中使用的resources就是一种从指定的资源清单直接生成配置的方式，而bases则是基于已有Kustomize项目载入基础配置，它们都是生成器类型的指令。另外两个常用的生成器是configmapGenerator和secretGenerator，它们能够根据指定的直接值或者文件生成相应类型的资源，而且generatorOptions字段还可以为生成资源统一添加标签和注解信息，具体的使用格式及简要功能说明如下所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">configMapGenerator</span> <span class="string">&lt;[]ConfigMapGeneratorArgs&gt;</span>  <span class="comment"># ConfigMap资源生成器列表</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span>       <span class="comment"># ConfigMap资源的名称，会受到namePrefix和nameSuffix的影响</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;String&gt;</span>  <span class="comment"># 资源所在的名称空间，会覆盖Kustomize级别的名称空间设定</span></span><br><span class="line">  <span class="string">behavior</span> <span class="string">&lt;String&gt;</span>   <span class="comment"># 与上级同名资源的合并策略，可用取值为create/replace/merge</span></span><br><span class="line">  <span class="string">files</span> <span class="string">&lt;[]String&gt;</span>    <span class="comment"># 从指定的路径加载文件生成ConfigMap，要使用当前项目的相对路径</span></span><br><span class="line">  <span class="string">literals</span> <span class="string">&lt;[]String&gt;</span> <span class="comment"># 从指定的key=value格式的直接值生成ConfigMap</span></span><br><span class="line">  <span class="string">env</span> <span class="string">&lt;String&gt;</span>  <span class="comment"># 从指定的环境变量文件中加载key=value格式的环境变量作为资源数据</span></span><br><span class="line">  <span class="string">secretGenerator</span> <span class="string">&lt;[]secretGeneratorArgs&gt;</span>  <span class="comment"># Secret资源生成器列表</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span>       <span class="comment"># Secret资源的名称，会受到namePrefix和nameSuffix的影响</span></span><br><span class="line">  <span class="string">namespace</span> <span class="string">&lt;String&gt;</span>  <span class="comment"># 资源所在的名称空间，会覆盖Kustomize级别的名称空间设定</span></span><br><span class="line">  <span class="string">behavior</span> <span class="string">&lt;String&gt;</span>   <span class="comment"># 与上级同名资源的合并策略，可用取值为create/replace/merge</span></span><br><span class="line">  <span class="string">files</span> <span class="string">&lt;[]String&gt;</span>    <span class="comment"># 从指定的路径加载文件生成Secret，加载起始于当前项目的相对路径</span></span><br><span class="line">  <span class="string">literals</span> <span class="string">&lt;[]String&gt;</span> <span class="comment"># 从指定的key=value格式的直接值生成Secret</span></span><br><span class="line">  <span class="string">type</span> <span class="string">&lt;String&gt;</span>       <span class="comment"># Secret资源的类型，且kubernetes.io/tls有特殊的键名要求</span></span><br><span class="line">  <span class="string">generatorOptions</span> <span class="string">&lt;GeneratorOptions&gt;</span>   <span class="comment"># 当前kustomization.yaml中的ConfigMap</span></span><br><span class="line">                                      <span class="comment"># 和Secret生成器专用的选项</span></span><br><span class="line"></span><br><span class="line"><span class="string">labels</span> <span class="string">&lt;map[String]String&gt;</span>  <span class="comment"># 为当前kustomization.yaml中所有生成的资源添加的标签</span></span><br><span class="line"><span class="string">annotations</span> <span class="string">&lt;map[String]String&gt;</span>     <span class="comment"># 为生成的所有资源添加的注解</span></span><br><span class="line"><span class="string">disableNameSuffixHash</span> <span class="string">&lt;Boolean&gt;</span>     <span class="comment"># 是否禁用hash名称后缀，默认为启用</span></span><br></pre></td></tr></table></figure>

<p>假设，我们此前还为demoapp在demoapp/staging目录下准备了专用于staging环境的应用配置，它与此前的test环境几乎完全相似，而我们希望在此基础为该环境添加专用的ConfigMap和Secret资源，下面的kustomization.yaml示例文件就给出了所需的相关配置项，其中secretGenerator调用的tls.crt和tls.key文件需要事先准备妥当。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="attr">bases:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../base/</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">namespace.yaml</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">staging</span></span><br><span class="line"><span class="attr">commonLabels:</span></span><br><span class="line">  <span class="attr">environment:</span> <span class="string">staging</span></span><br><span class="line"><span class="attr">commonAnnotations:</span></span><br><span class="line">  <span class="attr">ilinux.io/app:</span> <span class="string">&quot;demoapp&quot;</span> </span><br><span class="line"><span class="attr">configMapGenerator:</span>    <span class="comment"># 根据直接值生成ConfigMap资源</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp-conf</span></span><br><span class="line">  <span class="attr">literals:</span>            <span class="comment"># 直接值列表，它们将组合在同一个ConfigMap资源中</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">host=&quot;0.0.0.0&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">port=&quot;8080&quot;</span></span><br><span class="line"><span class="attr">secretGenerator:</span>       <span class="comment"># 根据文件生成Secret资源</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp-ssl</span></span><br><span class="line">  <span class="attr">files:</span>               <span class="comment"># 文件列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secrets/tls.crt</span>    <span class="comment"># 证书文件的键名必须为tls.crt，因而准备的文件名也得为tls.crt</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secrets/tls.key</span>    <span class="comment"># 密钥文件的键名必须为tls.key，因而准备的文件名也得为tls.key</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&quot;kubernetes.io/tls&quot;</span>   </span><br><span class="line"><span class="attr">generatorOptions:</span>      <span class="comment"># 生成器专用选项，禁止为生成的资源自动添加随机的hash后缀</span></span><br><span class="line">  <span class="attr">disableNameSuffixHash:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>同样，配置完成后，我们使用kubectl apply -k命令来确认其最终的配置。为了节约篇幅，下面的命令结果中仅列出了生成的ConfigMap和Secret资源。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">~$</span> <span class="string">kubectl</span> <span class="string">apply</span> <span class="string">-k</span> <span class="string">demoapp/staging</span> <span class="string">--dry-run=client</span> <span class="string">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;8080&quot;</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">ilinux.io/app:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">environment:</span> <span class="string">staging</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demoapp-conf</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">staging</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">tls.crt:</span> <span class="string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1J……</span></span><br><span class="line">    <span class="attr">tls.key:</span> <span class="string">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0……</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">ilinux.io/app:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">environment:</span> <span class="string">staging</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demoapp-ssl</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">staging</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">kubernetes.io/tls</span></span><br></pre></td></tr></table></figure>

<p>生成的配置还要demoapp应用能够正确载入及使用，deployment/demoapp资源在Pod模板中默认不以任何形式调用ConfigMap和Secret资源，我们可以通过覆盖该资源定义或者为其添加补丁来自定义其他的配置信息。</p>
<h3 id="资源补丁"><a href="#资源补丁" class="headerlink" title="资源补丁"></a>资源补丁</h3><p>除了资源配置的整体覆盖或替换，Kustomize还提供了两种补丁机制以完善基础资源配置的定义，补丁机制同样以叠加的方式增加、修改或删除资源或资源属性的配置。相关的配置格式及简要功能如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">patchesJson6902</span> <span class="string">&lt;[]Json6902&gt;</span>       <span class="comment"># 由各待补对象及其补丁文件所组成的列表</span></span><br><span class="line">  <span class="string">path</span> <span class="string">&lt;String&gt;</span>        <span class="comment"># 补丁文件，不含有目标资源对象的信息，支持JSON或YAML格式</span></span><br><span class="line">  <span class="string">target</span> <span class="string">&lt;Target&gt;</span>                  <span class="comment"># 待补资源对象</span></span><br><span class="line">    <span class="string">group</span> <span class="string">&lt;String&gt;</span>                 <span class="comment"># 资源所属的群组</span></span><br><span class="line">    <span class="string">version</span> <span class="string">&lt;String&gt;</span>               <span class="comment"># API版本</span></span><br><span class="line">    <span class="string">kind</span> <span class="string">&lt;String&gt;</span>                  <span class="comment"># 资源类型</span></span><br><span class="line">    <span class="string">name</span> <span class="string">&lt;String&gt;</span>                  <span class="comment"># 资源对象的名称</span></span><br><span class="line">    <span class="string">namespace</span> <span class="string">&lt;string&gt;</span>             <span class="comment"># 资源对象所属的名称空间</span></span><br><span class="line"><span class="string">patchesStrategicMerge</span> <span class="string">&lt;[]string&gt;</span>   <span class="comment"># 将补丁补到匹配的资源之上，匹配的方式是根据资源</span></span><br><span class="line">                                   <span class="comment"># Group/Version/Kind + Name/Namespace判断</span></span><br></pre></td></tr></table></figure>

<p>同样，我们假设此前还为demoapp在demoapp/prod目录下准备了专用于production环境的应用配置，它与此前的staging环境几乎完全相似，而我们希望在此基础为该环境添加专用的ConfigMap和Secret资源，下面的kustomization.yaml示例文件就给出了所需的相关配置项，其中依赖的补丁文件需要事先准备妥当。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="attr">bases:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../base/</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">namespace.yaml</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">commonLabels:</span></span><br><span class="line">  <span class="attr">environment:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">commonAnnotations:</span></span><br><span class="line">  <span class="attr">ilinux.io/app:</span> <span class="string">&quot;demoapp&quot;</span> </span><br><span class="line"><span class="attr">configMapGenerator:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp-conf</span></span><br><span class="line">  <span class="attr">literals:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">host=&quot;0.0.0.0&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">port=&quot;8080&quot;</span></span><br><span class="line"><span class="attr">secretGenerator:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp-ssl</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secrets/tls.crt</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secrets/tls.key</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&quot;kubernetes.io/tls&quot;</span></span><br><span class="line"><span class="attr">generatorOptions:</span></span><br><span class="line">  <span class="attr">disableNameSuffixHash:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">patchesStrategicMerge:</span>   <span class="comment"># 向匹配的资源打上指定文件中包含的补丁</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">patches/demoapp-add-configmap-and-secret.yaml</span>  <span class="comment"># 补丁文件路径</span></span><br><span class="line"><span class="attr">patchesJson6902:</span>         <span class="comment"># 将Json6902格式的补丁补到指定的资源之上</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">target:</span>                <span class="comment"># 待打补丁的资源对象</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">patches/patch-service-demoapp-targetport-8080.yaml</span>  <span class="comment"># 补丁文件路径</span></span><br></pre></td></tr></table></figure>

<p>下面是匹配到目标资源后自行为该资源打补丁的配置示例（patches/demoapp-add-configmap-and-secret.yaml），它使用apiVersion、kind、metadata.name和metadata.namespace等字段指明要适配的目标资源，而后以完整的资源路径指明补丁适配的位置。这类补丁会由Kustomize以合并的方式并入上级资源中。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoapp</span>   <span class="comment"># 补丁适配的目标位置，即Pod模板中名为demoapp的容器</span></span><br><span class="line">        <span class="attr">env:</span>            <span class="comment"># 此处起至文件尾部都是补丁的内容</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PORT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">demoapp-conf</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">demoapp.port</span></span><br><span class="line">              <span class="attr">optional:</span> <span class="literal">false</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">HOST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">demoapp-conf</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">demoapp.host</span></span><br><span class="line">              <span class="attr">optional:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappcerts</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/demoapp/certs/</span></span><br><span class="line">          <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">demoappcerts</span></span><br><span class="line">        <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">demoapp-ssl</span></span><br></pre></td></tr></table></figure>

<p>下面这个补丁是Json6902格式的资源示例（patches/patch-service-demoapp-targetport-8080.yaml），它并未指明适配的目标资源对象，而仅指定了JSON或YAML路径（path）格式的字段及其值，以及修补目标资源的操作方式（op）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">op:</span> <span class="string">replace</span>          <span class="comment"># 替换式补丁</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/spec/ports/0/targetPort</span>   <span class="comment"># .spec.ports[0].targetPort字段</span></span><br><span class="line">  <span class="attr">value:</span> <span class="number">8080</span>          <span class="comment"># 将上面字段的值修改为此处指定的值</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">op:</span> <span class="string">add</span>              <span class="comment"># 添加新的配置项</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/spec/ports/1</span>  <span class="comment"># .spec.ports[1]列表项</span></span><br><span class="line">  <span class="attr">value:</span>               <span class="comment"># 添加的内容为以下几个字段    </span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure>

<p>我们同样可以使用Kustomize编译该项目生成最终资源配置来验证其是否满足期望，鉴于篇幅原因，这里不再给出具体的命令及执行结果。提示<br>JSON Patch的格式请参考站点<a target="_blank" rel="noopener" href="http://jsonpatch.com/%E4%B8%8A%E7%9A%84%E8%AF%B4%E6%98%8E%E3%80%82">http://jsonpatch.com/上的说明。</a><br>以上使用格式及示例也进一步验证了Kustomize的使用哲学，它遵循声明式格式，用户只需声明所需要的内容，而后由系统来保证其结果，而且与Docker的镜像管理机制特别相像，一个应用可以拥有很多层，并且每一层都可以修改前一层。<br>另外需要特别说明的是，上面的示例步骤仅是为了循序渐进地说明如何构建分层的Kustomize应用，具体应用时，共享的配置部分通常都应该归置到基础库（base）中，仅个别需要定制的内容由最上级应用来提供，而且每一个变更都可以纳入Git仓库中，以便在需要时进行跟踪和溯源。</p>
<h2 id="Helm基础应用"><a href="#Helm基础应用" class="headerlink" title="Helm基础应用"></a>Helm基础应用</h2><p>与Kustomize使用JSON（或YAML）与叠加机制生成最终配置有所不同的是，Helm是一个模板引擎，它使用模板与值文件（value.yaml）来构建最终的配置清单。换个角度来说，Helm类似于Linux系统上的yum或apt-get等包管理器，可以帮助用户查找、分享及管理Kubernetes应用程序。</p>
<h3 id="Helm基础"><a href="#Helm基础" class="headerlink" title="Helm基础"></a>Helm基础</h3><p>Helm把Kubernetes的资源打包到一个Chart中，并将制作、测试完成的各个Chart保存到仓库进行存储和分发。Helm还实现了可配置的发布，它支持应用配置的版本管理，简化了Kubernetes部署应用的版本控制、打包、发布、删除、更新等操作，它有如下几个关键概念。</p>
<ul>
<li>Chart：即一个Helm程序包，它包含了运行一个Kubernetes应用所需要的镜像、依赖关系和资源定义等，它类似于APT的dpkg文件或者yum的rpm文件。</li>
<li>Repository：集中存储和分发Chart的仓库，类似于Perl的CPAN，或者Python的PyPI等。</li>
<li>Config：Chart实例化安装运行时使用的配置信息。</li>
<li>Release：Chart实例化配置后运行于Kubernetes集群中的一个应用实例；在同一个集群上，一个Chart可以使用不同的Config重复安装多次，每次安装都会创建一个新的Release（发布）。</li>
</ul>
<p>因此，Chart更像是存储在Kubernetes集群之外的程序，它的每次安装是指在集群中使用专用配置运行一个实例，执行过程有点类似于在操作系统上基于程序启动一个进程。<br>通常，用户在Helm客户端本地遵循其格式编写Chart文件，而后即可部署在Kubernetes集群上，运行为一个特定的Release。仅在有分发需求时，才应该把同一应用的Chart文件打包成归档压缩格式提交到特定的Chart仓库。仓库可以运行为公共托管平台，也可以是用户自建的服务器，仅供特定的组织或个人使用。<br>目前，Helm的主流可用版本主要有v2和v3两个。版本v2中，Helm主要由与用户交互的客户端、与Kubernetes API交互的服务端Tiller和Chart仓库（repository）组成，如图14-2所示。Helm的客户端是一个命令行工具，采用Go语言开发，它主要负责本地Chart开发、管理Chart仓库，以及基于gRPC协议与Tiller交互，从而完成应用部署、查询等管理任务。而Tiller服务器则托管运行在Kubernetes上，负责接收Helm客户端请求、将Chart转换为最终配置以生成一个Release，随后部署、跟踪以及管理各Release等功能。</p>
<p><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224204835418.png" alt="image-20220224204835418"></p>
<p>版本v2进化到版本v3的过程中，Helm客户端基本保持了原貌，但肩负重要任务的服务端组件Tiller被移除，取而代之是专用的CRD资源。换句话说，版本3时代的Helm使用CRD将Release直接保存到Kubernetes之上，且无须再跟踪各Release的状态，而将Chart渲染成Release的功能也移往Helm客户端，从而不必再用到Tiller组件。<br>事实上，由于Tiller拥有管理Kubernetes集群的密钥，在集群内公开了无须身份验证的gRPC端点且又无法在客户端用户上实现RBAC方式的授权管理功能，从而为Kubernetes集群引入了许多不确定的安全风险。因而，移除Tiller也是势在必行。好在，Helm的优势都基本保持未变，例如下面的这些优势依然存在。</p>
<ul>
<li>管理复杂应用：Chart能够描述哪怕是最复杂的程序结构，提供了可重复使用的应用安装的定义。</li>
<li>易于升级：使用就地升级和自定义钩子来解决更新的难题。</li>
<li>简单分享：Chart易于通过公共或私有服务完成版本化、共享及主机构建，且目前有众多成熟的Chart可供使用。</li>
<li>回滚：使用helm rollback命令轻松实现快速回滚。</li>
</ul>
<p>但凡事皆有两面性，Helm也存在着一些问题，而且有些问题甚至是原生的，甚至是其立足之本。例如，Helm有着更多的抽象层，因而学习曲线比较陡峭；即便程序包管理器基于默认的设定就能运行，但它也几乎必然会要求用户通过自定义设定来适配到自有环境，这不仅提升了在CI/CD管道中的处理复杂度，而且可读性较差的模板几乎不可避免地会随着时间的流逝而越来越丧失可定制性等。</p>
<h3 id="Helm-3快速入门"><a href="#Helm-3快速入门" class="headerlink" title="Helm 3快速入门"></a>Helm 3快速入门</h3><p>Helm的版本v2和版本v3目前处于维护当中，考虑了轻量、安全等特性，这里选择只介绍较新的版本v3的部署和使用，版本v2需要额外部署Tiller，而客户端的使用方法大多数都与版本v3相同。<br>Helm客户端工具支持预编译的二进制程序和源码编译两种安装方式，但它释出的每个版本都为各主流操作系统提供了适用的预编译版本，用户安装前按需下载适合的发行版本即可，大大简化了程序包的部署难度。<br>Helm项目托管在GitHub之上，项目地址为<a target="_blank" rel="noopener" href="https://github.com/kubernetes/helm%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%88%B0%E5%90%88%E7%94%A8%E7%89%88%E6%9C%AC%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%90%8E%E5%B9%B6%E5%B0%86%E5%85%B6%E5%B1%95%E5%BC%80%EF%BC%8C%E8%80%8C%E5%90%8E%E5%B0%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E6%88%96%E7%A7%BB%E5%8A%A8%E5%88%B0%E7%B3%BB%E7%BB%9FPATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%8D%B3%E5%8F%AF%E5%AE%8C%E6%88%90%E5%AE%89%E8%A3%85%E3%80%82%E6%9C%AC%E7%A4%BA%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFv3.2.4%E7%89%88%E6%9C%AC%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E4%B8%BA/usr/local/bin%E3%80%82">https://github.com/kubernetes/helm，下载到合用版本的压缩包后并将其展开，而后将二进制程序文件复制或移动到系统PATH环境变量指向的目录中即可完成安装。本示例中使用的是v3.2.4版本，程序包的安装目录为/usr/local/bin。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">tar -xf helm-v3.2.4-linux-amd64.tar.gz</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">sudo <span class="built_in">mv</span> linux-amd64/helm /usr/local/bin/</span></span><br></pre></td></tr></table></figure>

<p>Helm的各种管理功能均通过其子命令完成，例如要获取其简要使用帮助，直接使用如下所示的help子命令即可。但需要注意的是，Helm与Kubernetes API Server通信依赖于本地安装并配置的kubectl，因此运行Helm的节点也应该是可以正常使用kubectl命令的主机，或者至少是有着可用kubeconfig配置文件的主机。<br>如前所述，Helm可基于本地自行开发的Chart或经由公开仓库获取到的Chart完成应用管理。Helm项目维护的stable和incubator仓库中保存了一系列精心制作与维护的Chart，因而使用Helm完成应用管理的第一步通常是将它们添加为helm命令可以使用的本地仓库，从而能够使用内部的Chart。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm repo add stable https://kubernetes-charts.storage.googleapis.com/</span></span><br><span class="line">&quot;stable&quot; has been added to your repositories</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com</span></span><br><span class="line">&quot;incubator&quot; has been added to your repositories</span><br></pre></td></tr></table></figure>

<p>Helm Hub上还维护有众多第三方仓库，这些仓库都可以由helm repo命令添加到本地直接使用，而且也只能添加为本地仓库后才能够作为内部Chart使用。例如，维护有众多应用Chart且活跃度较高的Bitnami组织也拥有自己的Chart仓库，我们同样可以将其添加为本地仓库，如下面的命令所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm repo add bitnami https://charts.bitnami.com/bitnami</span></span><br><span class="line">&quot;bitnami&quot; has been added to your repositories</span><br></pre></td></tr></table></figure>

<p>Bitnami是一个开源项目，由Daniel Lopez Ridruejo于2003年在西班牙塞维利亚创立，其核心目标旨在为开源的Web应用程序、开发栈以及虚拟设备提供安装程序或安装软件包。<br>helo repo相关的命令用于管理使用的Charts仓库，其update子命令能够更新使用的默认仓库的元数据信息，其命令及执行结果如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm repo update</span></span><br><span class="line">Hang tight while we grab the latest from your chart repositories...</span><br><span class="line">...Successfully got an update from the &quot;incubator&quot; chart repository</span><br><span class="line">...Successfully got an update from the &quot;stable&quot; chart repository</span><br><span class="line">...Successfully got an update from the &quot;bitnami&quot; chart repository</span><br><span class="line">Update Complete.  Happy Helming!</span><br></pre></td></tr></table></figure>

<p>另外，除了add和update之外，helm repo命令还支持list和remove等子命令，前者用于列出本地配置的Chart仓库，而后者则用于移除指定的仓库。若要了解有哪些Chart可用，则要使用支持基于关键字搜索功能的helm search命令，它结合hub子命令可搜索Helm Hub或Monocular实例，而与repo子命令一起使用则能够搜索本地配置的各个仓库。前面添加的stable和incubator仓库中维护着主流的Chart集合，下面的搜索命令可直接列出该仓库中含有etcd关键字的所有Chart及简要描述。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm search repo etcd</span></span><br><span class="line">NAME    CHART VERSION   APP VERSION     DESCRIPTION                                   </span><br><span class="line">bitnami/etcd     4.8.12       3.4.9      etcd is a distributed key value store that prov...</span><br><span class="line">incubator/etcd      0.7.4       3.2.26    Distributed reliable key-value store for the mo...</span><br><span class="line">stable/etcd-operator   0.10.3      0.9.4    CoreOS etcd-operator Helm chart for Kubernetes</span><br><span class="line">stable/zetcd          0.1.9       0.0.3     CoreOS zetcd Helm chart for Kubernetes……</span><br></pre></td></tr></table></figure>

<p>在整个Helm Hub中进行搜索，意味着直接在线搜索Hub中存在的所有仓库，因而通常能得到更多的结果，如下面的命令结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm search hub etcd</span> </span><br><span class="line">URL              CHART VERSION   APP VERSION     DESCRIPTION                                       </span><br><span class="line">https://hub.helm.sh/charts/incubator/etcd   0.7.4   3.2.26   Distributed reliable key-value...</span><br><span class="line">https://hub.helm.sh/charts/bitnami/etcd   4.8.12   3.4.9   etcd is a distributed key value...</span><br><span class="line">https://hub.helm.sh/charts/stable/etcd-operator  0.10.3  0.9.4  CoreOS etcd-operator Helm …</span><br><span class="line">https://hub.helm.sh/charts/stable/zetcd  0.1.9   0.0.3  CoreOS zetcd Helm chart for Kubernetes            </span><br><span class="line">https://hub.helm.sh/charts/hkube/etcd   0.7.2008  3.3.1  Distributed reliable key-value...</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>省略搜索命令中的关键字能列出Helm Hub或本地配置的仓库中的所有Chart，而若要查看某个Chart的详细信息，则要使用helm show或helm inspect命令，它能够通过all子命令显示Chart的所有信息，或者通过chart、readme和values子命令分别显示Chart的定义、README信息及默认的值文件（values.yaml）内容。下面的命令就用于打印stable/etcd-operator的所有信息，为了节约篇幅，这里仅给出了命令返回的很少一部分结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm show all stable/etcd-operator</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">appVersion: 0.9.4</span><br><span class="line">description: CoreOS etcd-operator Helm chart for Kubernetes</span><br><span class="line">home: https://github.com/coreos/etcd-operator</span><br></pre></td></tr></table></figure>

<p>如前所述，将Chart中定义的应用部署到Kubernetes集群上生成的部署实例称为Release，一个集群上可能会存在某一Chart的多个实例，而Release名称便成了区分这些实例的关键标识，因此，部署命令helm install便要求为各Release指定一个专有的名称，如下面的命令格式所示。<br>helm install [NAME] [CHART] [flags]<br>我们知道，Helm是一个模板引擎，它使用值文件渲染模板生成具体的资源配置，但每个Chart通常都要为其模板提供一个具有通用目的的默认值文件，因而多数情况下，用户无须提供这类文件也能够直接部署生成一个实例。例如，下面的命令尝试在test名称空间中基于指定的Chart（stable/etcd-operator）及其默认的值文件部署出一个名为testop的实例来。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm install testop stable/etcd-operator --dry-run -n <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<p>由于使用了–dry-run选项，该命令仅会打印生成的最终资源配置，并会给出部署后的使用提示。若无错误信息返回且各配置项符合需要，移除该选项即可进入安装流程。Helm自身并不会创建目标名称空间，因此请务必确保引用的名称空间事先存在。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl create namespace <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">helm install testop stable/etcd-operator -n <span class="built_in">test</span></span></span><br><span class="line">manifest_sorter.go:192: info: skipping unknown hook: &quot;crd-install&quot;</span><br><span class="line">NAME: testop                            # Relase名称</span><br><span class="line">LAST DEPLOYED: Thu Sep 17 11:45:36 2020 # 部署时间</span><br><span class="line">NAMESPACE: test                         # 名称空间</span><br><span class="line">STATUS: deployed  # 部署状态</span><br><span class="line">REVISION: 1       # 历史版本</span><br><span class="line">TEST SUITE: None  # 测试套件状态，拥有测试套件的Release可由helm test命令进行测试</span><br><span class="line">NOTES:            # 简要使用提示</span><br><span class="line"></span><br><span class="line">1. etcd-operator deployed.</span><br><span class="line">   If you would like to deploy an etcd-cluster set &#x27;customResources.createEtcdClusterCRD&#x27; to true in values.yaml</span><br><span class="line">     Check the etcd-operator logs</span><br><span class="line">   export POD=$(kubectl get pods -l app=testop-etcd-operator-etcd-operator --namespace test --output name)</span><br><span class="line">   kubectl logs $POD --namespace=test……</span><br></pre></td></tr></table></figure>

<p>命令返回的结果称为Release的状态信息，这些信息随后还可以通过helm status命令再次获取。另外，helm install命令支持基于多种安装源进行应用部署，这包括Chart仓库、本地的Chart压缩包、本地Chart目录，甚至是指定一个Chart的URL等。<br>对于多数有状态应用，其Helm Chart主要用于部署生成管理该类应用集群的Operator，而后由用户根据Operator提供的CRD实现必要的应用管理功能，例如etcd-operator项目提供的集群部署和管理（etcdclusters）、数据备份（etcdbackups）和数据恢复（etcdrestores）等自定义资源类型及相关的Operator控制器等。我们可以使用Helm客户端列出的已经安装生成的Release的helm list命令，来了解该Operator的部署状况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm list -n <span class="built_in">test</span></span></span><br><span class="line">NAME          NAMESPACE    REVISION     UPDATED          STATUS   ……</span><br><span class="line">testop          test         1          2020-09-17……   deployed  ……</span><br></pre></td></tr></table></figure>

<p>该Operator生成的Pod资源也都是自定义的控制器程序，它们用于确保相关的自定义资源符合用户期望的状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl api-resources --api-group etcd.database.coreos.com</span></span><br><span class="line">NAME     SHORTNAMES   APIGROUP    NAMESPACED   KIND</span><br><span class="line">etcdbackups               etcd.database.coreos.com   true        EtcdBackup</span><br><span class="line">etcdclusters   etcd       etcd.database.coreos.com   true        EtcdCluster</span><br><span class="line">etcdrestores              etcd.database.coreos.com   true        EtcdRestore</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">kubectl get pods -n <span class="built_in">test</span> -l release=testop</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">testop-etcd-operator-etcd-backup-operator-66f5cf5bc8-w2mfl    1/1   Running ……</span><br><span class="line">testop-etcd-operator-etcd-operator-7f857bdd84-rssmf           1/1   Running ……</span><br><span class="line">testop-etcd-operator-etcd-restore-operator-7597fc47f7-2tslk   1/1   Running ……</span><br></pre></td></tr></table></figure>

<p>于是，用到etcd存储集群时，用户根据自定义资源etcdCluster声明出一个etcd集群规范，并应用于Kubernetes之上，该Operator即会自行确保其能够正确运行。具体使用请参考第12章中的相关话题的说明。<br>对于运行中的Release，我们可以使用helm get命令获取相关的钩子、最终资源配置清单、注意事项和用户自定义的模板参数值信息，相关信息的获取各自依赖于相关的子命令，或者直接使用子命令all一次性地列出所有这些信息。下面的命令结果显示出，用户在部署testop实例时未提供任何自定义值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm get values testop -n <span class="built_in">test</span></span>     </span><br><span class="line">USER-SUPPLIED VALUES:</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>升级或回滚应用，要分别使用helm upgrade和helm rollback命令，还可以使用helm history命令获取指定Release的变更历史。若各可用仓库中均不存在某应用相关的可用Chart，用户可以自行编写Chart，甚至将Chart回馈到社区。</p>
<h2 id="Helm-Chart"><a href="#Helm-Chart" class="headerlink" title="Helm Chart"></a>Helm Chart</h2><p>Chart本质是描述一组Kubernetes资源配置的文件集合，它既能部署小到单个资源的简单应用，例如一个memcached Pod，又能部署大型的复杂应用，例如由HTTP服务器、数据库服务器、缓存服务器和应用程序服务器等共同组成的Web应用栈，甚至是Istio这样的微服务网络系统等。从物理的角度来描述，Chart就是一个遵循特定规范的目录结构，它能够打包成一个可用于部署的版本化归档文件。<br>14.3.1　Chart包结构与描述文件<br>包是多数编程语言中都存在的概念，常用于创建独立的名称空间以及模块化应用程序。类似地，Chart就是Helm封装应用的格式，目录名即为包名或Chart名。例如，demoapp应用Chart的目录结构应该类似如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">demoapp</span><br><span class="line">├── CHANGELOG.md         # 变动清单</span><br><span class="line">├── Chart.yaml           # 当前Chart的描述信息，YAML格式的文件</span><br><span class="line">├── charts/              # 当前Chart包含的其他Chart（也称为子Chart）</span><br><span class="line">├── LICENSE              # 文件格式的许可证文件，可选</span><br><span class="line">├── crds/                # 自定义资源的存放目录</span><br><span class="line">├── README.md            # 易读格式的README文件，可选</span><br><span class="line">├── templates/           # 模板文件专用目录，目录中的文件需要发送给模板引擎进行渲染</span><br><span class="line">├── templates/NOTES.txt  # 简要使用说明，文本文件，可选</span><br><span class="line">├── values.yaml          # 默认的值文件，用于向模板中的参数提供默认值</span><br><span class="line">└── values.schema.json   # YAML格式的值文件对应的JSON格式的内容</span><br></pre></td></tr></table></figure>

<p>尽管charts和templates目录均为可选，但至少应该存在一个子Chart或一个模板文件，这意味着两个目录至少要存在一个。另外，Helm保留使用charts/和templates/目录以及上面列出的文件名称，其他文件都将被忽略。<br>Chart.yaml是包中一个必备的重要文件，用于提供Chart相关的各种元数据，例如名称、版本、关键词、维护者信息、使用的模板引擎等。Helm版本v2与版本v3的Chart.yaml文件格式有所不同，版本v3主要包含以下字段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apiVersion &lt;String&gt;        # Chart的API版本，必选字段</span><br><span class="line">name &lt;String&gt;              #当前Chart的名称，必选字段</span><br><span class="line">version &lt;String&gt;           # 遵循语义化版本规范第2版的版本号，必选字段</span><br><span class="line">kubeVersion &lt;String&gt;       #兼容的Kubernetes版本的版本号范围</span><br><span class="line">description &lt;String&gt;       #当前项目的单语句描述信息</span><br><span class="line">type &lt;String&gt;              # Chart所属的类型</span><br><span class="line">keywords &lt;[]String&gt;        # 当前项目的关键词列表</span><br><span class="line">home &lt;String&gt;              # 当前项目的主页URL</span><br><span class="line">sources &lt;[]String&gt;         # 当前项目用到的源码来源url列表</span><br><span class="line">dependencies &lt;[]Object&gt;    # 依赖的Chart的列表对象</span><br><span class="line">- name &lt;String&gt;            # Chart名称</span><br><span class="line">  version &lt;String&gt;         # Chart的版本</span><br><span class="line">  repository &lt;String&gt;      # 仓库的URL或以@开头的别名</span><br><span class="line">  conditions &lt;String&gt;      # 一个或多个YAML路径格式的条件字段，彼此间以逗号分隔</span><br><span class="line">  tags &lt;[]Tag&gt;             # YAML标签列表，用于将依赖的Chart进行分组并按组启用或禁用</span><br><span class="line">  enabled &lt;Bool&gt;           # 是否启用该Chart</span><br><span class="line">  import-values &lt;[]String&gt; # 导入子Chart中的值</span><br><span class="line">  alias &lt;String&gt;           # Chart的别名</span><br><span class="line">maintainers &lt;[]Object&gt;     # 项目维护者信息</span><br><span class="line">- name &lt;String&gt;            # 项目维护人员的名字</span><br><span class="line">  email &lt;String&gt;           # 维护人员的Email</span><br><span class="line">  url &lt;String&gt;             # 项目维护人员的相关URL</span><br><span class="line">icon &lt;String&gt;              # URL，指向当前项目的图标，SVG或PNG格式的图片</span><br><span class="line">appVersion &lt;String&gt;        #本项目用到的应用程序的版本号，且不必为语义化版本</span><br><span class="line">deprecated &lt;Bool&gt;          #当前Chart是否已废弃，布尔型值</span><br><span class="line">annotations &lt;map[String]String&gt;    # 注解信息</span><br></pre></td></tr></table></figure>

<p>上面Chart.yaml文件格式中，仅apiVersion、name、version为必选字段，余下的字段均可按需进行添加或移除。例如，下面的示例是demoapp Chart中使用的Chart.yaml的内容。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">appVersion:</span> <span class="number">1.5</span><span class="number">.0</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Web</span> <span class="string">application</span> <span class="string">example</span> <span class="string">based</span> <span class="string">on</span> <span class="string">Flask.</span> </span><br><span class="line"><span class="attr">engine:</span> <span class="string">gotpl</span></span><br><span class="line"><span class="attr">home:</span> <span class="string">http://www.ilinux.io/</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">demoapp</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">webapp</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">microservice</span></span><br><span class="line"><span class="attr">maintainers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">email:</span> <span class="string">mage@magedu.com</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">MageEdu</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line"><span class="attr">sources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">https://github.com/ikubernetes/</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.5</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>为新建的Chart生成该文件时，基于一个已有文件进行改写是一个不错的主意，既能降低出错的概率，又能提高编写效率。更具体的使用信息请参考<a target="_blank" rel="noopener" href="https://helm.sh/docs/topics/charts/%E7%AB%99%E7%82%B9%E4%B8%8A%E7%9A%84%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%E3%80%82">https://helm.sh/docs/topics/charts/站点上的文档说明。</a></p>
<h3 id="Chart中的依赖关系"><a href="#Chart中的依赖关系" class="headerlink" title="Chart中的依赖关系"></a>Chart中的依赖关系</h3><p>应用程序可能存在对其他应用的依赖关系，这类应用若对等制作为独立的Chart，则它们反映到Helm中依然存在类似的依赖关系。这种依赖关系可通过Chart.yaml中的dependencies字段进行动态链接，也可直接将依赖的其他Chart存储在当前Chart的charts/目录中进行手动管理。显然，即便手动管理依赖关系对个别管理场景有着些许优势，动态管理方式依然是推荐的首选方式。1. dependencies字段<br>Chart.yaml中的dependencies字段本质上只是一个简单的依赖关系列表，它有类似如下配置格式中的几个可用字段。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">dependencies</span> <span class="string">&lt;[]Object&gt;</span>    <span class="comment"># 依赖的Chart的列表对象</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">name</span> <span class="string">&lt;String&gt;</span>            <span class="comment"># Chart名称</span></span><br><span class="line">  <span class="string">version</span> <span class="string">&lt;String&gt;</span>         <span class="comment"># Chart的版本</span></span><br><span class="line">  <span class="string">repository</span> <span class="string">&lt;String&gt;</span>      <span class="comment"># 仓库的URL或以@开头的别名</span></span><br><span class="line">  <span class="string">conditions</span> <span class="string">&lt;String&gt;</span>      <span class="comment"># 一个或多个YAML路径格式的条件字段，彼此间以逗号分隔</span></span><br><span class="line">  <span class="string">tags</span> <span class="string">&lt;[]Tag&gt;</span>             <span class="comment"># YAML标签列表，用于将依赖的Chart进行分组并按组启用或禁用</span></span><br><span class="line">  <span class="string">enabled</span> <span class="string">&lt;Bool&gt;</span>           <span class="comment"># 是否启用该Chart</span></span><br><span class="line">  <span class="string">import-values</span> <span class="string">&lt;[]String&gt;</span> <span class="comment"># 导入子Chart中的值</span></span><br><span class="line">  <span class="string">alias</span> <span class="string">&lt;String&gt;</span>           <span class="comment"># Chart的别名</span></span><br></pre></td></tr></table></figure>

<p>定义依赖项时，仅name、version和repository几个为必选字段，且指定的各依赖项必然会被当前Chart所加载。若希望基于某种条件来决定是否启用依赖项，例如当前Chart是否在某个参数项启用了某项特性或某种功能等，则可以通过为依赖项添加conditions字段来实现。该字段值是包含一到多个YAML格式的路径，但仅有第一个有效，它通常代表当前Chart的某个可配置的参数，该参数应该被解析为布尔型值，其结果决定了依赖项中的Chart启用与否。<br>另外，当依赖较多的Chart时，tags字段能够将这些被依赖的Chart分成逻辑组，而后在当前Chart的值文件values.yaml中根据标签统一启用或禁用。但存在冲突时，conditions字段中的设定会覆盖tags中的定义。<br>下面依赖关系配置示例取自Bitnami仓库Harbor项目的Chart中的定义。示例中显示出，该Chart依赖于postgresql、redis和common这3个Chart，而且前两个Chart分别有着各自的启用条件，第一个Chart取决于该Chart值文件中postgresql.enabled参数的定义，而第二个Chart则取决于redis.enabled参数的值。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">postgresql</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">8.</span><span class="string">x.x</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://charts.bitnami.com/bitnami</span></span><br><span class="line">    <span class="attr">condition:</span> <span class="string">postgresql.enabled</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">10.</span><span class="string">x.x</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://charts.bitnami.com/bitnami</span></span><br><span class="line">    <span class="attr">condition:</span> <span class="string">redis.enabled</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">common</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">0.</span><span class="string">x.x</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://charts.bitnami.com/bitnami</span></span><br></pre></td></tr></table></figure>

<p>一旦依赖关系文件配置完成，即可使用helm dependency update命令更新依赖关系，并自动下载被依赖的Chart至当前包的charts/目录中。2. charts目录<br>若需要对依赖关系进行更多的控制，也可以手动将所有被依赖的Chart直接复制到charts目录中。被依赖的Chart既可以是归档格式，又可以是展开的目录格式，不过其名称不能以下划线（_）或点号（.）开头，因为此类文件会被Chart装载器自动忽略。例如，bitnami/harbor定义的依赖关系在其charts目录中生成的文件列表类似如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">charts/</span><br><span class="line">├── common-0.3.1.tgz</span><br><span class="line">├── postgresql-8.10.14.tgz</span><br><span class="line">└── redis-10.7.11.tgz</span><br></pre></td></tr></table></figure>

<p>被依赖的每个Chart可直接由helm pull命令下载，它将下载的文件默认保存在当前的工作目录下。</p>
<h3 id="模板与值"><a href="#模板与值" class="headerlink" title="模板与值"></a>模板与值</h3><p>简单来说，模板是指某项设计方案的固定格式，它包含遵循特定语法规范的标签（或者参数）及行为（action），而模板引擎就是将规范格式的模板代码转换为基于业务数据的算法实现，它的基本逻辑就是将指定的标签或参数替换为业务数据。从模板引擎的角度来说，模板就是嵌入了动作的文本，而模板引擎则通过将模板应用到一个数据结构（为模板参数提供业务数据）来获得输出。<br>在Go语言的语境中，模板就是一个字符串或一个文本文件，它们嵌入了一个或多个由双花括号包含的对象。每个action就是一个用模板语言书写的表达式，这些表达式可能仅选择结构体的成员执行简单的字符串替换，也可能含有复杂的模板语言代码，例如调用函数或方法、表达式控制流if-else语句和range循环语句等。<br>Helm Chart的模板主要用于泛化Kubernetes资源的定义，以允许用户提供简单的信息便能完成复杂资源配置的自定义，它遵循Go模板语言格式，并支持50种以上来自Spring库的模板函数附件，以及为数不少的其他专用函数。Helm Chart的模板引擎使用保存在值文件中的数据结构进行模板渲染，以生成最终的资源配置作为结果返回。<br>Chart程序包中，所有的模板文件都需要存储在templates目录下，由Helm引用时，它们都将被传递给模板引擎，并结合值文件或用户通过命令行传递的参数值进行渲染。下面的示例是bitnami/fluentd中ingress资源模板文件的内容，其中的Ingress资源基础框架隐约可见，但大部分业务数据都被“模板化”了，相关数据将在模板引擎对其进行渲染时生成。具体的模板语法及使用方式请参考Helm项目的文档及gotemplate的文档。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- if .Values.ingress.enabled -&#125;&#125;    # 该模板启用与否取决于值文件中该字段的值</span><br><span class="line">&#123;&#123;- $serviceName := include &quot;fluentd.fullname&quot; . -&#125;&#125; </span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; template &quot;fluentd.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    app: &#123;&#123; template &quot;fluentd.name&quot; . &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; template &quot;fluentd.chart&quot; . &#125;&#125;</span><br><span class="line">    release: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">    heritage: &#123;&#123; .Release.Service &#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.ingress.labels &#125;&#125;               # 流程控制语句</span><br><span class="line">&#123;&#123; toYaml .Values.ingress.labels | indent 4 &#125;&#125; # indent用于缩进</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.ingress.annotations &#125;&#125;</span><br><span class="line">  annotations:</span><br><span class="line">&#123;&#123; tpl ( toYaml .Values.ingress.annotations | indent 4 ) . &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">    &#123;&#123;- range $host := .Values.ingress.hosts &#125;&#125;  # 流程控制语句 </span><br><span class="line">    - http:</span><br><span class="line">        paths:</span><br><span class="line">          - path: &#123;&#123; $host.path | default &quot;/&quot; &#125;&#125;</span><br><span class="line">            backend:</span><br><span class="line">              serviceName: &#123;&#123; $serviceName &#125;&#125;</span><br><span class="line">              servicePort: &#123;&#123; $host.servicePort &#125;&#125;</span><br><span class="line">    &#123;&#123;- if (not (empty $host.name)) &#125;&#125;</span><br><span class="line">      host: &#123;&#123; $host.name &#125;&#125;</span><br><span class="line">    &#123;&#123;- end -&#125;&#125;</span><br><span class="line">    &#123;&#123;- end -&#125;&#125;</span><br><span class="line">  &#123;&#123;- if .Values.ingress.tls &#125;&#125;</span><br><span class="line">  tls:</span><br><span class="line">&#123;&#123; toYaml .Values.ingress.tls | indent 4 &#125;&#125;</span><br><span class="line">  &#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>值文件同样遵循YAML数据规范，它们是模板引擎渲染模板时的主要数据来源，Chart通常会自带该文件以提供默认值，同时Helm也允许用户通过命令行提供自定义的值文件，以及直接通过命令行选项给定个别参数的值。这类用户自定义提供的值将会合并到默认的值文件中，但它们有着更高的优先级。除此之外，Chart模板还有一些固定的预定义值，例如Release.Name、Release.Service、Release.IsUpgrade、Release.IsInstall、Release.Revision、Chart（chart.yaml文件的内容）、Files（Chart中非专有文件）和Capabilities（Kubernetes自身及各API的版本信息）等。注意<br>Chart中的值文件必须以values.yaml为文件名，但用户传递的自定义值文件则无此约束。<br>Helm将最终合并生成的值文件视作一个Values对象，各模板可以基于该对象访问值文件内部的任何一个值，例如下面值文件中的.Values.ingress.enabled或.Values.ingress.hosts等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>     <span class="comment"># 模板中引用该键值的格式为.Values.ingress.enabled</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">kubernetes.io/tls-acme:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">labels:</span> []</span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;http-input.local&quot;</span></span><br><span class="line">       <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">       <span class="attr">servicePort:</span> <span class="number">9880</span></span><br><span class="line">       <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">tls:</span> &#123;&#125;</span><br><span class="line">  <span class="comment"># Secrets must be manually created in the namespace.</span></span><br><span class="line"><span class="comment">#    - secretName: http-input-tls</span></span><br><span class="line"><span class="comment">#      hosts:</span></span><br><span class="line"><span class="comment">#        - http-input.local</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，值文件可为其所属的Chart及其位于charts/目录中的依赖项提供所需要的任何值，而且较高级别的Chart能够访问依赖的下级Chart中定义的所有变量，但下级Chart不能向上引用。</p>
<h3 id="其他需要说明的话题"><a href="#其他需要说明的话题" class="headerlink" title="其他需要说明的话题"></a>其他需要说明的话题</h3><p>定义Chart时还需用到许可证文件、自述文件（README.md）以及说明文件（NOTE.txt），其中说明文件为用户提供了重要的使用帮助及注意事项等。基于Chart的格式规范，用户即可自定义相关应用程序的Chart，并可通过仓库完成分享。<br>Chart也支持使用文件来描述安装、配置、使用和许可证信息。一般说来，README文件必须为Markdown格式，因此其后缀名通常是.md，它一般应该包含如下内容。</p>
<ul>
<li>当前Chart提供的应用或服务的描述信息。</li>
<li>运行当前chart需要满足的条件。</li>
<li>values.yaml文件中选项及默认值的描述。</li>
<li>其他任何有助于安装或配置当前Chart的有用信息。</li>
</ul>
<p>另外，templates/NOTES.txt文件中的内容将会在Chart安装完成后予以输出，通常用于向用户提供当前Chart相关的使用或初始访问方式的信息。另外，使用helm status命令查看某Release的相关状态信息时，此文件中的内容也会输出。</p>
<h3 id="自定义Chart简单示例"><a href="#自定义Chart简单示例" class="headerlink" title="自定义Chart简单示例"></a>自定义Chart简单示例</h3><p>典型的服务类容器化应用通常会由工作负载控制器（例如Deployment资源）、Service、ServiceAccount、ConfigMap、Secret、Ingress、HPA和PersistentVolumeClaim等资源对象组成，一般来说，工作负载控制器和Service通常是必备的资源，其他资源可按需进行定义或添加。</p>
<h4 id="生成Chart配置框架"><a href="#生成Chart配置框架" class="headerlink" title="生成Chart配置框架"></a>生成Chart配置框架</h4><p>helm create命令能为Deployment、Ingress、HPA、ServiceAccount和Service这5种类型资源各自提供一个示例模板以及其他几个必要的文件，以方便用户快速创建出所需要的自定义Chart。例如，下面的命令便会在命令执行的当前目录中创建一个名为demoapp的子目录作为Chart存储路径，并在该目录中为几种常见的资源类型生成基础的框架模板文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm create demoapp</span></span><br><span class="line">Creating demoapp</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">tree demoapp/</span></span><br><span class="line">demoapp/</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── hpa.yaml</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   ├── serviceaccount.yaml</span><br><span class="line">│   ├── service.yaml</span><br><span class="line">│   └── tests</span><br><span class="line">│       └── test-connection.yaml</span><br><span class="line">└── values.yaml</span><br></pre></td></tr></table></figure>

<p>上述命令还会成一个示例性的Chart.yaml文件及values.yaml文件，Helm默认将该Chart项目的目录名称作为项目名称，而版本号则为“0.1.0”，如下面由该命令生成的Chart.yaml文件的内容所示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">Helm</span> <span class="string">chart</span> <span class="string">for</span> <span class="string">Kubernetes</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="number">1.16</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>另外，该命令默认生成的值文件中提供了应用副本数（replicaCount）、应用镜像（image）、服务账户（serviceAccount）、安全上下文（podSecurityContext和securityContext）、服务和Ingress（service和ingress）、容器资源约束（resources）、自动缩放（autoscaling）以及影响调度器调度决策（nodeSelector、tolerations和affinity）等各方面的参数值。事实上，我们仅需要在各文件现有框架的基础上按需进行简单修改即可定义出所需的Chart来。</p>
<h4 id="定制Chart"><a href="#定制Chart" class="headerlink" title="定制Chart"></a>定制Chart</h4><p>假设，我们的目标是将容器应用ikubernetes/demoapp:v1.0构建为一个完整的Helm应用，而且Deployment控制器就能满足基本的应用编排需求，则简单修改默认生成的values.yaml文件以下部分的内容值就能基本满足需求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">replicaCount: 1                      # 应用的Pod副本数量</span><br><span class="line"></span><br><span class="line">image:                               # 定义应用镜像</span><br><span class="line">  repository: ikubernetes/demoapp    # 仓库名称</span><br><span class="line">  pullPolicy: IfNotPresent           # 镜像下载策略</span><br><span class="line">  tag: &quot;v1.0&quot;                        # 镜像标签</span><br><span class="line"></span><br><span class="line">imagePullSecrets: []                 # 私有镜像仓库的Secret</span><br><span class="line">nameOverride: &quot;&quot;                     # 应用名称</span><br><span class="line">fullnameOverride: &quot;&quot;                 # 完成格式的应用名称</span><br><span class="line"></span><br><span class="line">serviceAccount:                      # 专用的ServiceAcccount</span><br><span class="line">  create: false                      # 是否创建专用的SA</span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line">  name: &quot;&quot;                           # 专用SA的名称</span><br><span class="line">……   </span><br><span class="line">service:                             # 相关Service的定义</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">ingress:</span><br><span class="line">  enabled: false</span><br><span class="line">  annotations: &#123;&#125;</span><br><span class="line">    kubernetes.io/ingress.class: nginx</span><br><span class="line">    # kubernetes.io/tls-acme: &quot;true&quot;</span><br><span class="line">  hosts:</span><br><span class="line">    - host: www.ilinux.io</span><br><span class="line">      paths: </span><br><span class="line">      - path: /</span><br><span class="line">  tls: []</span><br><span class="line">  #  - secretName: chart-example-tls</span><br><span class="line">  #    hosts:</span><br><span class="line">  #      - chart-example.local</span><br></pre></td></tr></table></figure>

<p>值文件修订完成后，可使用helm template命令测试模板引擎基于值文件对模板进行渲染的结果，该命令会按照指定的Chart名称进行所有模板的渲染测试，如下面的命令所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm template demoapp</span></span><br><span class="line">---</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Source: demoapp/templates/service.yaml</span></span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: RELEASE-NAME-demoapp</span><br><span class="line">  labels:</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>接着，再简单定制出demoapp/Chart.yaml文件的内容，确保其程序版本、Chart版本、维护者信息等能映射出项目的实际情况，一个自定义的Chart就已然初具雏形。下面给出了一个Chart.yaml文件的基础内容示例。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v2</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">demoapp</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">A</span> <span class="string">kubernetes-native</span> <span class="string">application</span> <span class="string">demo.</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">application</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">appVersion:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">maintainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MageEdu</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">mage@magedu.com</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.magedu.com</span></span><br></pre></td></tr></table></figure>

<p>另外，若有必要，还可以修改demoapp/templates/NOTE.txt文件的内容，以帮助用户快速获取到该应用的简要使用说明。随后，我们便可通过专用于发现Chart中存在问题的helm lint命令对自定义Chart进行合规性校验，以确保自定义Chart能够遵循最佳实践且有着良好的模板格式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm lint demoapp</span></span><br><span class="line">==&gt; Linting demoapp</span><br><span class="line">[INFO] Chart.yaml: icon is recommended   # 提示类日志信息，建议为Chart添加icon的定义</span><br><span class="line"></span><br><span class="line">1 chart(s) linted, 0 chart(s) failed</span><br></pre></td></tr></table></figure>

<p>大多数情况下，该命令的错误提示及其标识的行号信息即能定位到问题所在。待确保关键问题都得到解决之后，即可通过helm install命令调试运行该Chart，以确认其定义的容器化应用是否能以期望的方式完成部署并成功运行。为了说明如何通过命令行选项向模板传递参数，这里特地通过service.type来设定相关Service的类型为NodePort。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm install demoapp --debug ./demoapp/ --dry-run -n default --<span class="built_in">set</span> service.type=NodePort</span></span><br><span class="line">install.go:159: [debug] Original chart version: &quot;&quot;</span><br><span class="line">install.go:176: [debug] CHART PATH: ……/chapter14/helm/demoapp</span><br><span class="line"></span><br><span class="line">NAME: demoapp</span><br><span class="line">LAST DEPLOYED: Wed Oct 21 14:51:28 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: pending-install</span><br><span class="line">REVISION: 1</span><br><span class="line">USER-SUPPLIED VALUES:  # 用户自定义值</span><br><span class="line">service:</span><br><span class="line">  type: NodePort       # Service的类型为NodePort，而不再是默认的ClusterIP</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>确认上述命令输出信息无误后，移除命令中的–dry-run选项后再次运行命令即可完成应用部署，如下面的命令及结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm install demoapp ./demoapp/  -n default --<span class="built_in">set</span> service.type=NodePort</span>                 </span><br><span class="line">NAME: demoapp</span><br><span class="line">LAST DEPLOYED: Wed Oct 21 14:51:28 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:  # 简要使用说明</span><br><span class="line">1. Get the application URL by running these commands:</span><br><span class="line">  export NODE_PORT=$(kubectl get --namespace default -o jsonpath=&quot;&#123;.spec.ports[0].nodePort&#125;&quot; services demoapp)</span><br><span class="line">  export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath=&quot;&#123;.items[0].status.addresses[0].address&#125;&quot;)</span><br><span class="line">  echo http://$NODE_IP:$NODE_PORT</span><br></pre></td></tr></table></figure>

<p>而后，根据上述NOTES中的命令提示，运行相关的命令获取访问端点后即可通过浏览器访问相应的服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">export</span> NODE_PORT=$(kubectl get --namespace default \</span></span><br><span class="line"><span class="language-bash">  -o jsonpath=<span class="string">&quot;&#123;.spec.ports[0].nodePort&#125;&quot;</span> services demoapp)</span> </span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">export</span> NODE_IP=$(kubectl get nodes --namespace default \</span></span><br><span class="line"><span class="language-bash">  -o jsonpath=<span class="string">&quot;&#123;.items[0].status.addresses[0].address&#125;&quot;</span>)</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">echo</span> http://<span class="variable">$NODE_IP</span>:<span class="variable">$NODE_PORT</span></span></span><br><span class="line">http://172.29.9.1:31586</span><br></pre></td></tr></table></figure>

<p>上面最后一个命令返回了在集群外部通过NodePort访问该Release部署的相关服务的可用端点之一。当然，我们也可以启用Ingress资源，并借助Ingress控制器来发布该服务。下面是一个自定义的值文件，它仅指明了要启用的Ingress资源，并给出了适用的Ingress控制器类别及HTTP路由相关的配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.ik8s.io</span></span><br><span class="line">      <span class="attr">paths:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<p>通过-f选项将该文件附加于helm install命令即可将其合并到Chart默认的值文件上，例如下面的命令基于自定义的demoapp Chart创建了第二个实例，它通过Ingress将服务发布到集群之外。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">~$</span> <span class="string">helm</span> <span class="string">install</span> <span class="string">demoapp-2</span> <span class="string">./demoapp/</span>  <span class="string">--debug</span> <span class="string">-n</span> <span class="string">default</span> <span class="string">-f</span> <span class="string">./demoapp-values.yaml</span></span><br><span class="line"><span class="string">……</span></span><br><span class="line"><span class="comment"># Source: demoapp/templates/ingress.yaml   # 基于ingress.yaml模板渲染生成的Ingress资源</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">demoapp-2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">helm.sh/chart:</span> <span class="string">demoapp-0.1.0</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">demoapp</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/instance:</span> <span class="string">demoapp-2</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/version:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/managed-by:</span> <span class="string">Helm</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">&quot;www.ik8s.io&quot;</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">demoapp-2</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">NOTES:</span>   <span class="comment"># 生成的简要使用说明</span></span><br><span class="line"><span class="attr">1. Get the application URL by running these commands:</span></span><br><span class="line">  <span class="string">http://www.ik8s.io/</span></span><br></pre></td></tr></table></figure>

<p>若Kubernetes集群有正常运行的Ingress Nginx控制器，根据使用提示，我们在集群外的客户端上发起请求测试，便能够正常访问demoapp的相关服务。如下面在集群外的客户端上执行的访问请求命令结果所示，其中32012是此前部署的Ingress Nginx控制器的Service资源对应于80端口的NodePort。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">curl -H <span class="string">&quot;Host: www.ik8s.io&quot;</span> 172.29.9.13:32012/</span></span><br><span class="line">iKubernetes demoapp v1.0 !! ……: demoapp-2-58f68ffb4d-vwb9k, ServerIP: 10.244.1.19!</span><br></pre></td></tr></table></figure>

<p>类似地，若需要自定义模板文件支持的其他配置，修改值文件中的配置项即可。而需要用到其他非默认支持的资源，例如Role和RoleBinding，甚至是其他通过CRD定义的CR资源等，就需要用户自行开发并添加相应的模板文件，以及在值文件中添加相关参数的默认值等。3. 打包及分享<br>测试完成的自定义Chart可打包后存储在目标仓库仅供自己或有限范围内的用户使用，也可按需公开回馈到社区之中。helm package命令基于众多选项提供了灵活的打包机制，如下的命令就会先更新依赖关系再进行打包操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm package -u --debug demoapp</span></span><br><span class="line">Successfully packaged chart and saved it to: ……/helm/demoapp-0.1.0.tgz</span><br></pre></td></tr></table></figure>

<p>该命令通过Chart.yaml文件中定义的版本等信息生成打包后的文件名称，且默认将打包后的文件存储在当前工作目录中，但也允许用户通过-d选项指定目标路径，随后即可将打包完成的Chart上传到仓库中。<br>从较为抽象的意义上来说，Chart仓库就是可以存储和共享Chart的HTTP/HTTPS服务器，它由索引文件index.yaml及打包的Chart共同组成，Helm客户端负责将Chart打包并存储到仓库之中。对于使用Harbor项目实现本地镜像服务的场景来说，这通常是用于内部分享自定义Chart的较优选择。<br>假设，我们拥有可访问的Harbor服务，即<a target="_blank" rel="noopener" href="https://hub.ilinux.io上名为ikubernetes的公开项目,则该项目中的helm/">https://hub.ilinux.io上名为ikubernetes的公开项目，则该项目中的Helm</a> Charts标签用于展示Chart仓库的相关信息，如图14-3所示。<br><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224211551538.png" alt="image-20220224211551538">该类Chart的仓库地址为<a target="_blank" rel="noopener" href="https://hub.ilinux.io/chartrepo/">https://hub.ilinux.io/chartrepo/</a><PROJECT>，其中的/chartrepo为固定的端点路径，下面的命令就用于将该仓库添加至本地helm命令的可用列表中。</PROJECT></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm repo add ikubernetes https://hub.ilinux.io/chartrepo/ikubernetes</span></span><br><span class="line">&quot;ikubernetes&quot; has been added to your repositories</span><br></pre></td></tr></table></figure>

<p>Harbor的部署方式请参考14.4节的内容；另外，若Harbor使用的是私有CA签署的TLS证书，则需要用户手动将该CA证书系统上默认的证书加载到路径中，例如Ubuntu系统上的/etc/ssl/certs目录等。<br>接下来，我们可以直接点击如图14-3中的“上传”按钮在Web GUI中完成Chart上传，也可以为helm添加向仓库推送Chart的push插件，以便直接通过命令行完成Chart上传。Helm的插件管理子命令为plugin，下面的命令就用于安装push插件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm plugin install https://github.com/chartmuseum/helm-push.git</span></span><br><span class="line">Downloading and installing helm-push v...</span><br><span class="line">https://github.com/chartmuseum/helm-push/releases/download/v.../helm-push_..._amd64.tar.gz</span><br><span class="line">Installed plugin: push</span><br></pre></td></tr></table></figure>

<p>假设用户ik8sdev拥有该仓库上传数据的权限，该用户登录Harbor服务的密码为iK8Sdev123，则下面的命令就能够把本地工作目录中与demoapp项目相关的Chart自动上传到指定的仓库中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm push -u ik8sdev -p iK8Sdev123 demoapp ikubernetes</span></span><br><span class="line">Pushing demoapp-0.1.0.tgz to ikubernetes...</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<p>随后，能够访问该仓库的所有客户端即可获取并使用demoapp相关的Chart。尽管这种能满足最基本存储要求的Chart仓库API有着诸多优点，但有些缺点也已经到了无法忽视的地步，例如：很难完全兼容生产环境中大多数的安全机制；重复存储由不同用户上传的同一Chart，从而消耗更多的存储空间；基于单索引文件进行搜索机制不复用多租户环境等。于是，Helm 3开始支持将Chart推送到与OCI兼容的仓库中，例如各种类型的Docker Registry等。但截至本书定稿前，该特性仍处于实验阶段，默认并未启用。下面的命令先是使用环境变量来启用OCI格式的Chart，而后以该格式将Chart存入本地的缓存中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash"><span class="built_in">export</span> HELM_EXPERIMENTAL_OCI=1</span></span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">helm chart save demoapp hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span></span><br><span class="line">ref:     hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span><br><span class="line">digest:  004094ae1f3b21326e71c7045d9b7153b548b6f3436db0f75c67e68aea207065</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>Harbor项目中的镜像仓库主要用于存储OCI格式的镜像文件，因而它同样能够存储以该格式组织的Helm Chart。通常，镜像注册表（Registry）服务需要先检查客户端的认证和授权信息并生成临时Token，helm命令也不例外。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm registry login http://hub.ilinux.io</span></span><br><span class="line">Username: ik8sdev</span><br><span class="line">Password: </span><br><span class="line">Login succeeded</span><br><span class="line">随后即可推送OCI格式的Chart到Harbor指定项目的仓库中，下面的命令仍以ikubernetes项目为例来存储demoapp Chart。</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">helm chart push hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span></span><br><span class="line">The push refers to repository [hub.ilinux.io/ikubernetes/demoapp]</span><br><span class="line">ref:     hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span><br><span class="line">digest:  004094ae1f3b21326e71c7045d9b7153b548b6f3436db0f75c67e68aea207065</span><br><span class="line">size:    4.1 KiB</span><br><span class="line">name:    demoapp</span><br><span class="line">version: 0.1.0</span><br><span class="line">v0.1.0: pushed to remote (1 layer, 4.1 KiB total)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，OCI格式的Chart会存储在Harbor的镜像仓库而非Helm Chart仓库中，而且这些Chart需要通过helm chart pull命令下载，使用helm chart export命令从缓存中导出，如下面的两个命令及其结果所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$ </span><span class="language-bash">helm chart pull hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span></span><br><span class="line">v0.1.0: Pulling from hub.ilinux.io/ikubernetes/demoapp</span><br><span class="line">ref:     hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span><br><span class="line">digest:  004094ae1f3b21326e71c7045d9b7153b548b6f3436db0f75c67e68aea207065</span><br><span class="line">……</span><br><span class="line"><span class="meta">~$ </span><span class="language-bash">helm chart <span class="built_in">export</span> hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span></span><br><span class="line">ref:     hub.ilinux.io/ikubernetes/demoapp:v0.1.0</span><br><span class="line">……</span><br><span class="line">Exported chart to demoapp/</span><br></pre></td></tr></table></figure>

<p>实践中，上述两种分享方式提供一种即可，后一种虽有着更优越的特性和更好的兼容能力，但目前尚不建议用于生产环境之中。</p>
<h2 id="Helm实践：部署Harbor注册中心"><a href="#Helm实践：部署Harbor注册中心" class="headerlink" title="Helm实践：部署Harbor注册中心"></a>Helm实践：部署Harbor注册中心</h2><p>Harbor项目是用于存储和分发容器镜像的企业级Registry（注册中心）开源解决方案，它构建在Docker Registry项目（后来称为Docker Distribution）之上，为其添加了认证、授权、风险扫描等功能组件，能够满足生产环境的功能要求，其成熟度已得到CNCF社区及用户的认可。而自2.0版开始，Harbor正式成为完全符合OCI规范的云原生工件Registry，支持托管容器镜像、清单列表、Helm Chart、CNAB（Cloud Native Application Bundles）和OPA（Open Policy Agent）等所有遵循OCI规范的工件，并允许在这些工件上施加拉取、推送、删除打标、复制和安全扫描等管理操作。Harbor程序组件如图14-4所示。<br><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224211655608.png" alt="image-20220224211655608">从系统构成上来说，Harbor 2.0主要包括基础服务和数据存储两类组件，其中基础服务类组件主要包括以下几个。</p>
<ul>
<li>核心组件（Core）：Harbor的核心服务，主要包括API Server、API Controllers、Config Manager、Namespace Manager、Quota Manager、Chart Controller、Signature Manager、Retention Manager、Notification Manager、Replication Controller、Scan Manager、OCI Artifact Manager、Registry Driver和Traffic Proxy等，它们的功能几乎都能见名知义。</li>
<li>Registry：第三方项目，负责提供注册中心服务，用于存储、管理Docker镜像并响应客户端的管理请求。</li>
<li>Chart Museum：第三方项目，负责Helm Chart的存储、管理，并响应客户端的管理请求。</li>
<li>Notary：第三方项目，它基于健壮的数字签名机制为数字内容提供了高度安全的可信机制，是TUF（The Update Framework）规范的开源实现，确保通过网络发布和接收到内容的有效性与完整性。</li>
<li>Job Service：通用作业队列，其他组件或服务可以通过静态API接口同时提交、运行异步任务。</li>
<li>GC Collector：垃圾收集器，负责设定GC计划，以及启动和跟踪GC进度。</li>
<li>Log Collector：日志收集器，负责将其他组件的日志统一收集到指定的位置以便进行审计。</li>
<li>Web Portal：Harbor的Web GUI，用于向用户提供基于Web的图形用户接口。</li>
<li>Kubernetes上的Ingress或者自主管理的代理服务器：提供API路由功能，所有组件均位于该代理服务器之后。</li>
</ul>
<p>数据访问层上相应的各服务中，由Redis提供的键值存储系统为Harbor提供通用缓存层，也负责为Job Service存储作业元数据；关系型数据库主要负责存储Harbor系统模型中的各类逻辑组件的元数据，该类组件主要包括名称空间（也称为项目)、用户、角色、复制策略、标签保留策略、Chart和镜像等；本地或远程的数据存储服务主要为镜像或Helm Chart提供持久存储服务，它支持本地文件系统、S3、GCS、Azure、OSS和Swift等。</p>
<h3 id="部署方案与配置方式"><a href="#部署方案与配置方式" class="headerlink" title="部署方案与配置方式"></a>部署方案与配置方式</h3><p>目前，Harbor中的大多数组件都是无状态应用，我们可以通过简单地增加副本数量来提升其高可用性。但是，Chart Museum和Registry在本地存储客户端推送数据时，应该使用持久存储功能卷来确保数据的可用性，但二者也支持将客户端推送的Chart或容器镜像等数据存储到外部的存储系统中，例如S3或GCS等。在后一种方案中，存储卷便成了可选配置。另外，Job Service和Trivy也会依赖持久存储卷以便于从故障中安全恢复。<br>Harbor既支持使用外部的Redis服务，也支持使用自行管理的Redis存储系统，SQL存储服务有类似使用机制，但应用到生产环境时，它们都应该提供高可用的服务，如图14-5所示。<br><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224211844299.png" alt="image-20220224211844299">根据实际需求，Notary、Trivy和Clair都是可选组件。其中，Notary依赖于内部组件间的HTTPS安全通信机制，禁用内部HTTPS通信也将禁用Notary，同时Notary也支持由用户显式禁用。而Trivy和Clair都是Harbor支持的镜像文件漏洞分析服务，二者可同时启用，但仅有一个可以作为默认使用项，默认为Trivy。相关的配置都能够借助向Chart传递自定义值完成。<br>如前所述，Harbor依赖前端代理服务Nginx进行API路由，在Kubernetes环境中，我们可以使用Ingress来完成该功能，而且Ingress还能将相关服务发布到集群外部。但未启用Ingress时，Helm Chart会自行部署Nginx代理组件，该组件的Service也就成了Harbor的访问入口，设置Service类型为NodePort或LoadBalancer才能支持集群外部客户端访问。<br>截至目前，Harbor项目提供的Chart（v1.4.2）尚不支持PostgreSQL和Redis的高可用部署，因此，用户需要自行部署和管理这两个有状态应用。不过，Bitnami组织维护的Harbor Chart所依赖的Redis Chart和PostgreSQL Chart都提供了有着较好可用性的部署方案，因而接下来的部署示例中我们将选择Bitnami仓库中的Harbor Chart。<br>部署之前，我们可以使用helm show values bitnami/harbor命令获取到该Chart中默认的值文件的内容，根据实际需要改动其配置，而后根据自定义的值文件创建Release。下面的自定义值文件（harbor-values-with-longhorn-volumes.yaml)便是根据bitnami/harbor默认的值文件自定义而来，该文件尽量保留了可能会修改的选项。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 是否启用Harbor内部组件间的TLS通信，启用时要求各组件事先配备相应的TLS Secret</span></span><br><span class="line"><span class="comment">## 但在相应组件的tls.existingSecret字段值为空的场景时，Helm也会自动生成必要的Secret</span></span><br><span class="line"><span class="attr">internalTLS:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span>   <span class="comment"># 默认为false，对于机密性要求较高的场景可以将其修改为true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service:</span>           <span class="comment"># Harbor服务的整体定义</span></span><br><span class="line">  <span class="comment">## Kubernetes Service类型，支持Ingress、ClusterIP、NodePort和LoadBalancer 4</span></span><br><span class="line">  <span class="string">种取值</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>   <span class="comment"># 默认为LoadBalancer</span></span><br><span class="line">  <span class="attr">tls:</span>             <span class="comment"># 是否配置启用TLS服务接口</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">## 指定使用现有的Secret，它必须包含tls.crt和tls.key，可选数据项为ca.crt</span></span><br><span class="line">    <span class="attr">existingSecret:</span> <span class="string">&quot;&quot;</span>   <span class="comment"># 留空表示使用自动生成的自签证书</span></span><br><span class="line">    <span class="comment">## 默认Notary将使用上面指定的数字证书，或者使用下面参数指定的专用证书</span></span><br><span class="line">    <span class="attr">notaryExistingSecret:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment">## 自动生成证书时在Subject中使用CN名称，未启用Ingress时为必选项</span></span><br><span class="line">    <span class="attr">commonName:</span> <span class="string">&quot;hub.ilinux.io&quot;</span>   <span class="comment"># 一般要与Core的虚拟主机名称一致</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="attr">http:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">https:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">notary:</span> <span class="number">4443</span>   <span class="comment"># Notary使用的端口，notary.enabled为true时生效</span></span><br><span class="line">  <span class="attr">nodePorts:</span>       <span class="comment"># NodePort类型Service的专用参数</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">    <span class="attr">https:</span></span><br><span class="line">    <span class="attr">notary:</span></span><br><span class="line">  <span class="attr">loadBalancerIP:</span></span><br><span class="line">  <span class="attr">loadBalancerSourceRanges:</span> []</span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span>            <span class="comment"># 外部流量的处理策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Ingress相关的配置参数</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>         <span class="comment"># 是否启用Ingress，true意味着将不再运行独立的Nginx代理  </span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="attr">core:</span> <span class="string">hub.ilinux.io</span> <span class="comment"># Portal及Core组件相关的虚拟主机名称</span></span><br><span class="line">    <span class="attr">notary:</span> <span class="string">notary.ilinux.io</span>  <span class="comment"># Notary组件相关的虚拟主机名称</span></span><br><span class="line">  <span class="attr">controller:</span> <span class="string">nginx</span> <span class="comment"># 控制器类型，default可适配大多数类型，这里选择使用Nginx  annotations:</span></span><br><span class="line">    <span class="attr">ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;true&quot;</span>   <span class="comment"># 通用参数，将HTTP定向至HTTPS</span></span><br><span class="line">    <span class="attr">ingress.kubernetes.io/proxy-body-size:</span> <span class="string">&quot;0&quot;</span>   <span class="comment"># Proxy协议报文body上限</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/proxy-body-size:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Harbor Core服务对外的URL，启用Ingress时应该与ingress.hosts.core的值保持</span></span><br><span class="line"><span class="comment">## 一致，NodePort类型的Service应该使用某节点的IP地址；若位于代理服务器之后，</span></span><br><span class="line"><span class="comment">## 则应该使用代理服务器的URL</span></span><br><span class="line"><span class="attr">externalURL:</span> <span class="string">https://hub.ilinux.io</span></span><br><span class="line"></span><br><span class="line"><span class="attr">persistence:</span>                   <span class="comment"># 数据持久相关的配置项</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">resourcePolicy:</span> <span class="string">&quot;keep&quot;</span>       <span class="comment"># keep用于确保删除Release时保留数据</span></span><br><span class="line">  <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">    <span class="attr">registry:</span>                  <span class="comment"># registry的持久存储卷配置</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;&quot;</span>        <span class="comment"># 使用现有的PVC，留空表示从存储类中动态分配</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span> <span class="comment"># 支持动态PV供给功能的存储类，“-”表示禁用</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">accessMode:</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">5Gi</span>    <span class="comment"># 请求使用的PV大小，生产环境应该按实际存储需求调整该值</span></span><br><span class="line">    <span class="attr">jobservice:</span>                <span class="comment"># jobservice的持久存储卷配置</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">accessMode:</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">1Gi</span></span><br><span class="line">    <span class="attr">chartmuseum:</span>               <span class="comment"># chartmuseum的持久存储卷配置</span></span><br><span class="line">      <span class="attr">existingClaim:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">accessMode:</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">5Gi</span></span><br><span class="line">    <span class="attr">trivy:</span>                     <span class="comment"># trivy的持久存储卷配置</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span></span><br><span class="line">      <span class="attr">accessMode:</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">5Gi</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">## 定义registry和chartmuseum相关的后端存储服务</span></span><br><span class="line">  <span class="attr">imageChartStorage:</span></span><br><span class="line">    <span class="comment">## Secret资源名称，存储有验证后端服务证书的CA证书链</span></span><br><span class="line">    <span class="attr">caBundleSecretName:</span></span><br><span class="line">    <span class="comment">## 指定后端存储类型，可用值有filesystem、azure、gcs、s3、swift、oss</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">filesystem</span>   <span class="comment"># 本示例选择使用默认的文件系统，生产环境建议使用外部存储</span></span><br><span class="line">    <span class="attr">filesystem:</span></span><br><span class="line">      <span class="attr">rootdirectory:</span> <span class="string">/storage</span></span><br><span class="line">      <span class="attr">maxthreads:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 为了确保更新操作正确运行，设置是否强制用户指定密码，否则将使用随机密码串</span></span><br><span class="line"><span class="comment">## true表示将强制要求设定harborAdminPassword、core.secret和secretKey</span></span><br><span class="line"><span class="attr">forcePassword:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">harborAdminPassword:</span> <span class="string">MageEdu123</span>   <span class="comment"># Harbor上admin用户的初始密码</span></span><br><span class="line"><span class="attr">secretKey:</span>     <span class="comment"># 组件间基于TLS通信时进行加解密的密钥，必须是16个字符的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Harbor专用的代理服务，与Ingress互斥，二者选择其中之一</span></span><br><span class="line"><span class="attr">nginx:</span>         <span class="comment"># Nginx组件的专用配置</span></span><br><span class="line">  <span class="attr">command:</span>     <span class="comment"># 自定义要支持的程序</span></span><br><span class="line">  <span class="attr">args:</span>        <span class="comment"># 向程序传递自定义参数</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>  <span class="comment"># Nginx的Pod副本数，为提升服务可用性通常应该增加其副本数量</span></span><br><span class="line">  <span class="comment">## 仅对使用了RWO PV的场景有用；此种情形下，当replicas的值为1时，使用滚动更新策略将</span></span><br><span class="line">  <span class="comment">## 导致更新无法正确执行，此时必须要使用Recreate策略；以下几个组件的要求相同</span></span><br><span class="line">  <span class="attr">updateStrategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">core:</span>            <span class="comment"># Core组件的相关配置</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">tls:</span>           <span class="comment"># 内部组件间TLS通信时启用</span></span><br><span class="line">    <span class="attr">existingSecret:</span> <span class="string">&quot;&quot;</span>   <span class="comment"># 组件间TLS通信时加载证书和私钥的secret</span></span><br><span class="line">  <span class="attr">secretName:</span> <span class="string">&quot;&quot;</span> <span class="comment"># 使用指定Secret资源中的tls.crt和tls.key来加解密令牌</span></span><br><span class="line"></span><br><span class="line"><span class="attr">portal:</span>          <span class="comment"># Portal的相关配置，这里仅保留了副本数和更新策略的定义，后面的组件类似</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobservice:</span>      <span class="comment"># jobservice组件相关的配置</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">maxJobWorkers:</span> <span class="number">10</span>   <span class="comment"># jobservice的最大线程数，应该根据复制的任务量进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="attr">registry:</span>        <span class="comment"># registry组件相关的配置</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">chartmuseum:</span>     <span class="comment"># chartmeseum相关的配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 是否启用该功能</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">useRedisCache:</span> <span class="literal">true</span>          <span class="comment"># 是否使用Redis缓存</span></span><br><span class="line">  <span class="attr">chartRepoName:</span> <span class="string">&quot;chartsRepo&quot;</span>  <span class="comment"># Chart仓库的名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clair:</span>           <span class="comment"># clair相关的配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 是否启用该组件</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">trivy:</span>                <span class="comment"># trivy相关的配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>       <span class="comment"># 是否启用该组件</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">notary:</span>               <span class="comment"># Notary相关的配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>       <span class="comment"># 是否启用该组件</span></span><br><span class="line">  <span class="attr">server:</span>             <span class="comment"># notary server相关的配置</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">signer:</span>             <span class="comment"># notary signer相关的配置</span></span><br><span class="line">    <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">redis:</span>                <span class="comment"># Harbor Chart自行管理的redis组件相关的配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>       <span class="comment"># 是否启用</span></span><br><span class="line">  <span class="comment">## password: &quot;&quot;</span></span><br><span class="line">  <span class="attr">usePassword:</span> <span class="literal">false</span>  <span class="comment"># 是否使用密码</span></span><br><span class="line">  <span class="attr">cluster:</span>            <span class="comment"># redis cluster相关的配置</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>    <span class="comment"># 是否启用cluster</span></span><br><span class="line">  <span class="attr">master:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 是否启用持久存储卷</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span>   <span class="comment"># 动态分配PV时使用的StorageClass资源</span></span><br><span class="line">      <span class="attr">accessModes:</span>    <span class="comment"># PV的访问模型</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">8Gi</span>       <span class="comment"># PV的大小</span></span><br><span class="line">  <span class="attr">slave:</span></span><br><span class="line">    <span class="attr">persistence:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment"># 是否启用持久卷</span></span><br><span class="line">      <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span></span><br><span class="line">      <span class="attr">accessModes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">8Gi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">postgresql:</span>           <span class="comment"># Harbor Chart用于管理postgresql组件相关的配置</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>       <span class="comment"># 是否启用该组件</span></span><br><span class="line">  <span class="attr">postgresqlUsername:</span> <span class="string">postgres</span>   <span class="comment"># 数据库服务用户名</span></span><br><span class="line">  <span class="attr">postgresqlPassword:</span> <span class="string">not-secure-database-password</span>   <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">replication:</span>        <span class="comment"># 复制相关的配</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>    <span class="comment"># 是否启用复制功能</span></span><br><span class="line">  <span class="attr">persistence:</span>        <span class="comment"># 持久卷相关的配置</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span>     <span class="comment"># 是否启用持久卷</span></span><br><span class="line">    <span class="attr">storageClass:</span> <span class="string">&quot;longhorn&quot;</span>   <span class="comment"># 动态分配PV时使用的存储类</span></span><br><span class="line">    <span class="attr">accessModes:</span>      <span class="comment"># 存储卷访问模型</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">8Gi</span></span><br><span class="line"></span><br><span class="line"><span class="attr">externalRedis:</span>      <span class="comment"># 使用外部的Redis服务；启用Redis将禁用externalRedis</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span>   <span class="comment"># 获取外部Redis服务的主机地址</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">&quot;&quot;</span>      <span class="comment"># 服务密码</span></span><br><span class="line">  <span class="attr">jobserviceDatabaseIndex:</span> <span class="string">&quot;1&quot;</span>    <span class="comment"># jobservice使用的数据库名称</span></span><br><span class="line">  <span class="attr">registryDatabaseIndex:</span> <span class="string">&quot;2&quot;</span>      <span class="comment"># registry使用的数据库名称</span></span><br><span class="line">  <span class="attr">chartmuseumDatabaseIndex:</span> <span class="string">&quot;3&quot;</span>   <span class="comment"># chartmuseum使用的数据库名称</span></span><br><span class="line">  <span class="attr">clairAdapterDatabaseIndex:</span> <span class="string">&quot;4&quot;</span>  <span class="comment"># clairAdapter使用的数据库名称</span></span><br><span class="line">  <span class="attr">trivyAdapterDatabaseIndex:</span> <span class="string">&quot;5&quot;</span>  <span class="comment"># trivyAdapter使用的数据库名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">externalDatabase:</span>        <span class="comment"># 启用外部的数据库服务，启用了PostgreSQL就会禁用该功能</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">bn_harbor</span>        <span class="comment"># 用于访问Portal相关数据库的用户名</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">&quot;&quot;</span>           <span class="comment"># 密码</span></span><br><span class="line">  <span class="attr">sslmode:</span>               <span class="comment"># 是否工作于SSL通信模式</span></span><br><span class="line">  <span class="attr">coreDatabase:</span>          <span class="comment"># core组件相关的数据库名称</span></span><br><span class="line">  <span class="attr">clairDatabase:</span>         <span class="comment"># clair组件相关的数据库名称</span></span><br><span class="line">  <span class="attr">clairUsername:</span>         <span class="comment"># 访问clair数据的用户名，默认同Portal的配置</span></span><br><span class="line">  <span class="attr">clairPassword:</span>         <span class="comment"># 访问clair数据的密码，默认同Portal的配置</span></span><br><span class="line">  <span class="attr">notaryServerDatabase:</span>  <span class="comment"># notary server组件相关的数据库</span></span><br><span class="line">  <span class="attr">notaryServerUsername:</span></span><br><span class="line">  <span class="attr">notaryServerPassword:</span></span><br><span class="line">  <span class="attr">notarySignerDatabase:</span>  <span class="comment"># notary signer组件相关的数据库</span></span><br><span class="line">  <span class="attr">notarySignerUsername:</span></span><br><span class="line">  <span class="attr">notarySignerPassword:</span></span><br></pre></td></tr></table></figure>

<p>上面定义的值文件示例在名为Longhorn的存储类中为需要持久卷的各组件动态分配PV，该存储类建立在由CNCF组织孵化的Longhorn存储项目之上。若需要在未配备存储卷资源的环境中以非持久化方式进行测试，我们只需要将值文件中各persistence.enable的值置为false即可，我们在本章的源代码中提供了一份修改好的值文件（harbor-values-without-persistence.yaml）。另外，该示例保持Harbor各组件Pod副本数为默认值1，以便在资源紧缺的环境中进行测试，生产环境中，建议按需增加各组件的副本数量至合理值，以便更好地承担负载并提供更高的服务可用性。</p>
<h3 id="Harbor部署与测试"><a href="#Harbor部署与测试" class="headerlink" title="Harbor部署与测试"></a>Harbor部署与测试</h3><p>在启用了HTTPS的场景中，Ingress资源上指定的虚拟主机依赖保存在证书和私钥的Secret资源，Harbor Chart部署过程中会自行生成私有CA（harbor-ca），以及由该CA签署的证书文件，而后根据CA的证书、服务证书及私钥自动创建出必要的Secret资源来，这也是我们接下来的部署操作采用的方式。服务证书的CN名称由service.tls.commonName的值指定，或根据Ingress中host.core和host.notary的虚拟主机名确定。若需要使用自有的证书和私钥，将它们创建为Secret资源后，由值文件中的参数service.tls.existingSecret按名引用即可。另外，在启用了组件间TLS通信的场景中，建议由部署过程自行生成需要的各个证书文件。<br>为了便于资源隔离和管理，我们计划把Harbor部署到同名的专用名称空间之中。下面的命令先创建了名称空间，随后基于14.4.1节示例中使用的值文件将Harbor部署到该名称空间之内。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">~$</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">namespace</span> <span class="string">harbor</span></span><br><span class="line"><span class="string">~$</span> <span class="string">helm</span> <span class="string">install</span> <span class="string">hub</span> <span class="string">-f</span> <span class="string">harbor-values-with-longhorn-volumes.yaml</span> <span class="string">bitnami/harbor</span> <span class="string">-n</span> <span class="string">harbor</span></span><br><span class="line"><span class="attr">NAME:</span> <span class="string">hub</span></span><br><span class="line"><span class="attr">LAST DEPLOYED:</span> <span class="string">Sat</span> <span class="string">Aug</span> <span class="number">30</span> <span class="number">15</span><span class="string">:02:45</span> <span class="number">2020</span></span><br><span class="line"><span class="attr">NAMESPACE:</span> <span class="string">harbor</span>       <span class="comment"># 名称空间</span></span><br><span class="line"><span class="attr">STATUS:</span> <span class="string">deployed</span>        <span class="comment"># 部署状态</span></span><br><span class="line"><span class="attr">REVISION:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">TEST SUITE:</span> <span class="string">None</span>        <span class="comment"># 测试套件</span></span><br><span class="line"><span class="attr">NOTES:</span>                  <span class="comment"># 部署完成后的使用提示</span></span><br><span class="line"><span class="string">**</span> <span class="string">Please</span> <span class="string">be</span> <span class="string">patient</span> <span class="string">while</span> <span class="string">the</span> <span class="string">chart</span> <span class="string">is</span> <span class="string">being</span> <span class="string">deployed</span> <span class="string">**</span></span><br><span class="line"><span class="attr">1. Get the Harbor URL:</span>  <span class="comment"># 访问Harbor的入口</span></span><br><span class="line">  <span class="string">You</span> <span class="string">should</span> <span class="string">be</span> <span class="string">able</span> <span class="string">to</span> <span class="string">access</span> <span class="string">your</span> <span class="string">new</span> <span class="string">Harbor</span> <span class="string">installation</span> <span class="string">through</span> <span class="string">https://hub.ilinux.io</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">Login</span> <span class="string">with</span> <span class="string">the</span> <span class="string">following</span> <span class="string">credentials</span> <span class="string">to</span> <span class="string">see</span> <span class="string">your</span> <span class="string">Harbor</span> <span class="string">application</span>  <span class="comment"># 登录时的用户名和密码</span></span><br><span class="line">  <span class="attr">echo Username:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">  <span class="attr">echo Password:</span> <span class="string">$(kubectl</span> <span class="string">get</span> <span class="string">secret</span> <span class="string">--namespace</span> <span class="string">harbor</span> <span class="string">hub-harbor-core-envvars</span> <span class="string">\</span></span><br><span class="line"><span class="string">-o</span> <span class="string">jsonpath=&quot;&#123;.data.HARBOR_ADMIN_PASSWORD&#125;&quot;</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">--decode)</span></span><br></pre></td></tr></table></figure>

<p>随后，按照部署命令最后返回的提示，我们即可打开Harbor的Web GUI（见图14-6），并使用默认用户名admin及值文件中设定的管理员密码，或者根据上面命令获取到自动生成的默认密码进行服务访问。<br><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224212312835.png" alt="image-20220224212312835">Harbor将Docker镜像、Helm Chart以及CNAB应用等组织在项目或者名称空间的逻辑组件中，这些项目可以具有“公开”或“私有”的访问属性，library是默认的项目。Harbor基于RBAC管理项目上的用户授权，它内置了5个用户角色，允许用户在特定项目上设置不同的角色，从而实现简单的权限分配。<br>为了简单演示其应用，及便于读者测试14.4.1节将Helm Chart推送至Harbor进行管理的机制，我们需要创建一个名为ik8sdev的用户，一个名为ikubernetes的项目，而后为ik8sdev用户赋予该项目上的“开发人员”角色。而后即可在某主机上运行Docker命令，向该项目推送容器镜像以进行测试。<br>Harbor中的项目名称就是其Registry服务的名称空间，因此对于ikubernetes项目来说，其内部镜像仓库遵循hub.ilinux.io/ ikubernetes/REPOSITORY[:TAG]的标识格式。但下面第二个推送命令出现了错误，原因在于Docker不信任签署hub.ilinux.io证书的私有CA，我们可通过如下的命令结果看到这种错误提示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~# </span><span class="language-bash">docker image tag ikubernetes/demoapp:v1.0 hub.ilinux.io/ikubernetes/demoapp:v1.0</span></span><br><span class="line"><span class="meta">~# </span><span class="language-bash">docker image push hub.ilinux.io/ikubernetes/demoapp:v1.0</span></span><br><span class="line">The push refers to repository [hub.ilinux.io/ikubernetes/demoapp]</span><br><span class="line">Get https://hub.ilinux.io/v2/: x509: certificate signed by unknown authority</span><br></pre></td></tr></table></figure>

<p>简单解决办法是把Harbor自动生成的CA证书添加到系统上受信任的集合中，在Ubuntu系统上，该集合通常指的是/etc/ssl/certs/目录，而RedHat及其克隆版的系统环境中通常使用的是/etc/pki/ca-trust/source/anchors/目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~# </span><span class="language-bash">wget --no-check-certificate -q https://hub.ilinux.io/api/v2.0/systeminfo/getcert \</span></span><br><span class="line"><span class="language-bash">-O /etc/ssl/certs/harbor-ca.crt</span></span><br><span class="line"><span class="meta">~# </span><span class="language-bash">systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>随后，重启Docker守护进程，让ikubernetes项目加载并信任Harbor的私有CA之后即可完成用户登录及容器镜像推送操作，推送完成后，Harbor的GUI界面中的ikubernetes项目如图14-7所示。</p>
<p><img src="/blog/2022/03/02/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomizeimage/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86-helm%E3%80%81Kustomize/image-20220224212326053.png" alt="image-20220224212326053"></p>
<p>Helm Chart的推送请参考14.4.1节的内容，这里不再给出具体的过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~# </span><span class="language-bash">docker login hub.ilinux.io</span></span><br><span class="line"><span class="meta">~# </span><span class="language-bash">docker image push hub.ilinux.io/ikubernetes/demoapp:v1.0</span></span><br><span class="line">The push refers to repository [hub.ilinux.io/ikubernetes/demoapp]</span><br><span class="line">5a4de022ffa3: Pushed </span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>Harbor 2.0还支持LDAP/UAA/OIDC外部认证、仓库间镜像数据的异步复制等多种功能，感兴趣的读者可通过Harbor项目的文档详细了解和探索其使用方法。</p>
<p>14.5　本章小结<br>目前来说，Kubernetes部署及管理应用程序的接口仍然相当复杂，当维护较多的资源时，用户必然会受困于复杂多变的资源配置清单，Kustomize以声明式机制进一步丰富了应用的编排能力，而Helm则通过Chart实现了类似yum、dnf或apt-get等程序包管理器的功能，大大降低了用户的使用成本。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Kubernetes/" rel="tag"># Kubernetes</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/02/28/Kubernetes%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90/" rel="prev" title="Kubernetes自定义资源">
      <i class="fa fa-chevron-left"></i> Kubernetes自定义资源
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">应用管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kustomize%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">Kustomize声明式应用管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">声明式应用管理基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE%E5%88%86%E8%A7%A3"><span class="nav-number">1.1.2.</span> <span class="nav-text">应用配置分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E8%A1%A5%E4%B8%81"><span class="nav-number">1.1.3.</span> <span class="nav-text">资源补丁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Helm%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">Helm基础应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Helm%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.1.</span> <span class="nav-text">Helm基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Helm-3%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">Helm 3快速入门</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Helm-Chart"><span class="nav-number">1.3.</span> <span class="nav-text">Helm Chart</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chart%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">Chart中的依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%80%BC"><span class="nav-number">1.3.2.</span> <span class="nav-text">模板与值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%9C%80%E8%A6%81%E8%AF%B4%E6%98%8E%E7%9A%84%E8%AF%9D%E9%A2%98"><span class="nav-number">1.3.3.</span> <span class="nav-text">其他需要说明的话题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Chart%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">自定义Chart简单示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E6%88%90Chart%E9%85%8D%E7%BD%AE%E6%A1%86%E6%9E%B6"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">生成Chart配置框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6Chart"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">定制Chart</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Helm%E5%AE%9E%E8%B7%B5%EF%BC%9A%E9%83%A8%E7%BD%B2Harbor%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-number">1.4.</span> <span class="nav-text">Helm实践：部署Harbor注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.1.</span> <span class="nav-text">部署方案与配置方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Harbor%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">Harbor部署与测试</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description">myBlog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
